diff -crB tmp/simplesim-3.0/config.h simplesim-3.0/config.h
*** tmp/simplesim-3.0/config.h	2003-10-08 21:14:59.000000000 -0500
--- simplesim-3.0/config.h	2003-10-08 21:19:13.000000000 -0500
***************
*** 1,4 ****
! /* config.h - SimpleScaler Alpha ISA configuration */
  
  /* SimpleScalar(TM) Tool Suite
   * Copyright (C) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
--- 1,4 ----
! /* config.h - SimpleScaler PISA ISA default configuration */
  
  /* SimpleScalar(TM) Tool Suite
   * Copyright (C) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
diff -crB tmp/simplesim-3.0/loader.c simplesim-3.0/loader.c
*** tmp/simplesim-3.0/loader.c	2003-10-08 21:16:35.000000000 -0500
--- simplesim-3.0/loader.c	2003-10-08 21:21:22.000000000 -0500
***************
*** 65,75 ****
  #ifdef BFD_LOADER
  #include <bfd.h>
  #else /* !BFD_LOADER */
! #include "target-alpha/ecoff.h"
  #endif /* BFD_LOADER */
  
  /* amount of tail padding added to all loaded text segments */
! #define TEXT_TAIL_PADDING 0 /* was: 128 */
  
  /* program text (code) segment base */
  md_addr_t ld_text_base = 0;
--- 65,75 ----
  #ifdef BFD_LOADER
  #include <bfd.h>
  #else /* !BFD_LOADER */
! #include "target-pisa/ecoff.h"
  #endif /* BFD_LOADER */
  
  /* amount of tail padding added to all loaded text segments */
! #define TEXT_TAIL_PADDING 128
  
  /* program text (code) segment base */
  md_addr_t ld_text_base = 0;
***************
*** 80,99 ****
  /* program initialized data segment base */
  md_addr_t ld_data_base = 0;
  
- /* top of the data segment */
- md_addr_t ld_brk_point = 0;
- 
  /* program initialized ".data" and uninitialized ".bss" size in bytes */
  unsigned int ld_data_size = 0;
  
  /* program stack segment base (highest address in stack) */
! md_addr_t ld_stack_base = 0;
  
  /* program initial stack size */
  unsigned int ld_stack_size = 0;
  
  /* lowest address accessed on the stack */
! md_addr_t ld_stack_min = -1;
  
  /* program file name */
  char *ld_prog_fname = NULL;
--- 80,99 ----
  /* program initialized data segment base */
  md_addr_t ld_data_base = 0;
  
  /* program initialized ".data" and uninitialized ".bss" size in bytes */
  unsigned int ld_data_size = 0;
  
+ /* top of the data segment */
+ md_addr_t ld_brk_point = 0;
+ 
  /* program stack segment base (highest address in stack) */
! md_addr_t ld_stack_base = MD_STACK_BASE;
  
  /* program initial stack size */
  unsigned int ld_stack_size = 0;
  
  /* lowest address accessed on the stack */
! md_addr_t ld_stack_min = (md_addr_t)-1;
  
  /* program file name */
  char *ld_prog_fname = NULL;
***************
*** 113,145 ****
  {
    stat_reg_addr(sdb, "ld_text_base",
  		"program text (code) segment base",
! 		&ld_text_base, ld_text_base, "0x%010p");
    stat_reg_uint(sdb, "ld_text_size",
  		"program text (code) size in bytes",
  		&ld_text_size, ld_text_size, NULL);
    stat_reg_addr(sdb, "ld_data_base",
  		"program initialized data segment base",
! 		&ld_data_base, ld_data_base, "0x%010p");
    stat_reg_uint(sdb, "ld_data_size",
  		"program init'ed `.data' and uninit'ed `.bss' size in bytes",
  		&ld_data_size, ld_data_size, NULL);
    stat_reg_addr(sdb, "ld_stack_base",
  		"program stack segment base (highest address in stack)",
! 		&ld_stack_base, ld_stack_base, "0x%010p");
  #if 0 /* FIXME: broken... */
    stat_reg_addr(sdb, "ld_stack_min",
  		"program stack segment lowest address",
! 		&ld_stack_min, ld_stack_min, "0x%010p");
  #endif
-   stat_reg_uint(sdb, "ld_stack_size",
- 		"program initial stack size",
- 		&ld_stack_size, ld_stack_size, NULL);
    stat_reg_addr(sdb, "ld_prog_entry",
  		"program entry point (initial PC)",
! 		&ld_prog_entry, ld_prog_entry, "0x%010p");
    stat_reg_addr(sdb, "ld_environ_base",
  		"program environment base address address",
! 		&ld_environ_base, ld_environ_base, "0x%010p");
    stat_reg_int(sdb, "ld_target_big_endian",
  	       "target executable endian-ness, non-zero if big endian",
  	       &ld_target_big_endian, ld_target_big_endian, NULL);
--- 113,145 ----
  {
    stat_reg_addr(sdb, "ld_text_base",
  		"program text (code) segment base",
! 		&ld_text_base, ld_text_base, "  0x%08p");
    stat_reg_uint(sdb, "ld_text_size",
  		"program text (code) size in bytes",
  		&ld_text_size, ld_text_size, NULL);
    stat_reg_addr(sdb, "ld_data_base",
  		"program initialized data segment base",
! 		&ld_data_base, ld_data_base, "  0x%08p");
    stat_reg_uint(sdb, "ld_data_size",
  		"program init'ed `.data' and uninit'ed `.bss' size in bytes",
  		&ld_data_size, ld_data_size, NULL);
    stat_reg_addr(sdb, "ld_stack_base",
  		"program stack segment base (highest address in stack)",
! 		&ld_stack_base, ld_stack_base, "  0x%08p");
!   stat_reg_uint(sdb, "ld_stack_size",
! 		"program initial stack size",
! 		&ld_stack_size, ld_stack_size, NULL);
  #if 0 /* FIXME: broken... */
    stat_reg_addr(sdb, "ld_stack_min",
  		"program stack segment lowest address",
! 		&ld_stack_min, ld_stack_min, "  0x%08p");
  #endif
    stat_reg_addr(sdb, "ld_prog_entry",
  		"program entry point (initial PC)",
! 		&ld_prog_entry, ld_prog_entry, "  0x%08p");
    stat_reg_addr(sdb, "ld_environ_base",
  		"program environment base address address",
! 		&ld_environ_base, ld_environ_base, "  0x%08p");
    stat_reg_int(sdb, "ld_target_big_endian",
  	       "target executable endian-ness, non-zero if big endian",
  	       &ld_target_big_endian, ld_target_big_endian, NULL);
***************
*** 157,163 ****
  	     int zero_bss_segs)		/* zero uninit data segment? */
  {
    int i;
!   qword_t temp;
    md_addr_t sp, data_break = 0, null_ptr = 0, argv_addr, envp_addr;
  
    if (eio_valid(fname))
--- 157,163 ----
  	     int zero_bss_segs)		/* zero uninit data segment? */
  {
    int i;
!   word_t temp;
    md_addr_t sp, data_break = 0, null_ptr = 0, argv_addr, envp_addr;
  
    if (eio_valid(fname))
***************
*** 215,229 ****
  #ifdef MD_CROSS_ENDIAN
    else
      {
!       warn("endian of `%s' does not match host", fname);
!       warn("running with experimental cross-endian execution support");
!       warn("****************************************");
!       warn("**>> please check results carefully <<**");
!       warn("****************************************");
! #if 0
!       fatal("SimpleScalar/Alpha only supports binary execution on\n"
! 	    "       little-endian hosts, use EIO files on big-endian hosts");
! #endif
      }
  #endif /* MD_CROSS_ENDIAN */
  
--- 215,222 ----
  #ifdef MD_CROSS_ENDIAN
    else
      {
!       fatal("SimpleScalar/PISA only supports binary execution on\n"
! 	    "       same-endian hosts, use EIO files on cross-endian hosts");
      }
  #endif /* MD_CROSS_ENDIAN */
  
***************
*** 239,245 ****
      /* set up a local stack pointer, this is where the argv and envp
         data is written into program memory */
      ld_stack_base = MD_STACK_BASE;
!     sp = ROUND_DOWN(MD_STACK_BASE - MD_MAX_ENVIRON, sizeof(MD_DOUBLE_TYPE));
      ld_stack_size = ld_stack_base - sp;
  
      /* initial stack pointer value */
--- 233,239 ----
      /* set up a local stack pointer, this is where the argv and envp
         data is written into program memory */
      ld_stack_base = MD_STACK_BASE;
!     sp = ROUND_DOWN(MD_STACK_BASE - MD_MAX_ENVIRON, sizeof(dfloat_t));
      ld_stack_size = ld_stack_base - sp;
  
      /* initial stack pointer value */
***************
*** 296,302 ****
  		    bfd_section_name(abfd, sect));
  
  	    /* copy program section it into simulator target memory */
! 	    mem_bcopy(mem_fn, Write, bfd_section_vma(abfd, sect),
  		      p, bfd_section_size(abfd, sect));
  
  	    /* release the section buffer */
--- 290,296 ----
  		    bfd_section_name(abfd, sect));
  
  	    /* copy program section it into simulator target memory */
! 	    mem_bcopy(mem_access, mem, Write, bfd_section_vma(abfd, sect),
  		      p, bfd_section_size(abfd, sect));
  
  	    /* release the section buffer */
***************
*** 309,315 ****
  		 && bfd_section_size(abfd, sect))
  	  {
  	    /* zero out the section region */
! 	    mem_bzero(mem_fn,
  		      bfd_section_vma(abfd, sect),
  		      bfd_section_size(abfd, sect));
  	  }
--- 303,309 ----
  		 && bfd_section_size(abfd, sect))
  	  {
  	    /* zero out the section region */
! 	    mem_bzero(mem_access, mem,
  		      bfd_section_vma(abfd, sect),
  		      bfd_section_size(abfd, sect));
  	  }
***************
*** 330,341 ****
  		+ /* for speculative fetches/decodes */TEXT_TAIL_PADDING;
  
  	    /* create tail padding and copy into simulator target memory */
! #if 0
! 	    mem_bzero(mem_fn,
  		      bfd_section_vma(abfd, sect)
  		      + bfd_section_size(abfd, sect),
  		      TEXT_TAIL_PADDING);
- #endif
  	  }
  	/* expected data sections */
  	else if (!strcmp(bfd_section_name(abfd, sect), ".rdata")
--- 324,333 ----
  		+ /* for speculative fetches/decodes */TEXT_TAIL_PADDING;
  
  	    /* create tail padding and copy into simulator target memory */
! 	    mem_bzero(mem_access, mem,
  		      bfd_section_vma(abfd, sect)
  		      + bfd_section_size(abfd, sect),
  		      TEXT_TAIL_PADDING);
  	  }
  	/* expected data sections */
  	else if (!strcmp(bfd_section_name(abfd, sect), ".rdata")
***************
*** 379,384 ****
--- 371,385 ----
      struct ecoff_aouthdr ahdr;
      struct ecoff_scnhdr shdr;
  
+     /* set up a local stack pointer, this is where the argv and envp
+        data is written into program memory */
+     ld_stack_base = MD_STACK_BASE;
+     sp = ROUND_DOWN(MD_STACK_BASE - MD_MAX_ENVIRON, sizeof(dfloat_t));
+     ld_stack_size = ld_stack_base - sp;
+ 
+     /* initial stack pointer value */
+     ld_environ_base = sp;
+ 
      /* record profile file name */
      ld_prog_fname = argv[0];
  
***************
*** 395,435 ****
        fatal("cannot read header from executable `%s'", argv[0]);
  
      /* record endian of target */
!     if (fhdr.f_magic == MD_SWAPH(ECOFF_ALPHAMAGIC))
        ld_target_big_endian = FALSE;
!     else if (fhdr.f_magic == MD_SWAPH(ECOFF_EB_MAGIC)
! 	     || fhdr.f_magic == MD_SWAPH(ECOFF_EL_MAGIC)
! 	     || fhdr.f_magic == MD_SWAPH(ECOFF_EB_OTHER)
! 	     || fhdr.f_magic == MD_SWAPH(ECOFF_EL_OTHER))
!       fatal("Alpha simulator cannot run PISA binary `%s'", argv[0]);
      else
!       fatal("bad magic number in executable `%s' (not an executable)",
  	    argv[0]);
  
      if (fread(&ahdr, sizeof(struct ecoff_aouthdr), 1, fobj) < 1)
        fatal("cannot read AOUT header from executable `%s'", argv[0]);
  
!     ld_text_base = MD_SWAPQ(ahdr.text_start);
!     ld_text_size = MD_SWAPQ(ahdr.tsize);
!     ld_prog_entry = MD_SWAPQ(ahdr.entry);
!     ld_data_base = MD_SWAPQ(ahdr.data_start);
!     ld_data_size = MD_SWAPQ(ahdr.dsize) + MD_SWAPQ(ahdr.bsize);
!     regs->regs_R[MD_REG_GP] = MD_SWAPQ(ahdr.gp_value);
  
!     /* compute data segment size from data break point */
!     data_break = ld_data_base + ld_data_size;
  
      /* seek to the beginning of the first section header, the file header comes
         first, followed by the optional header (this is the aouthdr), the size
         of the aouthdr is given in Fdhr.f_opthdr */
!     fseek(fobj, sizeof(struct ecoff_filehdr) + MD_SWAPH(fhdr.f_opthdr), 0);
  
!     debug("processing %d sections in `%s'...",
! 	  MD_SWAPH(fhdr.f_nscns), argv[0]);
  
      /* loop through the section headers */
      floc = ftell(fobj);
!     for (i = 0; i < MD_SWAPH(fhdr.f_nscns); i++)
        {
  	char *p;
  
--- 396,437 ----
        fatal("cannot read header from executable `%s'", argv[0]);
  
      /* record endian of target */
!     if (fhdr.f_magic == ECOFF_EB_MAGIC)
!       ld_target_big_endian = TRUE;
!     else if (fhdr.f_magic == ECOFF_EL_MAGIC)
        ld_target_big_endian = FALSE;
!     else if (fhdr.f_magic == ECOFF_EB_OTHER || fhdr.f_magic == ECOFF_EL_OTHER)
!       fatal("PISA binary `%s' has wrong endian format", argv[0]);
!     else if (fhdr.f_magic == ECOFF_ALPHAMAGIC)
!       fatal("PISA simulator cannot run Alpha binary `%s'", argv[0]);
      else
!       fatal("bad magic number in executable `%s' (not an executable?)",
  	    argv[0]);
  
      if (fread(&ahdr, sizeof(struct ecoff_aouthdr), 1, fobj) < 1)
        fatal("cannot read AOUT header from executable `%s'", argv[0]);
  
!     data_break = MD_DATA_BASE + ahdr.dsize + ahdr.bsize;
  
! #if 0
!     Data_start = ahdr.data_start;
!     Data_size = ahdr.dsize;
!     Bss_size = ahdr.bsize;
!     Bss_start = ahdr.bss_start;
!     Gp_value = ahdr.gp_value;
!     Text_entry = ahdr.entry;
! #endif
  
      /* seek to the beginning of the first section header, the file header comes
         first, followed by the optional header (this is the aouthdr), the size
         of the aouthdr is given in Fdhr.f_opthdr */
!     fseek(fobj, sizeof(struct ecoff_filehdr) + fhdr.f_opthdr, 0);
  
!     debug("processing %d sections in `%s'...", fhdr.f_nscns, argv[0]);
  
      /* loop through the section headers */
      floc = ftell(fobj);
!     for (i = 0; i < fhdr.f_nscns; i++)
        {
  	char *p;
  
***************
*** 439,474 ****
  	  fatal("could not read section %d from executable", i);
  	floc = ftell(fobj);
  
! 	switch (MD_SWAPW(shdr.s_flags))
  	  {
  	  case ECOFF_STYP_TEXT:
! 	    p = calloc(MD_SWAPQ(shdr.s_size), sizeof(char));
  	    if (!p)
  	      fatal("out of virtual memory");
  
! 	    if (fseek(fobj, MD_SWAPQ(shdr.s_scnptr), 0) == -1)
  	      fatal("could not read `.text' from executable", i);
! 	    if (fread(p, MD_SWAPQ(shdr.s_size), 1, fobj) < 1)
  	      fatal("could not read text section from executable");
  
  	    /* copy program section into simulator target memory */
! 	    mem_bcopy(mem_access, mem, Write,
! 		      MD_SWAPQ(shdr.s_vaddr), p, MD_SWAPQ(shdr.s_size));
  
- #if 0
  	    /* create tail padding and copy into simulator target memory */
  	    mem_bzero(mem_access, mem,
! 		      MD_SWAPQ(shdr.s_vaddr) + MD_SWAPQ(shdr.s_size),
! 		      TEXT_TAIL_PADDING);
! #endif
! 
  	    /* release the section buffer */
  	    free(p);
  
  #if 0
! 	    Text_seek = MD_SWAPQ(shdr.s_scnptr);
! 	    Text_start = MD_SWAPQ(shdr.s_vaddr);
! 	    Text_size = MD_SWAPQ(shdr.s_size) / 4;
  	    /* there is a null routine after the supposed end of text */
  	    Text_size += 10;
  	    Text_end = Text_start + Text_size * 4;
--- 441,475 ----
  	  fatal("could not read section %d from executable", i);
  	floc = ftell(fobj);
  
! 	switch (shdr.s_flags)
  	  {
  	  case ECOFF_STYP_TEXT:
! 	    ld_text_size = ((shdr.s_vaddr + shdr.s_size) - MD_TEXT_BASE) 
! 	      + TEXT_TAIL_PADDING;
! 
! 	    p = calloc(shdr.s_size, sizeof(char));
  	    if (!p)
  	      fatal("out of virtual memory");
  
! 	    if (fseek(fobj, shdr.s_scnptr, 0) == -1)
  	      fatal("could not read `.text' from executable", i);
! 	    if (fread(p, shdr.s_size, 1, fobj) < 1)
  	      fatal("could not read text section from executable");
  
  	    /* copy program section into simulator target memory */
! 	    mem_bcopy(mem_access, mem, Write, shdr.s_vaddr, p, shdr.s_size);
  
  	    /* create tail padding and copy into simulator target memory */
  	    mem_bzero(mem_access, mem,
! 		      shdr.s_vaddr + shdr.s_size, TEXT_TAIL_PADDING);
!   
  	    /* release the section buffer */
  	    free(p);
  
  #if 0
! 	    Text_seek = shdr.s_scnptr;
! 	    Text_start = shdr.s_vaddr;
! 	    Text_size = shdr.s_size / 4;
  	    /* there is a null routine after the supposed end of text */
  	    Text_size += 10;
  	    Text_end = Text_start + Text_size * 4;
***************
*** 476,566 ****
  #endif
  	    break;
  
- 	  case ECOFF_STYP_INIT:
- 	  case ECOFF_STYP_FINI:
- 	    if (MD_SWAPQ(shdr.s_size) > 0)
- 	      {
- 		p = calloc(MD_SWAPQ(shdr.s_size), sizeof(char));
- 		if (!p)
- 		  fatal("out of virtual memory");
- 		
- 		if (fseek(fobj, MD_SWAPQ(shdr.s_scnptr), 0) == -1)
- 		  fatal("could not read `.text' from executable", i);
- 		if (fread(p, MD_SWAPQ(shdr.s_size), 1, fobj) < 1)
- 		  fatal("could not read text section from executable");
- 		
- 		/* copy program section into simulator target memory */
- 		mem_bcopy(mem_access, mem,
- 			  Write, MD_SWAPQ(shdr.s_vaddr),
- 			  p, MD_SWAPQ(shdr.s_size));
- 		
- 		/* release the section buffer */
- 		free(p);
- 	      }
- 	    else
- 	      warn("section `%s' is empty...", shdr.s_name);
- 	    break;
- 
- 	  case ECOFF_STYP_LITA:
- 	  case ECOFF_STYP_LIT8:
- 	  case ECOFF_STYP_LIT4:
- 	  case ECOFF_STYP_XDATA:
- 	  case ECOFF_STYP_PDATA:
- 	  case ECOFF_STYP_RCONST:
- 	    /* fall through */
- 
  	  case ECOFF_STYP_RDATA:
  	    /* The .rdata section is sometimes placed before the text
  	     * section instead of being contiguous with the .data section.
  	     */
  #if 0
! 	    Rdata_start = MD_SWAPQ(shdr.s_vaddr);
! 	    Rdata_size = MD_SWAPQ(shdr.s_size);
! 	    Rdata_seek = MD_SWAPQ(shdr.s_scnptr);
  #endif
  	    /* fall through */
  	  case ECOFF_STYP_DATA:
  #if 0
! 	    Data_seek = MD_SWAPQ(shdr.s_scnptr);
  #endif
  	    /* fall through */
  	  case ECOFF_STYP_SDATA:
  #if 0
! 	    Sdata_seek = MD_SWAPQ(shdr.s_scnptr);
  #endif
! 	    if (MD_SWAPQ(shdr.s_size) > 0)
! 	      {
! 		p = calloc(MD_SWAPQ(shdr.s_size), sizeof(char));
! 		if (!p)
! 		  fatal("out of virtual memory");
! 
! 		if (fseek(fobj, MD_SWAPQ(shdr.s_scnptr), 0) == -1)
! 		  fatal("could not read `.text' from executable", i);
! 		if (fread(p, MD_SWAPQ(shdr.s_size), 1, fobj) < 1)
! 		  fatal("could not read text section from executable");
! 
! 		/* copy program section it into simulator target memory */
! 		mem_bcopy(mem_access, mem,
! 			  Write, MD_SWAPQ(shdr.s_vaddr),
! 			  p, MD_SWAPQ(shdr.s_size));
! 
! 		/* release the section buffer */
! 		free(p);
! 	      }
! 	    else
! 	      warn("section `%s' is empty...", shdr.s_name);
! 	  break;
  
  	  case ECOFF_STYP_BSS:
- 	  case ECOFF_STYP_SBSS:
- 	    /* no data to read... */
  	    break;
  
! 	  default:
! 	    warn("section `%s' ignored...", shdr.s_name);
  	  }
        }
  
      /* done with the executable, close it */
      if (fclose(fobj))
        fatal("could not close executable `%s'", argv[0]);
--- 477,533 ----
  #endif
  	    break;
  
  	  case ECOFF_STYP_RDATA:
  	    /* The .rdata section is sometimes placed before the text
  	     * section instead of being contiguous with the .data section.
  	     */
  #if 0
! 	    Rdata_start = shdr.s_vaddr;
! 	    Rdata_size = shdr.s_size;
! 	    Rdata_seek = shdr.s_scnptr;
  #endif
  	    /* fall through */
  	  case ECOFF_STYP_DATA:
  #if 0
! 	    Data_seek = shdr.s_scnptr;
  #endif
  	    /* fall through */
  	  case ECOFF_STYP_SDATA:
  #if 0
! 	    Sdata_seek = shdr.s_scnptr;
  #endif
! 
! 	    p = calloc(shdr.s_size, sizeof(char));
! 	    if (!p)
! 	      fatal("out of virtual memory");
! 
! 	    if (fseek(fobj, shdr.s_scnptr, 0) == -1)
! 	      fatal("could not read `.text' from executable", i);
! 	    if (fread(p, shdr.s_size, 1, fobj) < 1)
! 	      fatal("could not read text section from executable");
! 
! 	    /* copy program section it into simulator target memory */
! 	    mem_bcopy(mem_access, mem, Write, shdr.s_vaddr, p, shdr.s_size);
! 
! 	    /* release the section buffer */
! 	    free(p);
! 
! 	    break;
  
  	  case ECOFF_STYP_BSS:
  	    break;
  
! 	  case ECOFF_STYP_SBSS:
! 	    break;
  	  }
        }
  
+     /* compute data segment size from data break point */
+     ld_text_base = MD_TEXT_BASE;
+     ld_data_base = MD_DATA_BASE;
+     ld_prog_entry = ahdr.entry;
+     ld_data_size = data_break - ld_data_base;
+ 
      /* done with the executable, close it */
      if (fclose(fobj))
        fatal("could not close executable `%s'", argv[0]);
***************
*** 585,591 ****
  	 of this comment, e-mail me for details... */
        fprintf(stderr, "sim: *WARNING*: swapping bytes to match host...\n");
        fprintf(stderr, "sim: *WARNING*: swapping may break your program!\n");
!       /* #else */
        fatal("binary endian does not match host endian");
  #endif
      }
--- 551,557 ----
  	 of this comment, e-mail me for details... */
        fprintf(stderr, "sim: *WARNING*: swapping bytes to match host...\n");
        fprintf(stderr, "sim: *WARNING*: swapping may break your program!\n");
! #else
        fatal("binary endian does not match host endian");
  #endif
      }
***************
*** 597,628 ****
  	 of this comment, e-mail me for details... */
        fprintf(stderr, "sim: *WARNING*: swapping words to match host...\n");
        fprintf(stderr, "sim: *WARNING*: swapping may break your program!\n");
!       /* #else */
        fatal("binary endian does not match host endian");
  #endif
      }
  
-   /* set up a local stack pointer, this is where the argv and envp
-      data is written into program memory */
-   ld_stack_base = ld_text_base - (409600+4096);
- #if 0
-   sp = ROUND_DOWN(ld_stack_base - MD_MAX_ENVIRON, sizeof(MD_DOUBLE_TYPE));
- #endif
-   sp = ld_stack_base - MD_MAX_ENVIRON;
-   ld_stack_size = ld_stack_base - sp;
- 
-   /* initial stack pointer value */
-   ld_environ_base = sp;
- 
    /* write [argc] to stack */
!   temp = MD_SWAPQ(argc);
!   mem_access(mem, Write, sp, &temp, sizeof(qword_t));
!   regs->regs_R[MD_REG_A0] = temp;
!   sp += sizeof(qword_t);
  
    /* skip past argv array and NULL */
    argv_addr = sp;
-   regs->regs_R[MD_REG_A1] = argv_addr;
    sp = sp + (argc + 1) * sizeof(md_addr_t);
  
    /* save space for envp array and NULL */
--- 563,580 ----
  	 of this comment, e-mail me for details... */
        fprintf(stderr, "sim: *WARNING*: swapping words to match host...\n");
        fprintf(stderr, "sim: *WARNING*: swapping may break your program!\n");
! #else
        fatal("binary endian does not match host endian");
  #endif
      }
  
    /* write [argc] to stack */
!   temp = MD_SWAPW(argc);
!   mem_access(mem, Write, sp, &temp, sizeof(word_t));
!   sp += sizeof(word_t);
  
    /* skip past argv array and NULL */
    argv_addr = sp;
    sp = sp + (argc + 1) * sizeof(md_addr_t);
  
    /* save space for envp array and NULL */
***************
*** 635,646 ****
    for (i=0; i<argc; i++)
      {
        /* write the argv pointer array entry */
!       temp = MD_SWAPQ(sp);
        mem_access(mem, Write, argv_addr + i*sizeof(md_addr_t),
  		 &temp, sizeof(md_addr_t));
        /* and the data */
        mem_strcpy(mem_access, mem, Write, sp, argv[i]);
!       sp += strlen(argv[i])+1;
      }
    /* terminate argv array with a NULL */
    mem_access(mem, Write, argv_addr + i*sizeof(md_addr_t),
--- 587,598 ----
    for (i=0; i<argc; i++)
      {
        /* write the argv pointer array entry */
!       temp = MD_SWAPW(sp);
        mem_access(mem, Write, argv_addr + i*sizeof(md_addr_t),
  		 &temp, sizeof(md_addr_t));
        /* and the data */
        mem_strcpy(mem_access, mem, Write, sp, argv[i]);
!       sp += strlen(argv[i]) + 1;
      }
    /* terminate argv array with a NULL */
    mem_access(mem, Write, argv_addr + i*sizeof(md_addr_t),
***************
*** 650,656 ****
    for (i = 0; envp[i]; i++)
      {
        /* write the envp pointer array entry */
!       temp = MD_SWAPQ(sp);
        mem_access(mem, Write, envp_addr + i*sizeof(md_addr_t),
  		 &temp, sizeof(md_addr_t));
        /* and the data */
--- 602,608 ----
    for (i = 0; envp[i]; i++)
      {
        /* write the envp pointer array entry */
!       temp = MD_SWAPW(sp);
        mem_access(mem, Write, envp_addr + i*sizeof(md_addr_t),
  		 &temp, sizeof(md_addr_t));
        /* and the data */
***************
*** 667,673 ****
        /* we did, indicate to the user that MD_MAX_ENVIRON must be increased,
  	 alternatively, you can use a smaller environment, or fewer
  	 command line arguments */
!       fatal("environment overflow, increase MD_MAX_ENVIRON in alpha.h");
      }
  
    /* initialize the bottom of heap to top of data segment */
--- 619,625 ----
        /* we did, indicate to the user that MD_MAX_ENVIRON must be increased,
  	 alternatively, you can use a smaller environment, or fewer
  	 command line arguments */
!       fatal("environment overflow, increase MD_MAX_ENVIRON in ss.h");
      }
  
    /* initialize the bottom of heap to top of data segment */
***************
*** 676,681 ****
--- 628,634 ----
    /* set initial minimum stack pointer value to initial stack value */
    ld_stack_min = regs->regs_R[MD_REG_SP];
  
+   /* set up initial register state */
    regs->regs_R[MD_REG_SP] = ld_environ_base;
    regs->regs_PC = ld_prog_entry;
  
***************
*** 686,689 ****
--- 639,666 ----
    debug("ld_stack_base: 0x%08x  ld_stack_size: 0x%08x",
  	ld_stack_base, ld_stack_size);
    debug("ld_prog_entry: 0x%08x", ld_prog_entry);
+ 
+   /* finally, predecode the text segment... */
+   {
+     md_addr_t addr;
+     md_inst_t inst;
+     enum md_fault_type fault;
+ 
+     if (OP_MAX > 255)
+       fatal("cannot perform fast decoding, too many opcodes");
+ 
+     debug("sim: decoding text segment...");
+     for (addr=ld_text_base;
+ 	 addr < (ld_text_base+ld_text_size);
+ 	 addr += sizeof(md_inst_t))
+       {
+ 	fault = mem_access(mem, Read, addr, &inst, sizeof(inst));
+ 	if (fault != md_fault_none)
+ 	  fatal("could not read instruction memory");
+ 	inst.a = (inst.a & ~0xff) | (word_t)MD_OP_ENUM(MD_OPFIELD(inst));
+ 	fault = mem_access(mem, Write, addr, &inst, sizeof(inst));
+ 	if (fault != md_fault_none)
+ 	  fatal("could not write instruction memory");
+       }
+   }
  }
diff -crB tmp/simplesim-3.0/machine.c simplesim-3.0/machine.c
*** tmp/simplesim-3.0/machine.c	2003-10-08 21:12:28.000000000 -0500
--- simplesim-3.0/machine.c	2003-10-08 21:22:07.000000000 -0500
***************
*** 1,4 ****
! /* alpha.c - Alpha ISA definition routines */
  
  /* SimpleScalar(TM) Tool Suite
   * Copyright (C) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
--- 1,4 ----
! /* pisa.c - SimpleScalar portable ISA (pisa) definition routines */
  
  /* SimpleScalar(TM) Tool Suite
   * Copyright (C) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
***************
*** 58,100 ****
  #include "eval.h"
  #include "regs.h"
  
- #if 0 /* cross-endian execution now works with EIO trace files only... */
- /* FIXME: currently SimpleScalar/AXP only builds on little-endian... */
- #if !defined(BYTES_LITTLE_ENDIAN) || !defined(WORDS_LITTLE_ENDIAN)
- #error SimpleScalar/AXP only builds on little-endian machines...
- #endif
- #endif
- 
- /* FIXME: currently SimpleScalar/AXP only builds with qword support... */
- #if !defined(HOST_HAS_QWORD)
- #error SimpleScalar/AXP only builds on hosts with builtin qword support...
- #error Try building with GNU GCC, as it supports qwords on most machines.
- #endif
- 
  /* preferred nop instruction definition */
! md_inst_t MD_NOP_INST = 0x43ff041f;		/* addq r31,r31,r31 */
  
  /* opcode mask -> enum md_opcodem, used by decoder (MD_OP_ENUM()) */
  enum md_opcode md_mask2op[MD_MAX_MASK+1];
- unsigned int md_opoffset[OP_MAX];
- 
- /* enum md_opcode -> mask for decoding next level */
- unsigned int md_opmask[OP_MAX] = {
-   0, /* NA */
- #define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3) 0,
- #define DEFLINK(OP,MSK,NAME,SHIFT,MASK) MASK,
- #define CONNECT(OP)
- #include "machine.def"
- };
- 
- /* enum md_opcode -> shift for decoding next level */
- unsigned int md_opshift[OP_MAX] = {
-   0, /* NA */
- #define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3) 0,
- #define DEFLINK(OP,MSK,NAME,SHIFT,MASK) SHIFT,
- #define CONNECT(OP)
- #include "machine.def"
- };
  
  /* enum md_opcode -> description string */
  char *md_op2name[OP_MAX] = {
--- 58,68 ----
  #include "eval.h"
  #include "regs.h"
  
  /* preferred nop instruction definition */
! md_inst_t MD_NOP_INST = { NOP, 0 };
  
  /* opcode mask -> enum md_opcodem, used by decoder (MD_OP_ENUM()) */
  enum md_opcode md_mask2op[MD_MAX_MASK+1];
  
  /* enum md_opcode -> description string */
  char *md_op2name[OP_MAX] = {
***************
*** 116,124 ****
  
  /* enum md_opcode -> enum md_fu_class, used by performance simulators */
  enum md_fu_class md_op2fu[OP_MAX] = {
!   FUClamd_NA, /* NA */
  #define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3) RES,
! #define DEFLINK(OP,MSK,NAME,MASK,SHIFT) FUClamd_NA,
  #define CONNECT(OP)
  #include "machine.def"
  };
--- 84,92 ----
  
  /* enum md_opcode -> enum md_fu_class, used by performance simulators */
  enum md_fu_class md_op2fu[OP_MAX] = {
!   FUClass_NA, /* NA */
  #define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3) RES,
! #define DEFLINK(OP,MSK,NAME,MASK,SHIFT) FUClass_NA,
  #define CONNECT(OP)
  #include "machine.def"
  };
***************
*** 139,144 ****
--- 107,138 ----
    "wr-port"
  };
  
+ /* enum md_opcode -> opcode flags, used by simulators */
+ unsigned int md_op2flags[OP_MAX] = {
+   NA, /* NA */
+ #define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3) FLAGS,
+ #define DEFLINK(OP,MSK,NAME,MASK,SHIFT) NA,
+ #define CONNECT(OP)
+ #include "machine.def"
+ };
+ 
+ /* lwl/lwr/swl/swr masks */
+ word_t md_lr_masks[] = {
+ #ifdef BYTES_BIG_ENDIAN
+   0x00000000,
+   0x000000ff,
+   0x0000ffff,
+   0x00ffffff,
+   0xffffffff,
+ #else
+   0xffffffff,
+   0x00ffffff,
+   0x0000ffff,
+   0x000000ff,
+   0x00000000,
+ #endif
+ };
+ 
  char *md_amode_str[md_amode_NUM] =
  {
    "(const)",		/* immediate addressing mode */
***************
*** 156,162 ****
  
    /* integer register file */
    { "$r0",	rt_gpr,		0 },
!   { "$v0",	rt_gpr,		0 },
    { "$r1",	rt_gpr,		1 },
    { "$r2",	rt_gpr,		2 },
    { "$r3",	rt_gpr,		3 },
--- 150,156 ----
  
    /* integer register file */
    { "$r0",	rt_gpr,		0 },
!   { "$zero",	rt_gpr,		0 },
    { "$r1",	rt_gpr,		1 },
    { "$r2",	rt_gpr,		2 },
    { "$r3",	rt_gpr,		3 },
***************
*** 164,170 ****
    { "$r5",	rt_gpr,		5 },
    { "$r6",	rt_gpr,		6 },
    { "$r7",	rt_gpr,		7 },
-   { "$err",	rt_gpr,		7 },
    { "$r8",	rt_gpr,		8 },
    { "$r9",	rt_gpr,		9 },
    { "$r10",	rt_gpr,		10 },
--- 158,163 ----
***************
*** 173,207 ****
    { "$r13",	rt_gpr,		13 },
    { "$r14",	rt_gpr,		14 },
    { "$r15",	rt_gpr,		15 },
-   { "$fp",	rt_gpr,		15 },
    { "$r16",	rt_gpr,		16 },
-   { "$a0",	rt_gpr,		16 },
    { "$r17",	rt_gpr,		17 },
-   { "$a1",	rt_gpr,		17 },
    { "$r18",	rt_gpr,		18 },
-   { "$a2",	rt_gpr,		18 },
    { "$r19",	rt_gpr,		19 },
-   { "$a3",	rt_gpr,		19 },
    { "$r20",	rt_gpr,		20 },
-   { "$a4",	rt_gpr,		20 },
    { "$r21",	rt_gpr,		21 },
-   { "$a5",	rt_gpr,		21 },
    { "$r22",	rt_gpr,		22 },
    { "$r23",	rt_gpr,		23 },
    { "$r24",	rt_gpr,		24 },
    { "$r25",	rt_gpr,		25 },
    { "$r26",	rt_gpr,		26 },
-   { "$ra",	rt_gpr,		26 },
    { "$r27",	rt_gpr,		27 },
    { "$r28",	rt_gpr,		28 },
    { "$r29",	rt_gpr,		29 },
!   { "$gp",	rt_gpr,		29 },
    { "$r30",	rt_gpr,		30 },
!   { "$sp",	rt_gpr,		30 },
    { "$r31",	rt_gpr,		31 },
-   { "$zero",	rt_gpr,		31 },
  
!   /* floating point register file - double precision */
    { "$f0",	rt_fpr,		0 },
    { "$f1",	rt_fpr,		1 },
    { "$f2",	rt_fpr,		2 },
--- 166,192 ----
    { "$r13",	rt_gpr,		13 },
    { "$r14",	rt_gpr,		14 },
    { "$r15",	rt_gpr,		15 },
    { "$r16",	rt_gpr,		16 },
    { "$r17",	rt_gpr,		17 },
    { "$r18",	rt_gpr,		18 },
    { "$r19",	rt_gpr,		19 },
    { "$r20",	rt_gpr,		20 },
    { "$r21",	rt_gpr,		21 },
    { "$r22",	rt_gpr,		22 },
    { "$r23",	rt_gpr,		23 },
    { "$r24",	rt_gpr,		24 },
    { "$r25",	rt_gpr,		25 },
    { "$r26",	rt_gpr,		26 },
    { "$r27",	rt_gpr,		27 },
    { "$r28",	rt_gpr,		28 },
+   { "$gp",	rt_gpr,		28 },
    { "$r29",	rt_gpr,		29 },
!   { "$sp",	rt_gpr,		29 },
    { "$r30",	rt_gpr,		30 },
!   { "$fp",	rt_gpr,		30 },
    { "$r31",	rt_gpr,		31 },
  
!   /* floating point register file - single precision */
    { "$f0",	rt_fpr,		0 },
    { "$f1",	rt_fpr,		1 },
    { "$f2",	rt_fpr,		2 },
***************
*** 235,240 ****
--- 220,243 ----
    { "$f30",	rt_fpr,		30 },
    { "$f31",	rt_fpr,		31 },
  
+   /* floating point register file - double precision */
+   { "$d0",	rt_dpr,		0 },
+   { "$d1",	rt_dpr,		1 },
+   { "$d2",	rt_dpr,		2 },
+   { "$d3",	rt_dpr,		3 },
+   { "$d4",	rt_dpr,		4 },
+   { "$d5",	rt_dpr,		5 },
+   { "$d6",	rt_dpr,		6 },
+   { "$d7",	rt_dpr,		7 },
+   { "$d8",	rt_dpr,		8 },
+   { "$d9",	rt_dpr,		9 },
+   { "$d10",	rt_dpr,		10 },
+   { "$d11",	rt_dpr,		11 },
+   { "$d12",	rt_dpr,		12 },
+   { "$d13",	rt_dpr,		13 },
+   { "$d14",	rt_dpr,		14 },
+   { "$d15",	rt_dpr,		15 },
+ 
    /* floating point register file - integer precision */
    { "$l0",	rt_lpr,		0 },
    { "$l1",	rt_lpr,		1 },
***************
*** 270,277 ****
    { "$l31",	rt_lpr,		31 },
  
    /* miscellaneous registers */
!   { "$fpcr",	rt_ctrl,	0 },
!   { "$uniq",	rt_ctrl,	1 },
  
    /* program counters */
    { "$pc",	rt_PC,		0 },
--- 273,281 ----
    { "$l31",	rt_lpr,		31 },
  
    /* miscellaneous registers */
!   { "$hi",	rt_ctrl,	0 },
!   { "$lo",	rt_ctrl,	1 },
!   { "$fcc",	rt_ctrl,	2 },
  
    /* program counters */
    { "$pc",	rt_PC,		0 },
***************
*** 312,322 ****
  
        if (!is_write)
  	{
! 	  val->type = et_qword;
! 	  val->value.as_qword = regs->regs_R[reg];
  	}
        else
! 	regs->regs_R[reg] = eval_as_qword(*val);
        break;
  
      case rt_lpr:
--- 316,326 ----
  
        if (!is_write)
  	{
! 	  val->type = et_uint;
! 	  val->value.as_uint = regs->regs_R[reg];
  	}
        else
! 	regs->regs_R[reg] = eval_as_uint(*val);
        break;
  
      case rt_lpr:
***************
*** 325,335 ****
  
        if (!is_write)
  	{
! 	  val->type = et_qword;
! 	  val->value.as_qword = regs->regs_F.q[reg];
  	}
        else
! 	regs->regs_F.q[reg] = eval_as_qword(*val);
        break;
  
      case rt_fpr:
--- 329,339 ----
  
        if (!is_write)
  	{
! 	  val->type = et_uint;
! 	  val->value.as_uint = regs->regs_F.l[reg];
  	}
        else
! 	regs->regs_F.l[reg] = eval_as_uint(*val);
        break;
  
      case rt_fpr:
***************
*** 338,343 ****
--- 342,360 ----
  
        if (!is_write)
  	{
+ 	  val->type = et_float;
+ 	  val->value.as_float = regs->regs_F.f[reg];
+ 	}
+       else
+ 	regs->regs_F.f[reg] = eval_as_float(*val);
+       break;
+ 
+     case rt_dpr:
+       if (reg < 0 || reg >= MD_NUM_FREGS/2)
+ 	return "register number out of range";
+ 
+       if (!is_write)
+ 	{
  	  val->type = et_double;
  	  val->value.as_double = regs->regs_F.d[reg];
  	}
***************
*** 348,371 ****
      case rt_ctrl:
        switch (reg)
  	{
! 	case /* FPCR */0:
  	  if (!is_write)
  	    {
! 	      val->type = et_qword;
! 	      val->value.as_qword = regs->regs_C.fpcr;
  	    }
  	  else
! 	    regs->regs_C.fpcr = eval_as_qword(*val);
  	  break;
  
! 	case /* UNIQ */1:
  	  if (!is_write)
  	    {
! 	      val->type = et_qword;
! 	      val->value.as_qword = regs->regs_C.uniq;
  	    }
  	  else
! 	    regs->regs_C.uniq = eval_as_qword(*val);
  	  break;
  
  	default:
--- 365,398 ----
      case rt_ctrl:
        switch (reg)
  	{
! 	case /* HI */0:
  	  if (!is_write)
  	    {
! 	      val->type = et_uint;
! 	      val->value.as_uint = regs->regs_C.hi;
  	    }
  	  else
! 	    regs->regs_C.hi = eval_as_uint(*val);
  	  break;
  
! 	case /* LO */1:
  	  if (!is_write)
  	    {
! 	      val->type = et_uint;
! 	      val->value.as_uint = regs->regs_C.lo;
  	    }
  	  else
! 	    regs->regs_C.lo = eval_as_uint(*val);
! 	  break;
! 
! 	case /* FCC */2:
! 	  if (!is_write)
! 	    {
! 	      val->type = et_int;
! 	      val->value.as_int = regs->regs_C.fcc;
! 	    }
! 	  else
! 	    regs->regs_C.fcc = eval_as_uint(*val);
  	  break;
  
  	default:
***************
*** 405,412 ****
  void
  md_print_ireg(md_gpr_t regs, int reg, FILE *stream)
  {
!   myfprintf(stream, "%4s: %16ld/0x%012lx",
! 	    md_reg_name(rt_gpr, reg), regs[reg], regs[reg]);
  }
  
  void
--- 432,439 ----
  void
  md_print_ireg(md_gpr_t regs, int reg, FILE *stream)
  {
!   fprintf(stream, "%4s: %12d/0x%08x",
! 	  md_reg_name(rt_gpr, reg), regs[reg], regs[reg]);
  }
  
  void
***************
*** 427,434 ****
  void
  md_print_fpreg(md_fpr_t regs, int reg, FILE *stream)
  {
!   myfprintf(stream, "%4s: %16ld/0x%012lx/%f",
! 	    md_reg_name(rt_fpr, reg), regs.q[reg], regs.q[reg], regs.d[reg]);
  }
  
  void
--- 454,466 ----
  void
  md_print_fpreg(md_fpr_t regs, int reg, FILE *stream)
  {
!   fprintf(stream, "%4s: %12d/0x%08x/%f",
! 	  md_reg_name(rt_fpr, reg), regs.l[reg], regs.l[reg], regs.f[reg]);
!   if (/* even? */!(reg & 1))
!     {
!       fprintf(stream, " (%4s as double: %f)",
! 	      md_reg_name(rt_dpr, reg/2), regs.d[reg/2]);
!     }
  }
  
  void
***************
*** 454,464 ****
    switch (reg)
      {
      case 0:
!       myfprintf(stream, "FPCR: 0x%012lx", regs.fpcr);
        break;
  
      case 1:
!       myfprintf(stream, "UNIQ: 0x%012lx", regs.uniq);
        break;
  
      default:
--- 486,500 ----
    switch (reg)
      {
      case 0:
!       fprintf(stream, "HI: 0x%08x", regs.hi);
        break;
  
      case 1:
!       fprintf(stream, "LO: 0x%08x", regs.lo);
!       break;
! 
!     case 2:
!       fprintf(stream, "FCC: 0x%08x", regs.fcc);
        break;
  
      default:
***************
*** 472,543 ****
    md_print_creg(regs, 0, stream);
    fprintf(stream, "  ");
    md_print_creg(regs, 1, stream);
    fprintf(stream, "\n");
  }
  
  /* xor checksum registers */
  word_t
  md_xor_regs(struct regs_t *regs)
  {
    int i;
!   qword_t checksum = 0;
  
!   for (i=0; i < (MD_NUM_IREGS-1); i++)
      checksum ^= regs->regs_R[i];
  
!   for (i=0; i < (MD_NUM_FREGS-1); i++)
!     checksum ^= regs->regs_F.q[i];
  
!   checksum ^= regs->regs_C.fpcr;
!   checksum ^= regs->regs_C.uniq;
    checksum ^= regs->regs_PC;
    checksum ^= regs->regs_NPC;
  
!   return (word_t)((checksum >> 32) ^ checksum);
  }
  
- 
- /* enum md_opcode -> opcode flags, used by simulators */
- unsigned int md_op2flags[OP_MAX] = {
-   NA, /* NA */
- #define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3) FLAGS,
- #define DEFLINK(OP,MSK,NAME,MASK,SHIFT) NA,
- #define CONNECT(OP)
- #include "machine.def"
- };
- 
- 
  /* intialize the inst decoder, this function builds the ISA decode tables */
  void
  md_init_decoder(void)
  {
!   unsigned long max_offset = 0;
!   unsigned long offset = 0;
! 
  #define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3)		\
!   if ((MSK)+offset >= MD_MAX_MASK)					\
!     panic("MASK_MAX is too small, index==%d", (MSK)+offset);		\
!   if (md_mask2op[(MSK)+offset])						\
!     fatal("doubly defined opcode, index==%d", (MSK)+offset);		\
!   md_mask2op[(MSK)+offset]=(OP); max_offset=MAX(max_offset,(MSK)+offset);
! 
! #define DEFLINK(OP,MSK,NAME,MASK,SHIFT)					\
!   if ((MSK)+offset >= MD_MAX_MASK)					\
!     panic("MASK_MAX is too small, index==%d", (MSK)+offset);		\
!   if (md_mask2op[(MSK)+offset])						\
!     fatal("doubly defined opcode, index==%d", (MSK)+offset);		\
!   md_mask2op[(MSK)+offset]=(OP); max_offset=MAX(max_offset,(MSK)+offset);
! 
! #define CONNECT(OP)							\
!     offset = max_offset+1; md_opoffset[OP] = offset;
  
  #include "machine.def"
- 
-   if (max_offset >= MD_MAX_MASK)
-     panic("MASK_MAX is too small, index==%d", max_offset);
  }
  
! /* disassemble an Alpha instruction */
  void
  md_print_insn(md_inst_t inst,		/* instruction to disassemble */
  	      md_addr_t pc,		/* addr of inst, used for PC-rels */
--- 508,576 ----
    md_print_creg(regs, 0, stream);
    fprintf(stream, "  ");
    md_print_creg(regs, 1, stream);
+   fprintf(stream, "  ");
+   md_print_creg(regs, 2, stream);
    fprintf(stream, "\n");
  }
  
+ /* compute CRC of all registers */
+ word_t
+ md_crc_regs(struct regs_t *regs)
+ {
+   int i;
+   word_t crc_accum = 0;
+ 
+   for (i=0; i < MD_NUM_IREGS; i++)
+     crc_accum = crc(crc_accum, regs->regs_R[i]);
+ 
+   for (i=0; i < MD_NUM_FREGS; i++)
+     crc_accum = crc(crc_accum, regs->regs_F.l[i]);
+ 
+   crc_accum = crc(crc_accum, regs->regs_C.hi);
+   crc_accum = crc(crc_accum, regs->regs_C.lo);
+   crc_accum = crc(crc_accum, regs->regs_C.fcc);
+   crc_accum = crc(crc_accum, regs->regs_PC);
+   crc_accum = crc(crc_accum, regs->regs_NPC);
+ 
+   return crc_accum;
+ }
+ 
  /* xor checksum registers */
  word_t
  md_xor_regs(struct regs_t *regs)
  {
    int i;
!   word_t checksum = 0;
  
!   for (i=0; i < MD_NUM_IREGS; i++)
      checksum ^= regs->regs_R[i];
  
!   for (i=0; i < MD_NUM_FREGS; i++)
!     checksum ^= regs->regs_F.l[i];
  
!   checksum ^= regs->regs_C.hi;
!   checksum ^= regs->regs_C.lo;
!   checksum ^= regs->regs_C.fcc;
    checksum ^= regs->regs_PC;
    checksum ^= regs->regs_NPC;
  
!   return checksum;
  }
  
  /* intialize the inst decoder, this function builds the ISA decode tables */
  void
  md_init_decoder(void)
  {
!   /* FIXME: CONNECT defined? */
  #define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3)		\
!   if (md_mask2op[(MSK)]) fatal("doubly defined mask value");		\
!   if ((MSK) >= MD_MAX_MASK) fatal("mask value is too large");		\
!   md_mask2op[(MSK)]=(OP);
  
  #include "machine.def"
  }
  
! /* disassemble a SimpleScalar instruction */
  void
  md_print_insn(md_inst_t inst,		/* instruction to disassemble */
  	      md_addr_t pc,		/* addr of inst, used for PC-rels */
***************
*** 553,603 ****
    MD_SET_OPCODE(op, inst);
  
    /* disassemble the instruction */
!   if (op <= OP_NA || op >= OP_MAX)
      {
        /* bogus instruction */
!       fprintf(stream, "<invalid inst: 0x%08x>", inst);
      }
    else
      {
        char *s;
  
!       /* FIXME: %-10s crashes on Suns!!! */
!       fprintf(stream, "%s ", MD_OP_NAME(op));
  
        s = MD_OP_FORMAT(op);
        while (*s) {
  	switch (*s) {
! 	case 'a':
! 	  fprintf(stream, "r%d", RA);
  	  break;
  	case 'b':
! 	  fprintf(stream, "r%d", RB);
  	  break;
! 	case 'c':
! 	  fprintf(stream, "r%d", RC);
  	  break;
! 	case 'A':
! 	  fprintf(stream, "f%d", RA);
  	  break;
! 	case 'B':
! 	  fprintf(stream, "f%d", RB);
  	  break;
! 	case 'C':
! 	  fprintf(stream, "f%d", RC);
  	  break;
  	case 'o':
! 	  fprintf(stream, "%d", (sword_t)SEXT(OFS));
  	  break;
! 	case 'j':
! 	  myfprintf(stream, "0x%p", pc + (SEXT(OFS) << 2) + 4);
  	  break;
  	case 'J':
! 	  myfprintf(stream, "0x%p", pc + (SEXT21(TARG) << 2) + 4);
  	  break;
! 	case 'i':
! 	  fprintf(stream, "%d", (word_t)IMM);
  	  break;
  	default:
  	  /* anything unrecognized, e.g., '.' is just passed through */
  	  fputc(*s, stream);
--- 586,673 ----
    MD_SET_OPCODE(op, inst);
  
    /* disassemble the instruction */
!   if (op == OP_NA || op >= OP_MAX)
      {
        /* bogus instruction */
!       fprintf(stream, "<invalid inst: 0x%08x:%08x>", inst.a, inst.b);
      }
    else
      {
        char *s;
  
!       fprintf(stream, "%-10s", MD_OP_NAME(op));
  
        s = MD_OP_FORMAT(op);
        while (*s) {
  	switch (*s) {
! 	case 'd':
! 	  fprintf(stream, "r%d", RD);
! 	  break;
! 	case 's':
! 	  fprintf(stream, "r%d", RS);
! 	  break;
! 	case 't':
! 	  fprintf(stream, "r%d", RT);
  	  break;
  	case 'b':
! 	  fprintf(stream, "r%d", BS);
  	  break;
! 	case 'D':
! 	  fprintf(stream, "f%d", FD);
  	  break;
! 	case 'S':
! 	  fprintf(stream, "f%d", FS);
  	  break;
! 	case 'T':
! 	  fprintf(stream, "f%d", FT);
  	  break;
! 	case 'j':
! 	  fprintf(stream, "0x%x", (pc + 8 + (OFS << 2)));
  	  break;
  	case 'o':
! 	case 'i':
! 	  fprintf(stream, "%d", IMM);
  	  break;
! 	case 'H':
! 	  fprintf(stream, "%d", SHAMT);
! 	  break;
! 	case 'u':
! 	  fprintf(stream, "%u", UIMM);
! 	  break;
! 	case 'U':
! 	  fprintf(stream, "0x%x", UIMM);
  	  break;
  	case 'J':
! 	  fprintf(stream, "0x%x", ((pc & 036000000000) | (TARG << 2)));
  	  break;
! 	case 'B':
! 	  fprintf(stream, "0x%x", BCODE);
! 	  break;
! #if 0 /* FIXME: obsolete... */
! 	case ')':
! 	  /* handle pre- or post-inc/dec */
! 	  if (SS_COMP_OP == SS_COMP_NOP)
! 	    fprintf(stream, ")");
! 	  else if (SS_COMP_OP == SS_COMP_POST_INC)
! 	    fprintf(stream, ")+");
! 	  else if (SS_COMP_OP == SS_COMP_POST_DEC)
! 	    fprintf(stream, ")-");
! 	  else if (SS_COMP_OP == SS_COMP_PRE_INC)
! 	    fprintf(stream, ")^+");
! 	  else if (SS_COMP_OP == SS_COMP_PRE_DEC)
! 	    fprintf(stream, ")^-");
! 	  else if (SS_COMP_OP == SS_COMP_POST_DBL_INC)
! 	    fprintf(stream, ")++");
! 	  else if (SS_COMP_OP == SS_COMP_POST_DBL_DEC)
! 	    fprintf(stream, ")--");
! 	  else if (SS_COMP_OP == SS_COMP_PRE_DBL_INC)
! 	    fprintf(stream, ")^++");
! 	  else if (SS_COMP_OP == SS_COMP_PRE_DBL_DEC)
! 	    fprintf(stream, ")^--");
! 	  else
! 	    panic("bogus SS_COMP_OP");
  	  break;
+ #endif
  	default:
  	  /* anything unrecognized, e.g., '.' is just passed through */
  	  fputc(*s, stream);
***************
*** 606,608 ****
--- 676,722 ----
        }
      }
  }
+ 
+ 
+ #if 0
+ 
+ /* INC_DEC expression step tables, they map (operation, size) -> step value,
+    and speed up pre/post-incr/desc handling */
+ 
+ /* force a nasty address */
+ #define XX		0x6bababab
+ 
+ /* before increment */
+ int ss_fore_tab[/* operand size */8][/* operation */5] = {
+              /* NOP   POSTI POSTD  PREI   PRED */
+ /* byte */    {  0,    0,    0,     1,     -1,  },
+ /* half */    {  0,    0,    0,     2,     -2,  },
+ /* invalid */ {  XX,   XX,   XX,    XX,    XX,  },
+ /* word */    {  0,    0,    0,     4,     -4,  },
+ /* invalid */ {  XX,   XX,   XX,    XX,    XX,  },
+ /* invalid */ {  XX,   XX,   XX,    XX,    XX,  },
+ /* invalid */ {  XX,   XX,   XX,    XX,    XX,  },
+ /* dword */   {  0,    0,    0,     8,     -8,  },
+ };
+ 
+ /* after increment */
+ int ss_aft_tab[/* operand size */8][/* operation */5] = {
+              /* NOP   POSTI POSTD  PREI   PRED */
+ /* byte */    {  0,    1,    -1,    0,     0,   },
+ /* half */    {  0,    2,    -2,    0,     0,   },
+ /* invalid */ {  XX,   XX,   XX,    XX,    XX,  },
+ /* word */    {  0,    4,    -4,    0,     0,   },
+ /* invalid */ {  XX,   XX,   XX,    XX,    XX,  },
+ /* invalid */ {  XX,   XX,   XX,    XX,    XX,  },
+ /* invalid */ {  XX,   XX,   XX,    XX,    XX,  },
+ /* dword */   {  0,    8,    -8,    0,     0,   },
+ };
+ 
+ /* LWL/LWR implementation workspace */
+ md_addr_t ss_lr_temp;
+ 
+ /* temporary variables */
+ md_addr_t temp_bs, temp_rd;
+ 
+ 
+ #endif
diff -crB tmp/simplesim-3.0/machine.def simplesim-3.0/machine.def
*** tmp/simplesim-3.0/machine.def	2003-10-08 21:15:08.000000000 -0500
--- simplesim-3.0/machine.def	2003-10-08 21:22:53.000000000 -0500
***************
*** 1,6 ****
  /* This doesn't look like -*- C -*-, but it is! */
  
! /* alpha.def - Alpha ISA machine definition */
  
  /* SimpleScalar(TM) Tool Suite
   * Copyright (C) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
--- 1,6 ----
  /* This doesn't look like -*- C -*-, but it is! */
  
! /* pisa.def - SimpleScalar portable ISA (pisa) machine definition */
  
  /* SimpleScalar(TM) Tool Suite
   * Copyright (C) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
***************
*** 51,58 ****
   */
  
  
- /* FIXME: these comments are out-of-date */
- 
  /* This file defines all aspects of the SimpleScalar instruction set
   * architecture.  Each instruction set in the architecture has a DEFINST()
   * macro call included below.  The contents of a instruction definition are
--- 51,56 ----
***************
*** 191,4121 ****
   *		    TALIGN(T)	   - check jump target T alignment
   */
  
! #if 0
! /* TOP LEVEL decode table */
! DEFLINK(TOPLEV, 0x00, "toplev", 26, 0x3f)
! CONNECT(TOPLEV)
! #endif
  
! DEFLINK(CALL_PAL, 0x00, "call_pal", 0, 0xff)
  
! #define LDA_IMPL							\
    {									\
!     SET_GPR(RA, GPR(RB) + SEXT(OFS));					\
    }
! DEFINST(LDA,			0x08,
! 	"lda",			"a,o(b)",
! 	IntALU,			F_ICOMP,
! 	DGPR(RA), DNA,		DNA, DGPR(RB), DNA)
  
! #define LDAH_IMPL							\
    {									\
!     SET_GPR(RA, GPR(RB) + SEXT32(65536 * OFS));				\
    }
! DEFINST(LDAH,			0x09,
! 	"ldah",			"a,o(b)",
! 	IntALU,			F_ICOMP,
! 	DGPR(RA), DNA,		DNA, DGPR(RB), DNA)
  
! /* EV56 BWX extension... */
! #define LDBU_IMPL							\
    {									\
!     byte_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_BYTE(GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
! 									\
!     SET_GPR(RA, (qword_t)_result);					\
    }
! DEFINST(LDBU,			0x0a,
! 	"ldbu",			"a,o(b)",
  	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RA), DNA,		DNA, DGPR(RB), DNA)
  
! #define LDQ_U_IMPL							\
    {									\
!     qword_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_QWORD((GPR(RB) + SEXT(OFS)) & ~7, _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
  									\
!     SET_GPR(RA, _result);						\
    }
! DEFINST(LDQ_U,			0x0b,
! 	"ldq_u",		"a,o(b)",
  	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RA), DNA,		DNA, DGPR(RB), DNA)
  
! /* EV56 BWX extension... */
! #define LDWU_IMPL							\
    {									\
      half_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_HALF(GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
! 									\
!     SET_GPR(RA, (qword_t)_result);					\
    }
! DEFINST(LDWU,			0x0c,
! 	"ldwu",			"a,o(b)",
! 	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RA), DNA,		DNA, DGPR(RB), DNA)
  
! /* EV56 BWX extension... */
! #define STW_IMPL							\
    {									\
      enum md_fault_type _fault;						\
  									\
!     WRITE_HALF((half_t)GPR(RA), GPR(RB) + SEXT(OFS), _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(STW,			0x0d,
! 	"stw",			"a,o(b)",
! 	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DGPR(RA), DGPR(RB), DNA)
  
! /* EV56 BWX extension... */
! #define STB_IMPL							\
    {									\
      enum md_fault_type _fault;						\
  									\
!     WRITE_BYTE((byte_t)GPR(RA), GPR(RB) + SEXT(OFS), _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(STB,			0x0e,
! 	"stb",			"a,o(b)",
! 	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define STQ_U_IMPL							\
    {									\
      enum md_fault_type _fault;						\
  									\
!     WRITE_QWORD(GPR(RA), (GPR(RB) + SEXT(OFS)) & ~7, _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(STQ_U,			0x0f,
! 	"stq_u",		"a,o(b)",
! 	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! DEFLINK(INTA, 0x10, "inta", 5, 0x7f)
! 
! DEFLINK(INTL, 0x11, "intl", 5, 0x7f)
! 
! DEFLINK(INTS, 0x12, "ints", 5, 0x7f)
! 
! /* changed from 0x7f to 0x3f to allow MUL{Q,L}/V */
! DEFLINK(INTM, 0x13, "intm", 5, 0x3f)
! 
! /* added 02/27/99, plakal@cecil, from Alpha Arch Handbook (Rev.4, EV6) */
! 
! /* FIX extensions */
! DEFLINK(ITFP, 0x14, "itfp", 5, 0x3f)
! 
  
! #define FLTV_IMPL							\
    {									\
!     /* FIXME: unimplemented */						\
!     DECLARE_FAULT(md_fault_unimpl);					\
    }
- DEFINST(FLTV,			0x15,
- 	"fltv (unimpl)",	"",
- 	NA,			NA,
- 	DNA, DNA,		DNA, DNA, DNA)
- 
- DEFLINK(FLTI, 0x16, "flti", 5, 0x3f)
- 
- DEFLINK(FLTL, 0x17, "fltl", 5, /* FIXME: check this... */0x7f)
- 
- /* changed the shift & mask to incorporate new instructions in the group */
- DEFLINK(MISC, 0x18, "misc", 8, 0xff)
  
! DEFLINK(JMPJSR, 0x1a, "jmpjsr", 14, 0x03)
! 
! /* changed from EXTS to FPTI to include more extensions (FIX,CIX,MVI) */
! DEFLINK(FPTI, 0x1c, "fpti", 5, 0x7f)
  
! #define LDF_IMPL							\
    {									\
!     /* FIXME: unimplemented */						\
!     DECLARE_FAULT(md_fault_unimpl);					\
!   }
! DEFINST(LDF,			0x20,
! 	"ldf (unimpl)",		"",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
  
! #define LDG_IMPL							\
    {									\
!     /* FIXME: unimplemented */						\
!     DECLARE_FAULT(md_fault_unimpl);					\
!   }
! DEFINST(LDG,			0x21,
! 	"ldg (unimpl)",		"",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
  
! #define LDS_IMPL							\
    {									\
!     sqword_t _longhold, _e1, _e2;					\
      enum md_fault_type _fault;						\
  									\
!     _longhold = READ_WORD(GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
  									\
!     _e1 = _longhold & 0x40000000;					\
!     _e2 = (_longhold >> 23) & ULL(0x7f);				\
!     if (_e1)								\
!       {									\
! 	if (_e2 == ULL(0x3f800000))					\
! 	  _e2 = ULL(0x7ff);						\
! 	else								\
! 	  _e2 |= ULL(0x400);						\
!       }									\
!     else								\
!       {									\
! 	if (_e2 == 0)							\
! 	  _e2 = 0;							\
! 	else								\
! 	  _e2 |= ULL(0x380);						\
!       }									\
!     SET_FPR_Q(RA, ((_longhold & ULL(0x80000000)) << 32			\
! 		   | _e2 << 52 | (_longhold & ULL(0x7fffff)) << 29));	\
    }
! DEFINST(LDS,			0x22,
! 	"lds",			"A,o(b)",
  	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DFPR(RA), DNA,		DNA, DGPR(RB), DNA)
  
! #define LDT_IMPL							\
    {									\
!     qword_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_QWORD(GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
  									\
!     SET_FPR_Q(RA, _result);						\
    }
! DEFINST(LDT,			0x23,
! 	"ldt",			"A,o(b)",
  	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DFPR(RA), DNA,		DNA, DGPR(RB), DNA)
  
! #define STF_IMPL							\
    {									\
!     /* FIXME: unimplemented */						\
!     DECLARE_FAULT(md_fault_unimpl);					\
    }
! DEFINST(STF,			0x24,
! 	"stf (unimpl)",		"",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
  
! #define STG_IMPL							\
    {									\
!     /* FIXME: unimplemented */						\
!     DECLARE_FAULT(md_fault_unimpl);					\
    }
! DEFINST(STG,			0x25,
! 	"stg (unimpl)",		"",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
  
! #define STS_IMPL							\
    {									\
-     sqword_t _longhold;							\
-     sword_t _inthold;							\
      enum md_fault_type _fault;						\
  									\
!     _longhold = FPR_Q(RA);						\
!     _inthold = (((_longhold >> 32) & ULL(0xc0000000))			\
! 		| ((_longhold >> 29) & ULL(0x3fffffff)));		\
!     WRITE_WORD(_inthold, GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(STS,			0x26,
! 	"sts",			"A,o(b)",
  	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DFPR(RA), DGPR(RB), DNA)
  
! #define STT_IMPL							\
    {									\
      enum md_fault_type _fault;						\
  									\
!     WRITE_QWORD(FPR_Q(RA), GPR(RB) + SEXT(OFS), _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(STT,			0x27,
! 	"stt",			"A,o(b)",
  	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DFPR(RA), DGPR(RB), DNA)
  
! #define LDL_IMPL							\
    {									\
-     word_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_WORD(GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
  									\
!     SET_GPR(RA, (sqword_t)((sword_t)_result));				\
    }
! DEFINST(LDL,			0x28,
! 	"ldl",			"a,o(b)",
! 	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RA), DNA,		DNA, DGPR(RB), DNA)
  
! #define LDQ_IMPL							\
    {									\
!     qword_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_QWORD(GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
  									\
!     SET_GPR(RA, _result);						\
    }
! DEFINST(LDQ,			0x29,
! 	"ldq",			"a,o(b)",
! 	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RA), DNA,		DNA, DGPR(RB), DNA)
  
! /* FIXME: not fully implemented... */
! #define LDL_L_IMPL							\
    {									\
!     word_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_WORD(GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
  									\
!     SET_GPR(RA, (sqword_t)((sword_t)_result));				\
    }
! DEFINST(LDL_L,			0x2a,
! 	"ldl_l (unimpl)",	"a,o(b)",
! 	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RA), DNA,		DNA, DGPR(RB), DNA)
! 
! /* FIXME: not fully implemented... */
! #define LDQ_L_IMPL							\
    {									\
!     qword_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_QWORD(GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
  									\
!     SET_GPR(RA, _result);						\
    }
! DEFINST(LDQ_L,			0x2b,
! 	"ldq_l (unimpl)",	"a,o(b)",
! 	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RA), DNA,		DNA, DGPR(RB), DNA)
  
! #define STL_IMPL							\
    {									\
!     word_t _src;							\
      enum md_fault_type _fault;						\
  									\
!     _src = (word_t)(GPR(RA) & ULL(0xffffffff));				\
!     WRITE_WORD(_src, GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(STL,			0x2c,
! 	"stl",			"a,o(b)",
! 	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define STQ_IMPL							\
    {									\
      enum md_fault_type _fault;						\
  									\
!     WRITE_QWORD(GPR(RA), GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(STQ,			0x2d,
! 	"stq",			"a,o(b)",
  	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DGPR(RA), DGPR(RB), DNA)
  
! /* FIXME: not fully implemented... */
! #define STL_C_IMPL							\
    {									\
!     word_t _src;							\
      enum md_fault_type _fault;						\
  									\
!     _src = (word_t)(GPR(RA) & ULL(0xffffffff));				\
!     WRITE_WORD(_src, GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(STL_C,			0x2e,
! 	"stl_c (unimpl)",	"a,o(b)",
  	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DGPR(RA), DGPR(RB), DNA)
  
! /* FIXME: not fully implemented... */
! #define STQ_C_IMPL							\
    {									\
      enum md_fault_type _fault;						\
  									\
!     WRITE_QWORD(GPR(RA), GPR(RB) + SEXT(OFS), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(STQ_C,			0x2f,
! 	"stq_c (unimpl)",	"a,o(b)",
! 	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define BR_IMPL								\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     SET_GPR(RA, CPC + 4);						\
    }
! DEFINST(BR,			0x30,
! 	"br",			"a,J",
! 	IntALU,			F_CTRL|F_UNCOND|F_DIRJMP,
! 	DGPR(RA), DNA,		DNA, DNA, DNA)
  
! #define FBEQ_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if (FPR(RA) == 0.0)							\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
    }
! DEFINST(FBEQ,			0x31,
! 	"fbeq",			"A,j",
! 	FloatADD,		F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DFPR(RA), DNA, DNA)
  
! #define FBLT_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if (FPR(RA) < 0.0)							\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
    }
! DEFINST(FBLT,			0x32,
! 	"fblt",			"A,j",
! 	FloatADD,		F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DFPR(RA), DNA, DNA)
  
! #define FBLE_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if (FPR(RA) <= 0.0)							\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
    }
! DEFINST(FBLE,			0x33,
! 	"fble",			"A,j",
! 	FloatADD,		F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DFPR(RA), DNA, DNA)
  
! /* NOTE: this is semantically equivalent to BR, the different opcode tips
!    off the predictor to use the return address stack... */
! #define BSR_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     SET_GPR(RA, CPC + 4);						\
    }
! DEFINST(BSR,			0x34,
! 	"bsr",			"a,J",
! 	IntALU,			F_CTRL|F_UNCOND|F_DIRJMP,
! 	DGPR(RA), DNA,		DNA, DNA, DNA)
  
! #define FBNE_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if (FPR(RA) != 0.0)							\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
    }
! DEFINST(FBNE,			0x35,
! 	"fbne",			"A,j",
! 	FloatADD,		F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DFPR(RA), DNA, DNA)
  
! #define FBGE_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if (FPR(RA) >= 0.0)							\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
    }
! DEFINST(FBGE,			0x36,
! 	"fbge",			"A,j",
! 	FloatADD,		F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DFPR(RA), DNA, DNA)
  
! #define FBGT_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if (FPR(RA) > 0.0)							\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
    }
! DEFINST(FBGT,			0x37,
! 	"fbgt",			"A,j",
! 	FloatADD,		F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DFPR(RA), DNA, DNA)
  
! #define BLBC_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if (!(GPR(RA) & 1))							\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
    }
! DEFINST(BLBC,			0x38,
! 	"blbc",			"a,j",
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RA), DNA, DNA)
  
! #define BEQ_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if (GPR(RA) == ULL(0))						\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!   }
! DEFINST(BEQ,			0x39,
! 	"beq",			"a,j",
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RA), DNA, DNA)
! 
! #define BLT_IMPL							\
!   {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if ((sqword_t)GPR(RA) < LL(0))					\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!   }
! DEFINST(BLT,			0x3a,
! 	"blt",			"a,j",
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RA), DNA, DNA)
! 
! #define BLE_IMPL							\
!   {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if ((sqword_t)GPR(RA) <= LL(0))					\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
    }
! DEFINST(BLE,			0x3b,
! 	"ble",			"a,j",
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RA), DNA, DNA)
  
! #define BLBS_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if (GPR(RA) & 1)							\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
    }
! DEFINST(BLBS,			0x3c,
! 	"blbs",			"a,j",
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RA), DNA, DNA)
  
! #define BNE_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if (GPR(RA) != ULL(0))						\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
    }
! DEFINST(BNE,			0x3d,
! 	"bne",			"a,j",
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RA), DNA, DNA)
  
! #define BGE_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if ((sqword_t)GPR(RA) >= LL(0))					\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
    }
! DEFINST(BGE,			0x3e,
! 	"bge",			"a,j",
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RA), DNA, DNA)
  
! #define BGT_IMPL							\
    {									\
!     SET_TPC(CPC + (SEXT21(TARG) << 2) + 4);				\
!     if ((sqword_t)GPR(RA) > LL(0))					\
!       SET_NPC(CPC + (SEXT21(TARG) << 2) + 4);				\
    }
! DEFINST(BGT,			0x3f,
! 	"bgt",			"a,j",
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RA), DNA, DNA)
  
  
! CONNECT(CALL_PAL)
! 
! #define PAL_CALLSYS_IMPL						\
    {									\
!     SYSCALL(inst);							\
    }
! DEFINST(PAL_CALLSYS,		0x83,
! 	"call_pal callsys",	"",
! 	NA,			F_TRAP,
! 	DNA, DNA,		DNA, DNA, DNA)
  
- #define PAL_RDUNIQ_IMPL							\
-   {									\
-     SET_GPR(/* v0 */0, UNIQ);						\
-   }
- DEFINST(PAL_RDUNIQ,		0x9e,
- 	"call_pal rduniq",	"",
- 	NA,			F_TRAP,
- 	DGPR(/* v0 */0), DNA,	DUNIQ, DNA, DNA)
  
! #define PAL_WRUNIQ_IMPL							\
    {									\
!     SET_UNIQ(GPR(/* a0 */16));						\
    }
! DEFINST(PAL_WRUNIQ,		0x9f,
! 	"call_pal wruniq",	"",
! 	NA,			F_TRAP,
! 	DUNIQ, DNA,		DGPR(/* a0 */16), DNA, DNA)
! 	
! 
! CONNECT(INTA)
! 
! DEFLINK(ADDL_LINK, 0x00, "addl_link", 12, 1)
! 
! DEFLINK(S4ADDL_LINK, 0x02, "s4addl_link", 12, 1)
! 
! DEFLINK(SUBL_LINK, 0x09, "subl_link", 12, 1)
  
! DEFLINK(S4SUBL_LINK, 0x0b, "s4subl_link", 12, 1)
! 
! DEFLINK(CMPBGE_LINK, 0x0f, "cmpbge_link", 12, 1)
! 
! DEFLINK(S8ADDL_LINK, 0x12, "s8addl_link", 12, 1)
! 
! DEFLINK(S8SUBL_LINK, 0x1b, "s8subl_link", 12, 1)
! 
! DEFLINK(CMPULT_LINK, 0x1d, "cmpult_link", 12, 1)
! 
! DEFLINK(ADDQ_LINK, 0x20, "addq_link", 12, 1)
! 
! DEFLINK(S4ADDQ_LINK, 0x22, "s4addq_link", 12, 1)
! 
! DEFLINK(SUBQ_LINK, 0x29, "subq_link", 12, 1)
! 
! DEFLINK(S4SUBQ_LINK, 0x2b, "s4subq_link", 12, 1)
! 
! DEFLINK(CMPEQ_LINK, 0x2d, "cmpeq_link", 12, 1)
! 
! DEFLINK(S8ADDQ_LINK, 0x32, "s8addq_link", 12, 1)
! 
! DEFLINK(S8SUBQ_LINK, 0x3b, "s8subq_link", 12, 1)
! 
! DEFLINK(CMPULE_LINK, 0x3d, "cmpule_link", 12, 1)
! 
! DEFLINK(ADDLV_LINK, 0x40, "addlv_link", 12, 1)
! 
! DEFLINK(SUBLV_LINK, 0x49, "sublv_link", 12, 1)
! 
! DEFLINK(CMPLT_LINK, 0x4d, "cmplt_link", 12, 1)
! 
! DEFLINK(ADDQV_LINK, 0x60, "addqv_link", 12, 1)
! 
! DEFLINK(SUBQV_LINK, 0x69, "subqv_link", 12, 1)
! 
! DEFLINK(CMPLE_LINK, 0x6d, "cmple_link", 12, 1)
! 
! 
! CONNECT(ADDL_LINK)
! 
! #define ADDL_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32((GPR(RA) + GPR(RB)) & ULL(0xffffffff)));		\
    }
! DEFINST(ADDL,			0x00,
! 	"addl",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define ADDLI_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32((GPR(RA) + IMM) & ULL(0xffffffff)));		\
    }
! DEFINST(ADDLI,			0x01,
! 	"addl",			"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 	
  
! CONNECT(S4ADDL_LINK)
  
! #define S4ADDL_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32(((GPR(RA) << 2) + GPR(RB)) & ULL(0xffffffff)));	\
    }
! DEFINST(S4ADDL,			0x00,
! 	"s4addl",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define S4ADDLI_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32(((GPR(RA) << 2) + IMM) & ULL(0xffffffff)));	\
    }
! DEFINST(S4ADDLI,		0x01,
! 	"s4addl",		"a,i,c",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 	
  
! CONNECT(SUBL_LINK)
! 
! #define SUBL_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32((GPR(RA) - GPR(RB)) & ULL(0xffffffff)));		\
    }
! DEFINST(SUBL,			0x00,
! 	"subl",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define SUBLI_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32((GPR(RA) - IMM) & ULL(0xffffffff)));		\
    }
! DEFINST(SUBLI,			0x01,
! 	"subl",			"a,i,c",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
  
! 
! CONNECT(S4SUBL_LINK)
! 
! #define S4SUBL_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32(((GPR(RA) << 2) - GPR(RB)) & ULL(0xffffffff)));	\
    }
! DEFINST(S4SUBL,			0x00,
! 	"s4subl",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define S4SUBLI_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32(((GPR(RA) << 2) - IMM) & ULL(0xffffffff)));	\
    }
! DEFINST(S4SUBLI,		0x01,
! 	"s4subl",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
  
! CONNECT(CMPBGE_LINK)
! 
! #define CMPBGE_IMPL							\
    {									\
      int _i;								\
!     qword_t _rav, _rbv;							\
  									\
!     _rav = GPR(RA);							\
!     _rbv = GPR(RB);							\
!     SET_GPR(RC, 0);							\
  									\
!     for (_i = 56; _i >= 0; _i -= 8)					\
        {									\
! 	SET_GPR(RC, GPR(RC) << 1);					\
! 	SET_GPR(RC, (GPR(RC)						\
! 		     | ((_rav >> _i & (sqword_t)0xff) >=		\
! 			(_rbv >> _i & (sqword_t)0xff))));		\
        }									\
    }
! DEFINST(CMPBGE,			0x00,
! 	"cmpbge",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define CMPBGEI_IMPL							\
    {									\
      int _i;								\
-     qword_t _rav, _rbv;							\
  									\
!     _rav = GPR(RA);							\
!     _rbv = IMM;								\
!     SET_GPR(RC, 0);							\
  									\
!     for (_i = 56; _i >= 0; _i -= 8)					\
        {									\
! 	SET_GPR(RC, GPR(RC) << 1);					\
! 	SET_GPR(RC, (GPR(RC)						\
! 		     | ((_rav >> _i & (sqword_t)0xff) >=		\
! 			(_rbv >> _i & (sqword_t)0xff))));		\
        }									\
    }
! DEFINST(CMPBGEI,		0x01,
! 	"cmpbge",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
  
! CONNECT(S8ADDL_LINK)
! 
! #define S8ADDL_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32(((GPR(RA) << 3) + GPR(RB)) & ULL(0xffffffff)));	\
    }
! DEFINST(S8ADDL,			0x00,
! 	"s8addl",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 	
! #define S8ADDLI_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32(((GPR(RA) << 3) + IMM) & ULL(0xffffffff)));	\
    }
! DEFINST(S8ADDLI,		0x01,
! 	"s8addl",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 	
  
! CONNECT(S8SUBL_LINK)
! 
! #define S8SUBL_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32(((GPR(RA) << 3) - GPR(RB)) & ULL(0xffffffff)));	\
    }
! DEFINST(S8SUBL,			0x00,
! 	"s8subl",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 	
! #define S8SUBLI_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32(((GPR(RA) << 3) - IMM) & ULL(0xffffffff)));	\
    }
! DEFINST(S8SUBLI,		0x01,
! 	"s8subl",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
  
! 
! CONNECT(CMPULT_LINK)
! 
! #define CMPULT_IMPL							\
    {									\
!     SET_GPR(RC, (qword_t)GPR(RA) < (qword_t)GPR(RB));			\
    }
! DEFINST(CMPULT,			0x00,
! 	"cmpult",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define CMPULTI_IMPL							\
    {									\
!     SET_GPR(RC, (qword_t)GPR(RA) < (qword_t)IMM);			\
    }
! DEFINST(CMPULTI,		0x01,
! 	"cmpult",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
  
! 
! CONNECT(ADDQ_LINK)
! 
! #define ADDQ_IMPL							\
    {									\
!     SET_GPR(RC, GPR(RA) + GPR(RB));					\
    }
! DEFINST(ADDQ,			0x00,
! 	"addq",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 	
! #define ADDQI_IMPL							\
    {									\
!     SET_GPR(RC, GPR(RA) + IMM);						\
    }
! DEFINST(ADDQI,			0x01,
! 	"addq",			"a,i,c",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
  
! CONNECT(S4ADDQ_LINK)
! 
! #define S4ADDQ_IMPL							\
    {									\
!     SET_GPR(RC, (GPR(RA) << 2) + GPR(RB));				\
    }
! DEFINST(S4ADDQ,			0x00,
! 	"s4addq",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define S4ADDQI_IMPL							\
    {									\
!     SET_GPR(RC, (GPR(RA) << 2) + IMM);					\
    }
! DEFINST(S4ADDQI,		0x01,
! 	"s4addq",		"a,i,c",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
  
! 
! CONNECT(SUBQ_LINK)
! 
! #define SUBQ_IMPL							\
    {									\
!     SET_GPR(RC, GPR(RA) - GPR(RB));					\
    }
! DEFINST(SUBQ,			0x00,
! 	"subq",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define SUBQI_IMPL							\
    {									\
!     SET_GPR(RC, GPR(RA) - IMM);						\
    }
! DEFINST(SUBQI,			0x01,
! 	"subq",			"a,i,c",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
  
! CONNECT(S4SUBQ_LINK)
! 
! #define S4SUBQ_IMPL							\
    {									\
!     SET_GPR(RC, (GPR(RA) << 2) - GPR(RB));				\
    }
! DEFINST(S4SUBQ,			0x00,
! 	"s4subq",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define S4SUBQI_IMPL							\
    {									\
!     SET_GPR(RC, (GPR(RA) << 2) - IMM);					\
    }
! DEFINST(S4SUBQI,		0x01,
! 	"s4subq",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
  
! CONNECT(CMPEQ_LINK)
! 
! #define CMPEQ_IMPL							\
    {									\
!     SET_GPR(RC, GPR(RA) == GPR(RB));					\
    }
! DEFINST(CMPEQ,			0x00,
! 	"cmpeq",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define CMPEQI_IMPL							\
    {									\
!     SET_GPR(RC, GPR(RA) == (qword_t)IMM);				\
    }
! DEFINST(CMPEQI,			0x01,
! 	"cmpeq",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(S8ADDQ_LINK)
! 
! #define S8ADDQ_IMPL							\
    {									\
!     SET_GPR(RC, (GPR(RA) << 3) + GPR(RB));				\
    }
! DEFINST(S8ADDQ,			0x00,
! 	"s8addq",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define S8ADDQI_IMPL							\
    {									\
!     SET_GPR(RC, (GPR(RA) << 3) + IMM);					\
    }
! DEFINST(S8ADDQI,		0x01,
! 	"s8addq",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(S8SUBQ_LINK)
! 
! #define S8SUBQ_IMPL							\
    {									\
!     SET_GPR(RC, (GPR(RA) << 3) - GPR(RB));				\
    }
! DEFINST(S8SUBQ,			0x00,
! 	"s8subq",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define S8SUBQI_IMPL							\
    {									\
!     SET_GPR(RC, (GPR(RA) << 3) - IMM);					\
    }
! DEFINST(S8SUBQI,		0x01,
! 	"s8subq",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(CMPULE_LINK)
! 
! #define CMPULE_IMPL							\
    {									\
!     SET_GPR(RC, (qword_t)GPR(RA) <= (qword_t)GPR(RB));			\
    }
! DEFINST(CMPULE,			0x00,
! 	"cmpule",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define CMPULEI_IMPL							\
    {									\
!     SET_GPR(RC, (qword_t)GPR(RA) <= (qword_t)IMM);			\
    }
! DEFINST(CMPULEI,		0x01,
! 	"cmpule",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(ADDLV_LINK)
  
! #define ADDLV_IMPL							\
    {									\
!     /* FIXME: not checking for overflows... */				\
!     SET_GPR(RC, SEXT32((GPR(RA) + GPR(RB)) & ULL(0xffffffff)));		\
    }
! DEFINST(ADDLV,			0x00,
! 	"addl/v (unimpl)",	"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define ADDLVI_IMPL							\
    {									\
!     /* FIXME: not checking for overflows... */				\
!     SET_GPR(RC, SEXT32((GPR(RA) + IMM) & ULL(0xffffffff)));		\
    }
! DEFINST(ADDLVI,			0x01,
! 	"addl/v (unimpl)",	"a,i,c",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(SUBLV_LINK)
  
! #define SUBLV_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32((GPR(RA) - GPR(RB)) & ULL(0xffffffff)));		\
    }
! DEFINST(SUBLV,			0x00,
! 	"subl/v (unimpl)",	"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define SUBLVI_IMPL							\
    {									\
!     SET_GPR(RC, SEXT32((GPR(RA) - IMM) & ULL(0xffffffff)));		\
    }
! DEFINST(SUBLVI,			0x01,
! 	"subl/v (unimpl)",	"a,i,c",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
  
  
! CONNECT(CMPLT_LINK)
  
! #define CMPLT_IMPL							\
    {									\
!     SET_GPR(RC, (sqword_t)GPR(RA) < (sqword_t)GPR(RB));			\
    }
! DEFINST(CMPLT,			0x00,
! 	"cmplt",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define CMPLTI_IMPL							\
    {									\
!     SET_GPR(RC, (sqword_t)GPR(RA) < (sqword_t)IMM);			\
    }
! DEFINST(CMPLTI,		0x01,
! 	"cmplt",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(ADDQV_LINK)
  
! #define ADDQV_IMPL							\
    {									\
!     /* FIXME: not checking for overflows... */				\
!     SET_GPR(RC, GPR(RA) + GPR(RB));					\
    }
! DEFINST(ADDQV,			0x00,
! 	"addq/v (unimpl)",	"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define ADDQVI_IMPL							\
    {									\
!     /* FIXME: not checking for overflows... */				\
!     SET_GPR(RC, GPR(RA) + IMM);						\
    }
! DEFINST(ADDQVI,			0x01,
! 	"addq/v (unimpl)",	"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
  
  
! CONNECT(SUBQV_LINK)
  
! #define SUBQV_IMPL							\
    {									\
!     /* FIXME: not checking for overflows... */				\
!     SET_GPR(RC, GPR(RA) - GPR(RB));					\
    }
! DEFINST(SUBQV,			0x00,
! 	"subq/v (unimpl)",	"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define SUBQVI_IMPL							\
    {									\
!     /* FIXME: not checking for overflows... */				\
!     SET_GPR(RC, GPR(RA) - IMM);						\
    }
! DEFINST(SUBQVI,			0x01,
! 	"subq/v (unimpl)",	"a,b,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
  
  
! CONNECT(CMPLE_LINK)
  
! #define CMPLE_IMPL							\
    {									\
!     SET_GPR(RC, (sqword_t)GPR(RA) <= (sqword_t)GPR(RB));		\
    }
! DEFINST(CMPLE,			0x00,
! 	"cmple",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define CMPLEI_IMPL							\
    {									\
!     SET_GPR(RC, (sqword_t)GPR(RA) <= (sqword_t)IMM);			\
    }
! DEFINST(CMPLEI,		0x01,
! 	"cmple",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
  
  
! CONNECT(INTL)
! 
! DEFLINK(AND_LINK, 0x00, "and_link", 12, 1)
! 
! DEFLINK(BIC_LINK, 0x08, "bic_link", 12, 1)  /* FIXME: PRM says 0x11.0x00 ?! */
! 
! DEFLINK(CMOVLBS_LINK, 0x14, "cmovlbs_link", 12, 1)
! 
! DEFLINK(CMOVLBC_LINK, 0x16, "cmovlbc_link", 12, 1)
! 
! /* FIXME: BetaDyn recodes some of these for SMT insts (NOP technology)... */
! DEFLINK(BIS_LINK, 0x20, "bis_link", 12, 1)
! 
! DEFLINK(CMOVEQ_LINK, 0x24, "cmoveq_link", 12, 1)
! 
! DEFLINK(CMOVNE_LINK, 0x26, "cmovne_link", 12, 1)
! 
! DEFLINK(ORNOT_LINK, 0x28, "ornot_link", 12, 1)
! 
! DEFLINK(XOR_LINK, 0x40, "xor_link", 12, 1)
! 
! DEFLINK(CMOVLT_LINK, 0x44, "cmovlt_link", 12, 1)
! 
! DEFLINK(CMOVGE_LINK, 0x46, "cmovge_link", 12, 1)
! 
! DEFLINK(EQV_LINK, 0x48, "eqv_link", 12, 1)
! 
! /* added 02/27/99, plakal@cecil, from Alpha Arch Handbook (Rev.4, EV6) */
! DEFLINK(AMASK_LINK, 0x61, "amask_link", 12, 1)
! 
! DEFLINK(CMOVLE_LINK, 0x64, "cmovle_link", 12, 1)
! 
! DEFLINK(CMOVGT_LINK, 0x66, "cmovgt_link", 12, 1)
! 
! /* added 02/27/99, plakal@cecil, from Alpha Arch Handbook (Rev.4, EV6) */
!  
! /* major implementation version of processor, used for code-scheduling
!  decisions, rather than ISA decisions. Makes sense to return EV6 -- for
!  sim-outorder */
! #define IMPLVER_IMPL							\
!   {									\
!     SET_GPR(RC, ULL(2));					        \
!   }
! DEFINST(IMPLVER,		0x6c,
! 	"implver",		"c",
! 	NA,			NA,
! 	DGPR(RC), DNA,		DNA, DNA, DNA)
! 
! 
! CONNECT(AND_LINK)
! 
! #define AND_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) & GPR(RB));					\
!   }
! DEFINST(AND,			0x00,
! 	"and",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define ANDI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) & IMM);						\
!   }
! DEFINST(ANDI,			0x01,
! 	"and",			"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(BIC_LINK)
! 
! #define BIC_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) & ~GPR(RB));					\
!   }
! DEFINST(BIC,			0x00,
! 	"bic",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define BICI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) & ~IMM);					\
!   }
! DEFINST(BICI,			0x01,
! 	"bic",			"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(CMOVLBS_LINK)
! 
! #define CMOVLBS_IMPL							\
!   {									\
!     if (GPR(RA) & 1)							\
!       SET_GPR(RC, GPR(RB));						\
!   }
! DEFINST(CMOVLBS,		0x00,
! 	"cmovlbs",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define CMOVLBSI_IMPL							\
!   {									\
!     if (GPR(RA) & 1)							\
!       SET_GPR(RC, IMM);							\
!   }
! DEFINST(CMOVLBSI,		0x01,
! 	"cmovlbs",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(CMOVLBC_LINK)
! 
! #define CMOVLBC_IMPL							\
!   {									\
!     if ((GPR(RA) & 1) == 0)						\
!       SET_GPR(RC, GPR(RB));						\
!   }
! DEFINST(CMOVLBC,		0x00,
! 	"cmovlbc",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define CMOVLBCI_IMPL							\
!   {									\
!     if ((GPR(RA) & 1) == 0)						\
!       SET_GPR(RC, IMM);							\
!   }
! DEFINST(CMOVLBCI,		0x01,
! 	"cmovlbc",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(BIS_LINK)
! 
! #define BIS_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) | GPR(RB));					\
!   }
! DEFINST(BIS,			0x00,
! 	"bis",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define BISI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) | IMM);						\
!   }
! DEFINST(BISI,			0x01,
! 	"bis",			"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(CMOVEQ_LINK)
! 
! #define CMOVEQ_IMPL							\
!   {									\
!     if (GPR(RA) == 0)							\
!       SET_GPR(RC, GPR(RB));						\
!   }
! DEFINST(CMOVEQ,			0x00,
! 	"cmoveq",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define CMOVEQI_IMPL							\
!   {									\
!     if (GPR(RA) == 0)							\
!       SET_GPR(RC, IMM);							\
!   }
! DEFINST(CMOVEQI,		0x01,
! 	"cmoveq",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(CMOVNE_LINK)
! 
! #define CMOVNE_IMPL							\
!   {									\
!     if (GPR(RA) != 0)							\
!       SET_GPR(RC, GPR(RB));						\
!   }
! DEFINST(CMOVNE,			0x00,
! 	"cmovne",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define CMOVNEI_IMPL							\
!   {									\
!     if (GPR(RA) != 0)							\
!       SET_GPR(RC, IMM);							\
!   }
! DEFINST(CMOVNEI,		0x01,
! 	"cmovne",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(ORNOT_LINK)
! 
! #define ORNOT_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) | ~GPR(RB));					\
!   }
! DEFINST(ORNOT,			0x00,
! 	"ornot",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define ORNOTI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) | ~IMM);					\
!   }
! DEFINST(ORNOTI,			0x01,
! 	"ornot",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(XOR_LINK)
! 
! #define XOR_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) ^ GPR(RB));					\
!   }
! DEFINST(XOR,			0x00,
! 	"xor",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define XORI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) ^ IMM);						\
!   }
! DEFINST(XORI,			0x01,
! 	"xor",			"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(CMOVLT_LINK)
! 
! #define CMOVLT_IMPL							\
!   {									\
!     if ((sqword_t)GPR(RA) < LL(0))					\
!       SET_GPR(RC, GPR(RB));						\
!   }
! DEFINST(CMOVLT,			0x00,
! 	"cmovlt",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define CMOVLTI_IMPL							\
!   {									\
!     if ((sqword_t)GPR(RA) < LL(0))					\
!       SET_GPR(RC, IMM);							\
!   }
! DEFINST(CMOVLTI,		0x01,
! 	"cmovlt",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(CMOVGE_LINK)
! 
! #define CMOVGE_IMPL							\
!   {									\
!     if ((sqword_t)GPR(RA) >= LL(0))					\
!       SET_GPR(RC, GPR(RB));						\
!   }
! DEFINST(CMOVGE,			0x00,
! 	"cmovge",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define CMOVGEI_IMPL							\
!   {									\
!     if ((sqword_t)GPR(RA) >= LL(0))					\
!       SET_GPR(RC, IMM);							\
!   }
! DEFINST(CMOVGEI,		0x01,
! 	"cmovge",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(EQV_LINK)
! 
! #define EQV_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) ^ ~GPR(RB));					\
!   }
! DEFINST(EQV,			0x00,
! 	"eqv",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define EQVI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) ^ ~IMM);					\
!   }
! DEFINST(EQVI,			0x01,
! 	"eqv",			"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! /* added 02/27/99, plakal@cecil, from Alpha Arch Handbook (Rev.4, EV6) */
! CONNECT(AMASK_LINK)
! 
! /* AMASK queries support for ISA extensions, currently we support:
! 	BWX (clear bit 0)
! 	FIX (clear bit 1) 
! 	CIX (clear bit 2)
! 	MVI (clear bit 8)
! */
! #define AMASK_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RB) & ULL(0xfffffffffffffef8));			\
!   }
! DEFINST(AMASK,			0x00,
! 	"amask",		"b,c",
! 	NA,			NA,
! 	DGPR(RC), DNA,		DGPR(RB), DNA, DNA)
! 
! #define AMASKI_IMPL							\
!   {									\
!     SET_GPR(RC, IMM & ULL(0xfffffffffffffef8));				\
!   }
! DEFINST(AMASKI,			0x01,
! 	"amask",		"i,c",
! 	NA,			F_IMM,
! 	DGPR(RC), DNA,		DNA, DNA, DNA)
! 
! 
! CONNECT(CMOVLE_LINK)
! 
! #define CMOVLE_IMPL							\
!   {									\
!     if ((sqword_t)GPR(RA) <= LL(0))					\
!       SET_GPR(RC, GPR(RB));						\
!   }
! DEFINST(CMOVLE,			0x00,
! 	"cmovle",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define CMOVLEI_IMPL							\
!   {									\
!     if ((sqword_t)GPR(RA) <= LL(0))					\
!       SET_GPR(RC, IMM);							\
!   }
! DEFINST(CMOVLEI,		0x01,
! 	"cmovle",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(CMOVGT_LINK)
! 
! #define CMOVGT_IMPL							\
!   {									\
!     if ((sqword_t)GPR(RA) > LL(0))					\
!       SET_GPR(RC, GPR(RB));						\
!   }
! DEFINST(CMOVGT,			0x00,
! 	"cmovgt",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define CMOVGTI_IMPL							\
!   {									\
!     if ((sqword_t)GPR(RA) > LL(0))					\
!       SET_GPR(RC, IMM);							\
!   }
! DEFINST(CMOVGTI,		0x01,
! 	"cmovgt",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(INTS)
! 
! DEFLINK(MSKBL_LINK, 0x02, "mskbl_link", 12, 1)
! 
! DEFLINK(EXTBL_LINK, 0x06, "extbl_link", 12, 1)
! 
! DEFLINK(INSBL_LINK, 0x0b, "insbl_link", 12, 1)
! 
! DEFLINK(MSKWL_LINK, 0x12, "mskwl_link", 12, 1)
! 
! DEFLINK(EXTWL_LINK, 0x16, "extwl_link", 12, 1)
! 
! DEFLINK(INSWL_LINK, 0x1b, "inswl_link", 12, 1)
! 
! DEFLINK(MSKLL_LINK, 0x22, "mskll_link", 12, 1)
! 
! DEFLINK(EXTLL_LINK, 0x26, "extll_link", 12, 1)
! 
! DEFLINK(INSLL_LINK, 0x2b, "insll_link", 12, 1)
! 
! DEFLINK(ZAP_LINK, 0x30, "zap_link", 12, 1)
! 
! DEFLINK(ZAPNOT_LINK, 0x31, "zapnot_link", 12, 1)
! 
! DEFLINK(MSKQL_LINK, 0x32, "mskql_link", 12, 1)
! 
! DEFLINK(SRL_LINK, 0x34, "srl_link", 12, 1)
! 
! DEFLINK(EXTQL_LINK, 0x36, "extql_link", 12, 1)
! 
! DEFLINK(SLL_LINK, 0x39, "sll_link", 12, 1)
! 
! DEFLINK(INSQL_LINK, 0x3b, "insql_link", 12, 1)
! 
! DEFLINK(SRA_LINK, 0x3c, "sra_link", 12, 1)
! 
! DEFLINK(MSKWH_LINK, 0x52, "mskwh_link", 12, 1)
! 
! DEFLINK(INSWH_LINK, 0x57, "inswh_link", 12, 1)
! 
! DEFLINK(EXTWH_LINK, 0x5a, "extwh_link", 12, 1)
! 
! DEFLINK(MSKLH_LINK, 0x62, "msklh_link", 12, 1)
! 
! DEFLINK(INSLH_LINK, 0x67, "inslh_link", 12, 1)
! 
! DEFLINK(EXTLH_LINK, 0x6a, "extlh_link", 12, 1)
! 
! DEFLINK(MSKQH_LINK, 0x72, "mskqh_link", 12, 1)
! 
! DEFLINK(INSQH_LINK, 0x77, "insqh_link", 12, 1)
! 
! DEFLINK(EXTQH_LINK, 0x7a, "extqh_link", 12, 1)
! 
! 
! CONNECT(MSKBL_LINK)
! 
! #define MSKBL_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) & ~(ULL(0xff) << ((GPR(RB) & 0x7) * 8)));	\
!   }
! DEFINST(MSKBL,			0x00,
! 	"mskbl",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define MSKBLI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) & ~(ULL(0xff) << ((IMM & 0x7) * 8)));		\
!   }
! DEFINST(MSKBLI,			0x01,
! 	"mskbl",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(EXTBL_LINK)
! 
! #define EXTBL_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA) >> ((GPR(RB) & 0x7) * 8)) & LL(0xff));		\
!   }
! DEFINST(EXTBL,			0x00,
! 	"extbl",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define EXTBLI_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA) >> ((IMM & 0x7) * 8)) & LL(0xff));		\
!   }
! DEFINST(EXTBLI,			0x01,
! 	"extbl",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(INSBL_LINK)
! 
! #define INSBL_IMPL							\
!   {									\
!     SET_GPR(RC, ((GPR(RA) << ((GPR(RB) & 0x7) * 8))			\
! 		     & (ULL(0xff) << ((GPR(RB) & 0x7) * 8))));		\
!   }
! DEFINST(INSBL,			0x00,
! 	"insbl",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define INSBLI_IMPL							\
!   {									\
!     SET_GPR(RC, ((GPR(RA) << ((IMM & 0x7) * 8))				\
! 		     & (ULL(0xff) << ((IMM & 0x7) * 8))));		\
!   }
! DEFINST(INSBLI,			0x01,
! 	"insbl",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(MSKWL_LINK)
! 
! #define MSKWL_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) & ~(ULL(0xffff) << ((GPR(RB) & 0x7) * 8)));	\
!   }
! DEFINST(MSKWL,			0x00,
! 	"mskwl",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define MSKWLI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) & ~(ULL(0xffff) << ((IMM & 0x7) * 8)));		\
!   }
! DEFINST(MSKWLI,			0x01,
! 	"mskwl",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(EXTWL_LINK)
! 
! #define EXTWL_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA) >> ((GPR(RB) & 0x7) * 8)) & LL(0xffff));	\
!   }
! DEFINST(EXTWL,			0x00,
! 	"extwl",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define EXTWLI_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA) >> ((IMM & 0x7) * 8)) & LL(0xffff));		\
!   }
! DEFINST(EXTWLI,			0x01,
! 	"extwl",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(INSWL_LINK)
! 
! #define INSWL_IMPL							\
!   {									\
!     SET_GPR(RC, ((GPR(RA) << ((GPR(RB) & 0x7) * 8))			\
! 		     & (ULL(0xffff) << ((GPR(RB) & 0x7) * 8))));	\
!   }
! DEFINST(INSWL,			0x00,
! 	"inswl",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define INSWLI_IMPL							\
!   {									\
!     SET_GPR(RC, ((GPR(RA) << ((IMM & 0x7) * 8))				\
! 		     & (ULL(0xffff) << ((IMM & 0x7) * 8))));		\
!   }
! DEFINST(INSWLI,			0x01,
! 	"inswl",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(MSKLL_LINK)
! 
! #define MSKLL_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) & ~(ULL(0xffffffff) << ((GPR(RB) & 0x7) * 8)));	\
!   }
! DEFINST(MSKLL,			0x00,
! 	"mskll",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define MSKLLI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) & ~(ULL(0xffffffff) << ((IMM & 0x7) * 8)));	\
!   }
! DEFINST(MSKLLI,			0x01,
! 	"mskll",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(EXTLL_LINK)
! 
! #define EXTLL_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA) >> ((GPR(RB) & 0x7) * 8)) & LL(0xffffffff));	\
!   }
! DEFINST(EXTLL,			0x00,
! 	"extll",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define EXTLLI_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA) >> ((IMM & 0x7) * 8)) & LL(0xffffffff));	\
!   }
! DEFINST(EXTLLI,			0x01,
! 	"extll",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(INSLL_LINK)
! 
! #define INSLL_IMPL							\
!   {									\
!     SET_GPR(RC, ((GPR(RA) << ((GPR(RB) & 0x7) * 8))			\
! 		     & (ULL(0xffffffff) << ((GPR(RB) & 0x7) * 8))));	\
!   }
! DEFINST(INSLL,			0x00,
! 	"insll",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define INSLLI_IMPL							\
!   {									\
!     SET_GPR(RC, ((GPR(RA) << ((IMM & 0x7) * 8))				\
! 		     & (ULL(0xffffffff) << ((IMM & 0x7) * 8))));	\
!   }
! DEFINST(INSLLI,			0x01,
! 	"insll",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(ZAP_LINK)
! 
! #define ZAP_IMPL							\
!   {									\
!     int _i;								\
!     qword_t _temp = LL(0xff);						\
!     qword_t _rav = GPR(RA);						\
!     qword_t _rbv = GPR(RB);						\
! 									\
!     SET_GPR(RC, 0);							\
!     for (_i = 1; _i < 0x100; _i = _i << 1)				\
!       {									\
! 	if (_i & ~_rbv)							\
! 	  SET_GPR(RC, GPR(RC) | (_rav & _temp));			\
! 	_temp = _temp << 8;						\
!       }									\
!   }
! DEFINST(ZAP,			0x00,
! 	"zap",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define ZAPI_IMPL							\
!   {									\
!     int _i;								\
!     qword_t _temp = LL(0xff);						\
!     qword_t _rav = GPR(RA);						\
!     qword_t _rbv = IMM;							\
! 									\
!     SET_GPR(RC, 0);							\
!     for (_i = 1; _i < 0x100; _i = _i << 1)				\
!       {									\
! 	if (_i & ~_rbv)							\
! 	  SET_GPR(RC, GPR(RC) | (_rav & _temp));			\
! 	_temp = _temp << 8;						\
!       }									\
!   }
! DEFINST(ZAPI,			0x01,
! 	"zap",			"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(ZAPNOT_LINK)
! 
! #define ZAPNOT_IMPL							\
!   {									\
!     int _i;								\
!     qword_t _temp = LL(0xff);						\
!     qword_t _rav = GPR(RA);						\
!     qword_t _rbv = GPR(RB);						\
! 									\
!     SET_GPR(RC, 0);							\
!     for (_i = 1; _i < 0x100; _i = _i << 1)				\
!       {									\
! 	if (_i & _rbv)							\
! 	  SET_GPR(RC, GPR(RC) | (_rav & _temp));			\
! 	_temp = _temp << 8;						\
!       }									\
!   }
! DEFINST(ZAPNOT,			0x00,
! 	"zapnot",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define ZAPNOTI_IMPL							\
!   {									\
!     int _i;								\
!     qword_t _temp = LL(0xff);						\
!     qword_t _rav = GPR(RA);						\
!     qword_t _rbv = IMM;							\
! 									\
!     SET_GPR(RC, 0);							\
!     for (_i = 1; _i < 0x100; _i = _i << 1)				\
!       {									\
! 	if (_i & _rbv)							\
! 	  SET_GPR(RC, GPR(RC) | (_rav & _temp));			\
! 	_temp = _temp << 8;						\
!       }									\
!   }
! DEFINST(ZAPNOTI,		0x01,
! 	"zapnot",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(MSKQL_LINK)
! 
! #define MSKQL_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA)						\
! 		 & ~(ULL(0xffffffffffffffff)				\
! 		     << ((GPR(RB) & 0x7) * 8))));			\
!   }
! DEFINST(MSKQL,			0x00,
! 	"mskql",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define MSKQLI_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA)						\
! 		 & ~(ULL(0xffffffffffffffff) << ((IMM & 0x7) * 8))));	\
!   }
! DEFINST(MSKQLI,			0x01,
! 	"mskql",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(SRL_LINK)
! 
! #define SRL_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) >> (GPR(RB) & 0x3f));				\
!   }
! DEFINST(SRL,			0x00,
! 	"srl",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define SRLI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) >> (IMM & 0x3f));				\
!   }
! DEFINST(SRLI,			0x01,
! 	"srl",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(EXTQL_LINK)
! 
! #define EXTQL_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) >> ((GPR(RB) & 0x7) * 8));			\
!   }
! DEFINST(EXTQL,			0x00,
! 	"extql",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define EXTQLI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) >> ((IMM & 0x7) * 8));				\
!   }
! DEFINST(EXTQLI,			0x01,
! 	"extql",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(SLL_LINK)
! 
! #define	SLL_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) << (GPR(RB) & 0x3f));				\
!   }
! DEFINST(SLL,			0x00,
! 	"sll",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define SLLI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) << (IMM & 0x3f));				\
!   }
! DEFINST(SLLI,			0x01,
! 	"sll",			"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(INSQL_LINK)
! 
! #define INSQL_IMPL							\
!   {									\
!     SET_GPR(RC, ((GPR(RA) << ((GPR(RB) & 0x7) * 8))			\
! 		 & (ULL(0xffffffffffffffff) << ((GPR(RB) & 0x7) * 8))));\
!   }
! DEFINST(INSQL,			0x00,
! 	"insql",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define INSQLI_IMPL							\
!   {									\
!     SET_GPR(RC, ((GPR(RA) << ((IMM & 0x7) * 8))				\
! 		 & (ULL(0xffffffffffffffff) << ((IMM & 0x7) * 8))));	\
!   }
! DEFINST(INSQLI,			0x01,
! 	"insql",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! CONNECT(SRA_LINK)
! 
! #define SRA_IMPL							\
!   {									\
!     SET_GPR(RC, (sqword_t)GPR(RA) >> (GPR(RB) & 0x3f));			\
!   }
! DEFINST(SRA,			0x00,
! 	"sra",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define SRAI_IMPL							\
!   {									\
!     SET_GPR(RC, (sqword_t)GPR(RA) >> (IMM & 0x3f));			\
!   }
! DEFINST(SRAI,			0x01,
! 	"sra",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(MSKWH_LINK)
! 
! #define MSKWH_IMPL							\
!   {									\
!     if ((GPR(RB) & 0x7) != 0)						\
!       SET_GPR(RC, GPR(RA) & ~(ULL(0xffff) >> ((8 - (GPR(RB) & 0x7)) * 8)));\
!     else								\
!       SET_GPR(RC, GPR(RA));						\
!   }
! DEFINST(MSKWH,			0x00,
! 	"mskwh",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define MSKWHI_IMPL							\
!   {									\
!     if ((IMM & 0x7) != 0)						\
!       SET_GPR(RC, GPR(RA) & ~(ULL(0xffff) >> ((8 - (IMM & 0x7)) * 8)));	\
!     else								\
!       SET_GPR(RC, GPR(RA));						\
!   }
! DEFINST(MSKWHI,			0x01,
! 	"mskwh",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(INSWH_LINK)
! 
! #define INSWH_IMPL							\
!   {									\
!     if ((GPR(RB) & 0x7) != 0)						\
!       SET_GPR(RC, ((GPR(RA) >> (63 - (GPR(RB) & 0x7) * 8)) >> 1		\
! 		   & (ULL(0xffff) >> ((8 - (GPR(RB) & 0x7)) * 8))));	\
!     else								\
!       SET_GPR(RC, 0);							\
!   }
! DEFINST(INSWH,			0x00,
! 	"inswh",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define INSWHI_IMPL							\
!   {									\
!     if ((IMM & 0x7) != 0)						\
!       SET_GPR(RC, ((GPR(RA) >> (63 - (IMM & 0x7) * 8)) >> 1		\
! 		   & (ULL(0xffff) >> ((8 - (IMM & 0x7)) * 8))));	\
!     else								\
!       SET_GPR(RC, 0);							\
!   }
! DEFINST(INSWHI,			0x01,
! 	"inswh",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(EXTWH_LINK)
! 
! #define EXTWH_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA) << ((64 - (GPR(RB)&0x7) * 8) & 0x3f)) & LL(0xffff));\
!   }
! DEFINST(EXTWH,			0x00,
! 	"extwh",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define EXTWHI_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA) << ((64 - (IMM & 0x7) * 8) & 0x3f)) & LL(0xffff));\
!   }
! DEFINST(EXTWHI,			0x01,
! 	"extwh",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(MSKLH_LINK)
! 
! #define MSKLH_IMPL							\
!   {									\
!     if ((GPR(RB) & 0x7) != 0)						\
!       SET_GPR(RC, GPR(RA) & ~(ULL(0xffffffff) >>			\
! 			      ((8 - (GPR(RB) & 0x7)) * 8)));		\
!     else								\
!       SET_GPR(RC, GPR(RA));						\
!   }
! DEFINST(MSKLH,			0x00,
! 	"msklh",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define MSKLHI_IMPL							\
!   {									\
!     if ((IMM & 0x7) != 0)						\
!       SET_GPR(RC, GPR(RA) & ~(ULL(0xffffffff) >>			\
! 			      ((8 - (IMM & 0x7)) * 8)));		\
!     else								\
!       SET_GPR(RC, GPR(RA));						\
!   }
! DEFINST(MSKLHI,			0x01,
! 	"msklh",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(INSLH_LINK)
! 
! #define INSLH_IMPL							\
!   {									\
!     if ((GPR(RB) & 0x7) != 0)						\
!       SET_GPR(RC, ((GPR(RA) >> (63 - (GPR(RB) & 0x7) * 8)) >> 1		\
! 		   & (ULL(0xffffffff) >> ((8 - (GPR(RB) & 0x7)) * 8))));\
!     else								\
!       SET_GPR(RC, 0);							\
!   }
! DEFINST(INSLH,			0x00,
! 	"inslh",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define INSLHI_IMPL							\
!   {									\
!     if ((IMM & 0x7) != 0)						\
!       SET_GPR(RC, ((GPR(RA) >> (63 - (IMM & 0x7) * 8)) >> 1		\
! 		   & (ULL(0xffffffff) >> ((8 - (IMM & 0x7)) * 8))));	\
!     SET_GPR(RC, 0);							\
!   }
! DEFINST(INSLHI,			0x01,
! 	"inslh",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(EXTLH_LINK)
! 
! #define EXTLH_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA) <<						\
! 		 ((64 - (GPR(RB) & 0x7) * 8) & 0x3f)) & LL(0xffffffff));\
!   }
! DEFINST(EXTLH,			0x00,
! 	"extlh",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define EXTLHI_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA) << ((64 - (IMM&0x7) * 8) & 0x3f)) & LL(0xffffffff));\
!   }
! DEFINST(EXTLHI,			0x01,
! 	"extlh",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(MSKQH_LINK)
! 
! #define MSKQH_IMPL							\
!   {									\
!     if ((GPR(RB) & 0x7) != 0)						\
!       SET_GPR(RC, (GPR(RA) & ~(ULL(0xffffffffffffffff)			\
! 			       >> ((8 - (GPR(RB) & 0x7)) * 8))));	\
!     else								\
!       SET_GPR(RC, GPR(RA));						\
!   }
! DEFINST(MSKQH,			0x00,
! 	"mskqh",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define MSKQHI_IMPL							\
!   {									\
!     if ((IMM & 0x7) != 0)						\
!       SET_GPR(RC, (GPR(RA) & ~(ULL(0xffffffffffffffff)			\
! 			       >> ((8 - (IMM & 0x7)) * 8))));		\
!     else								\
!       SET_GPR(RC, GPR(RA));						\
!   }
! DEFINST(MSKQHI,			0x01,
! 	"mskqh",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(INSQH_LINK)
! 
! #define INSQH_IMPL							\
!   {									\
!     if ((GPR(RB) & 0x7) != 0)						\
!       SET_GPR(RC, ((GPR(RA) >> (63 - (GPR(RB) & 0x7) * 8)) >> 1		\
! 		   & (ULL(0xffffffffffffffff)				\
! 		      >> ((8 - (GPR(RB) & 0x7)) * 8))));		\
!     else								\
!       SET_GPR(RC, 0);							\
!   }
! DEFINST(INSQH,			0x00,
! 	"insqh",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define INSQHI_IMPL							\
!   {									\
!     if ((IMM & 0x7) != 0)						\
!       SET_GPR(RC, ((GPR(RA) >> (63 - (IMM & 0x7) * 8)) >> 1		\
! 		   & (ULL(0xffffffffffffffff)				\
! 		      >> ((8 - (IMM & 0x7)) * 8))));			\
!     else								\
!       SET_GPR(RC, 0);							\
!   }
! DEFINST(INSQHI,			0x01,
! 	"insqh",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(EXTQH_LINK)
! 
! #define EXTQH_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA) << ((64 - (GPR(RB) & 0x7) * 8) & 0x3f)));	\
!   }
! DEFINST(EXTQH,			0x00,
! 	"extqh",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define EXTQHI_IMPL							\
!   {									\
!     SET_GPR(RC, (GPR(RA) << ((64 - (IMM & 0x7) * 8) & 0x3f)));		\
!   }
! DEFINST(EXTQHI,			0x01,
! 	"extqh",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(INTM)
! 
! /* FIXME: changed mask in DEFLINK(INTM ... above so that MUL{Q,L}/V
!    now map to MUL{Q,L}, i.e. no overflow checking (earlier they
!    generated unimplemented-faults). I think this is more symmetrical
!    because {ADD,SUB}{L,Q}/V also do not check for overflow.  */
! 
! DEFLINK(MULL_LINK, 0x00, "mull_link", 12, 1)
! 
! DEFLINK(MULQ_LINK, 0x20, "mulq_link", 12, 1)
! 
! DEFLINK(UMULH_LINK, 0x30, "umulh_link", 12, 1)
! 
! 
! CONNECT(MULL_LINK)
! 
! #define MULL_IMPL							\
!   {									\
!     SET_GPR(RC, SEXT32((GPR(RA) * GPR(RB)) & ULL(0xffffffff)));		\
!   }
! DEFINST(MULL,			0x00,
! 	"mull",			"a,b,c",
! 	IntMULT,		F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define MULLI_IMPL							\
!   {									\
!     SET_GPR(RC, SEXT32((GPR(RA) * IMM) & ULL(0xffffffff)));		\
!   }
! DEFINST(MULLI,			0x01,
! 	"mull",			"a,i,c",
! 	IntMULT,		F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(MULQ_LINK)
! 
! #define MULQ_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) * GPR(RB));					\
!   }
! DEFINST(MULQ,			0x00,
! 	"mulq",			"a,b,c",
! 	IntMULT,		F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define MULQI_IMPL							\
!   {									\
!     SET_GPR(RC, GPR(RA) * IMM);						\
!   }
! DEFINST(MULQI,			0x01,
! 	"mulq",			"a,i,c",
! 	IntMULT,		F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(UMULH_LINK)
! 
! #define UMULH_IMPL							\
!   {									\
!     sqword_t _v1 = GPR(RA);						\
!     sqword_t _v2 = GPR(RB);						\
!     qword_t _result;							\
!     qword_t _a, _b, _c, _d;						\
!     qword_t _bd, _ad, _cb, _ac;						\
!     qword_t _mid, _mid2, _carry_mid = 0;				\
! 									\
!     _a = (_v1 >> 32) & LL(0xffffffff);					\
!     _b = _v1 & LL(0xffffffff);						\
!     _c = (_v2 >> 32) & LL(0xffffffff);					\
!     _d = _v2 & LL(0xffffffff);						\
!   /*myfprintf(stderr, "%n: %p %p %p %p\n", sim_num_insn, _a, _b, _c, _d);*/\
! 									\
!     _bd = _b * _d;							\
!     _ad = _a * _d;							\
!     _cb = _c * _b;							\
!     _ac = _a * _c;							\
!   /*myfprintf(stderr, "    %p %p %p %p\n", _bd, _ad, _cb, _ac);*/	\
! 									\
!     _mid = _ad + _cb;							\
!     if (ARITH_OVFL(_mid, _ad, _cb))					\
!       _carry_mid = 1;							\
! 									\
!     _mid2 = _mid + ((_bd >> 32) & LL(0xffffffff));			\
!     if (ARITH_OVFL(_mid2, _mid, ((_bd >> 32) & LL(0xffffffff))))	\
!       _carry_mid += 1;							\
!     _result =								\
!       _ac + (_carry_mid << 32) + ((_mid2 >> 32) & LL(0xffffffff));	\
!     /*myfprintf(stderr, "    %p %p %p %p\n", _mid,_mid2,_carry_mid,_result);*/\
! 									\
!     SET_GPR(RC, _result);						\
!   }
! DEFINST(UMULH,			0x00,
! 	"umulh",		"a,b,c",
! 	IntMULT,		F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define UMULHI_IMPL							\
!   {									\
!     sqword_t _v1 = GPR(RA);						\
!     sqword_t _v2 = IMM;							\
!     qword_t _result;							\
!     qword_t _a, _b, _c, _d;						\
!     qword_t _bd, _ad, _cb, _ac;						\
!     qword_t _mid, _mid2, _carry_mid = 0;				\
! 									\
!     _a = (_v1 >> 32) & LL(0xffffffff);					\
!     _b = _v1 & LL(0xffffffff);						\
!     _c = (_v2 >> 32) & LL(0xffffffff);					\
!     _d = _v2 & LL(0xffffffff);						\
! 									\
!     _bd = _b * _d;							\
!     _ad = _a * _d;							\
!     _cb = _c * _b;							\
!     _ac = _a * _c;							\
! 									\
!     _mid = _ad + _cb;							\
!     if (ARITH_OVFL(_mid, _ad, _cb))					\
!       _carry_mid = 1;							\
! 									\
!     _mid2 = _mid + ((_bd >> 32) & LL(0xffffffff));			\
!     if (ARITH_OVFL(_mid2, _mid, ((_bd >> 32) & LL(0xffffffff))))	\
!       _carry_mid += 1;							\
!     _result =								\
!       _ac + (_carry_mid << 32) + ((_mid2 >> 32) & LL(0xffffffff));	\
! 									\
!     SET_GPR(RC, _result);						\
!   }
! DEFINST(UMULHI,			0x01,
! 	"umulh",		"a,i,c",
! 	IntMULT,		F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! /* added 02/27/99, plakal@cecil, from Alpha Arch Handbook (Rev.4, EV6) */
! /* FIX extensions */
! CONNECT(ITFP)
! 
! #define ITOFS_IMPL							\
!   {									\
!     sqword_t _longhold, _e1, _e2;					\
! 									\
!     _longhold = GPR(RA) & ULL(0xffffffff);				\
! 									\
!     _e1 = _longhold & 0x40000000;					\
!     _e2 = (_longhold >> 23) & ULL(0x7f);				\
!     if (_e1)								\
!       {									\
! 	if (_e2 == ULL(0x3f800000))					\
! 	  _e2 = ULL(0x7ff);						\
! 	else								\
! 	  _e2 |= ULL(0x400);						\
!       }									\
!     else								\
!       {									\
! 	if (_e2 == 0)							\
! 	  _e2 = 0;							\
! 	else								\
! 	  _e2 |= ULL(0x380);						\
!       }									\
!     SET_FPR_Q(RC, (((_longhold & ULL(0x80000000)) << 32)		\
! 		   | (_e2 << 52) | ((_longhold & ULL(0x7fffff)) << 29)));\
!   }
! DEFINST(ITOFS,			0x04,
! 	"itofs",	        "a,C",
! 	FloatCVT,	        F_FCOMP,  /* FIXME: are these flags correct? */
! 	DFPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! #define SQRTF_IMPL							\
!   {									\
!     /* FIXME: unimplemented */						\
!     DECLARE_FAULT(md_fault_unimpl);					\
!   }
! DEFINST(SQRTF,			0x0a,
! 	"sqrtf (unimpl)",	"B,C",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
! 
! 
! #define SQRTS_IMPL							\
!   {									\
!      if (FPR(RB) < 0.0)							\
!        DECLARE_FAULT(md_fault_invalid);					\
! 									\
!    /* -- FIXME: too much precision here */				\
!      SET_FPR(RC, (dfloat_t)sqrt((double)FPR(RB)));			\
!   }
! DEFINST(SQRTS,			0x0b,
! 	"sqrts",	        "B,C",
! 	FloatSQRT,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RB), DNA, DNA)
! 
! #define ITOFF_IMPL							\
!   {									\
!     /* FIXME: unimplemented */						\
!     DECLARE_FAULT(md_fault_unimpl);					\
!   }
! DEFINST(ITOFF,			0x14,
! 	"itoff (unimpl)",	"a,C",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
! 
! #define ITOFT_IMPL							\
!   {									\
!     SET_FPR_Q(RC, GPR(RA));                                             \
!   }
! DEFINST(ITOFT,			0x24,
! 	"itoft",	        "a,C",
! 	FloatCVT,	        F_FCOMP,  /* FIXME: are these flags correct? */
! 	DFPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! #define SQRTG_IMPL							\
!   {									\
!     /* FIXME: unimplemented */						\
!     DECLARE_FAULT(md_fault_unimpl);					\
!   }
! DEFINST(SQRTG,			0x2a,
! 	"sqrtg (unimpl)",	"B,C",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
! 
! #define SQRTT_IMPL							\
!   {									\
!      if (FPR(RB) < 0.0)							\
!        DECLARE_FAULT(md_fault_invalid);					\
! 									\
!      SET_FPR(RC, (dfloat_t)sqrt((double)FPR(RB)));			\
!   }
! DEFINST(SQRTT,			0x2b,
! 	"sqrtt",	        "B,C",
! 	NA,			NA,
! 	DFPR(RC), DNA,		DFPR(RB), DNA, DNA)
! 
! 
! CONNECT(FLTI)
! 
! #define ADDS_IMPL							\
!   {									\
!     /* FIXME: too much precision here... */				\
!     SET_FPR(RC, FPR(RA) + FPR(RB));					\
!   }
! DEFINST(ADDS,			0x00,
! 	"adds",			"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define SUBS_IMPL							\
!   {									\
!     /* FIXME: too much precision here... */				\
!     SET_FPR(RC, FPR(RA) - FPR(RB));					\
!   }
! DEFINST(SUBS,			0x01,
! 	"subs",			"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define MULS_IMPL							\
!   {									\
!     /* FIXME: too much precision here... */				\
!     SET_FPR(RC, FPR(RA) * FPR(RB));					\
!   }
! DEFINST(MULS,			0x02,
! 	"muls",			"A,B,C",
! 	FloatMULT,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define DIVS_IMPL							\
!   {									\
!     /* FIXME: too much precision here... */				\
!     SET_FPR(RC, FPR(RA) / FPR(RB));					\
!   }
! DEFINST(DIVS,			0x03,
! 	"divs",			"A,B,C",
! 	FloatDIV,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define ADDT_IMPL							\
!   {									\
!     SET_FPR(RC, FPR(RA) + FPR(RB));					\
!   }
! DEFINST(ADDT,			0x20,
! 	"addt",			"A,B,C",
! 	FloatADD,			F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define SUBT_IMPL							\
!   {									\
!     SET_FPR(RC, FPR(RA) - FPR(RB));					\
!   }
! DEFINST(SUBT,			0x21,
! 	"subt",			"A,B,C",
! 	FloatADD,			F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define MULT_IMPL							\
!   {									\
!     SET_FPR(RC, FPR(RA) * FPR(RB));					\
!   }
! DEFINST(MULT,			0x22,
! 	"mult",			"A,B,C",
! 	FloatMULT,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define DIVT_IMPL							\
!   {									\
!     SET_FPR(RC, FPR(RA) / FPR(RB));					\
!   }
! DEFINST(DIVT,			0x23,
! 	"divt",			"A,B,C",
! 	FloatDIV,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define CMPTUN_IMPL							\
!   {									\
!     SET_FPR(RC, (IS_IEEEFP_DBL_NAN(FPR_Q(RA)) || IS_IEEEFP_DBL_NAN(FPR_Q(RB)))\
! 	         ? 2.0 							\
! 	         : 0.0);						\
!   }
! DEFINST(CMPTUN,			0x24,
! 	"cmptun",	        "A,B,C",
! 	FloatCMP,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define CMPTEQ_IMPL							\
!   {									\
!     SET_FPR(RC, (((FPR_Q(RA) == FPR_Q(RB))				\
! 		  || (FPR_Q(RA) << 1 == ULL(0)				\
! 		      && FPR_Q(RB) << 1 == ULL(0)))			\
! 		 ? 2.0							\
! 		 : 0.0));						\
!   }
! DEFINST(CMPTEQ,			0x25,
! 	"cmpteq",		"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define CMPTLT_IMPL							\
!   {									\
!     SET_FPR(RC, (FPR(RA) < FPR(RB)) ? 2.0 : 0.0);			\
!   }
! DEFINST(CMPTLT,			0x26,
! 	"cmptlt",		"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define CMPTLE_IMPL							\
!   {									\
!     SET_FPR(RC, (FPR(RA) <= FPR(RB)) ? 2.0 : 0.0);			\
!   }
! DEFINST(CMPTLE,			0x27,
! 	"cmptle",		"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define CVTTS_IMPL							\
!   {									\
!     SET_FPR(RC, (float)FPR(RB));					\
!   }
! DEFINST(CVTTS,			0x2c,
! 	"cvtts",		"B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RB), DNA, DNA)
! 
! #define CVTTQ_IMPL							\
!   {									\
!     SET_FPR_Q(RC, (sqword_t)FPR(RB));					\
!   }
! DEFINST(CVTTQ,			0x2f,
! 	"cvttq",		"B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RB), DNA, DNA)
! 
! #define CVTQS_IMPL							\
!   {									\
!     /* FIXME: too much precision here... */				\
!     SET_FPR(RC, (sqword_t)FPR_Q(RB));					\
!   }
! DEFINST(CVTQS,			0x3c,
! 	"cvtqs",		"B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RB), DNA, DNA)
! 
! #define CVTQT_IMPL							\
!   {									\
!     SET_FPR(RC, (sqword_t)FPR_Q(RB));					\
!   }
! DEFINST(CVTQT,			0x3e,
! 	"cvtqt",		"B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RB), DNA, DNA)
! 
! 
! CONNECT(FLTL)
! 
! #define CVTLQ_IMPL							\
!   {									\
!     sqword_t _longhold;							\
!     sword_t _inthold;							\
! 									\
!     _longhold = FPR_Q(RB);						\
!     _inthold = (((_longhold >> 32) & 0xc0000000)			\
! 		| ((_longhold >> 29) & 0x3fffffff));			\
!     SET_FPR_Q(RC, (sqword_t)_inthold);					\
!   }
! 
! DEFINST(CVTLQ,			0x10,
! 	"cvtlq",		"B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RB), DNA, DNA)
! 
! #define CPYS_IMPL							\
!   {									\
!     SET_FPR_Q(RC, ((FPR_Q(RA) & ULL(1) << 63)				\
! 		   | (FPR_Q(RB) & LL(0x7fffffffffffffff))));		\
!   }
! DEFINST(CPYS,			0x20,
! 	"cpys",			"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define CPYSN_IMPL							\
!   {									\
!     SET_FPR_Q(RC, ((FPR_Q(RA) >> 63 ^ 1) << 63				\
! 		   | (FPR_Q(RB) & LL(0x7fffffffffffffff))));		\
!   }
! DEFINST(CPYSN,			0x21,
! 	"cpysn",		"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define CPYSE_IMPL							\
!   {									\
!     SET_FPR_Q(RC, ((FPR_Q(RA) & ULL(0xfff) << 52)			\
! 		   | (FPR_Q(RB) & ULL(0xfffffffffffff))));		\
!   }
! DEFINST(CPYSE,			0x22,
! 	"cpyse",		"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define MT_FPCR_IMPL							\
!   {									\
!     /* FIXED, 02/26/99, plakal@cecil, Glew's fix, read FP reg as qword */\
!     SET_FPCR(FPR_Q(RA));						\
!   }
! DEFINST(MT_FPCR,		0x24,
! 	"mt_fpcr",		"A",
! 	FloatADD,		F_FCOMP,
! 	DFPCR, DNA,		DFPR(RA), DNA, DNA)
! 
! #ifdef _MSC_VER
! #define MF_FPCR_IMPL							\
!   {									\
!     /* FIXME: qword_t to double conversion not implemented in MSC */	\
!     /* FIXED, 02/26/99, plakal@cecil, using Glew's fix, set FP reg as qword */\
!     SET_FPR_Q(RA, FPCR);						\
!   }
! #else /* !_MSC_VER */
! #define MF_FPCR_IMPL							\
!   {									\
!     /* FIXED, 02/26/99, plakal@cecil, using Glew's fix, set FP reg as qword */\
!     SET_FPR_Q(RA, FPCR);						\
!   }
! #endif /* _MSC_VER */
! DEFINST(MF_FPCR,		0x25,
! 	"mf_fpcr",		"A",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RA), DNA,		DFPCR, DNA, DNA)
! 
! #define FCMOVEQ_IMPL							\
!   {									\
!     if ((FPR_Q(RA) << 1) == ULL(0))					\
!       SET_FPR(RC, FPR(RB));						\
!   }
! DEFINST(FCMOVEQ,		0x2a,
! 	"fcmoveq",		"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define FCMOVNE_IMPL							\
!   {									\
!     if ((FPR_Q(RA) << 1) != ULL(0))					\
!       SET_FPR(RC, FPR(RB));						\
!   }
! DEFINST(FCMOVNE,		0x2b,
! 	"fcmovne",		"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define FCMOVLT_IMPL							\
!   {									\
!     if (((FPR_Q(RA) << 1) != ULL(0)) && (FPR_Q(RA) >> 63))		\
!       SET_FPR(RC, FPR(RB));						\
!   }
! DEFINST(FCMOVLT,		0x2c,
! 	"fcmovlt",		"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define FCMOVGE_IMPL							\
!   {									\
!     if (((FPR_Q(RA) << 1) == ULL(0)) || (FPR_Q(RA) >> 63 == ULL(0)))	\
!       SET_FPR(RC, FPR(RB));						\
!   }
! DEFINST(FCMOVGE,		0x2d,
! 	"fcmovge",		"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define FCMOVLE_IMPL							\
!   {									\
!     if (((FPR_Q(RA) << 1) == ULL(0)) || (FPR_Q(RA) >> 63))		\
!       SET_FPR(RC, FPR(RB));						\
!   }
! DEFINST(FCMOVLE,		0x2e,
! 	"fcmovle",		"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! #define FCMOVGT_IMPL							\
!   {									\
!     if (((FPR_Q(RA) << 1) != ULL(0)) && (FPR_Q(RA) >> 63 == ULL(0)))	\
!       SET_FPR(RC, FPR(RB));						\
!   }
! DEFINST(FCMOVGT,		0x2f,
! 	"fcmovgt",		"A,B,C",
! 	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RA), DFPR(RB), DNA)
! 
! /* FIXME: CVTQLV and CVTQLSV should map to here... */
! #define CVTQL_IMPL							\
    {									\
!     sqword_t longhold = FPR_Q(RB);					\
  									\
!     SET_FPR_Q(RC, (((longhold >> 32) & LL(0xc000000000000000))		\
! 		   | (longhold & LL(0x3fffffff)) << 29));		\
    }
! DEFINST(CVTQL,			0x30,
! 	"cvtql",		"B,C",
  	FloatADD,		F_FCOMP,
! 	DFPR(RC), DNA,		DFPR(RB), DNA, DNA)
! 
! 
! CONNECT(MISC)
! 
! /* Note: some DEFINSTs below have different MSK values because the
!    mask & shifts in the MISC link above have changed */
! 
! #define TRAPB_IMPL							\
!   {									\
!     /* FIXME: nada... */						\
!   }
! DEFINST(TRAPB,			0x00,
! 	"trapb",		"",
! 	NA,			F_TRAP,
! 	DNA, DNA,		DNA, DNA, DNA)
! 
! /* added 02/27/99, plakal@cecil, from Alpha Arch Handbook (Rev.4, EV6) */
! #define EXCB_IMPL							\
!   {									\
!     /* FIXME: nada... */						\
!   }
! DEFINST(EXCB,			0x04,
! 	"excb",		        "",
! 	NA,			F_TRAP,
! 	DNA, DNA,		DNA, DNA, DNA)
! 
! #define MB_IMPL								\
!   {									\
!     /* FIXME: not supported... */					\
!   }
! DEFINST(MB,			0x40, /* -- Changed from 0x04 */
! 	"mb",			"",
! 	NA,			F_TRAP,
! 	DNA, DNA,		DNA, DNA, DNA)
! 
! /* added 02/27/99, plakal@cecil, from Alpha Arch Handbook (Rev.4, EV6) */
!  
! #define WMB_IMPL							\
!   {									\
!     /* FIXME: not supported... */					\
!   }
! DEFINST(WMB,			0x44,
! 	"wmb",			"",
! 	NA,			F_TRAP,
! 	DNA, DNA,		DNA, DNA, DNA)
! 
! /* changed from unimplemented to unsupported */
! #define FETCH_IMPL							\
!   {									\
!     /* FIXME: not supported ... */					\
!   }
! DEFINST(FETCH,			0x80, /* -- Changed from 0x08 */
! 	"fetch",	        "0(b)",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
! 
! /* changed from unimplemented to unsupported */
! #define FETCH_M_IMPL							\
!   {									\
!     /* FIXME: not supported ... */					\
!   }
! DEFINST(FETCH_M,		0xa0, /* -- Changed from 0x0a */
! 	"fetch_m",	        "0(b)",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
! 
! /* changed from unimplemented */
! #define RPCC_IMPL							\
!   {									\
!     /* FIXME: dumb implementation */					\
!     SET_GPR(RA, ULL(0));                                                \
!   }
! DEFINST(RPCC,			0xc0, /* -- Changed from 0x0c */
! 	"rpcc",          	"a",
! 	NA,			NA,
! 	DGPR(RA), DNA,		DNA, DNA, DNA)
! 
! /* added 02/27/99, plakal@cecil, from Alpha Arch Handbook (Rev.4, EV6) */
! #define _RC_IMPL						        \
!   {									\
!     /* FIXME: not supported */						\
!   }
! DEFINST(_RC,			0xe0,  
! 	"rc",		        "a",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
  
! /* added 02/27/99, plakal@cecil, from Alpha Arch Handbook (Rev.4, EV6) */
! #define ECB_IMPL							\
    {									\
!     /* FIXME: nada... */						\
!   }
! DEFINST(ECB,			0xe8,
! 	"ecb",		        "(b)",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
! 
! /* changed from unimplemented to unsupported */
! #define _RS_IMPL							\
!   {									\
!     /* FIXME: not supported */						\
    }
! DEFINST(_RS,			0xf0,  /* -- Changed from 0x0f */
! 	"rs",		        "a",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
  
! /* added 02/27/99, plakal@cecil, from Alpha Arch Handbook (Rev.4, EV6) */
! #define WH64_IMPL							\
    {									\
!     /* FIXME: nada... */						\
    }
! DEFINST(WH64,			0xf8,
! 	"wh64",		        "(b)",
! 	NA,			NA,
! 	DNA, DNA,		DNA, DNA, DNA)
  
! 
! CONNECT(JMPJSR)
! 
! #define JMP_IMPL							\
    {									\
!     SET_TPC(GPR(RB) & ~3);						\
!     SET_NPC(GPR(RB) & ~3);						\
!     SET_GPR(RA, CPC + 4);						\
    }
! DEFINST(JMP,			0x00,
! 	"jmp",			"a,(b)",
! 	IntALU,			F_CTRL|F_UNCOND|F_INDIRJMP,
! 	DGPR(RA), DNA,		DGPR(RB), DNA, DNA)
  
! #define JSR_IMPL							\
    {									\
!     SET_TPC(GPR(RB) & ~3);						\
!     SET_NPC(GPR(RB) & ~3);						\
!     SET_GPR(RA, CPC + 4);						\
    }
! DEFINST(JSR,			0x01,
! 	"jsr",			"a,(b)",
! 	IntALU,			F_CTRL|F_UNCOND|F_INDIRJMP,
! 	DGPR(RA), DNA,		DGPR(RB), DNA, DNA)
  
! #define RETN_IMPL							\
    {									\
!     SET_TPC(GPR(RB) & ~3);						\
!     SET_NPC(GPR(RB) & ~3);						\
!     SET_GPR(RA, CPC + 4);						\
    }
! DEFINST(RETN,			0x02,
! 	"ret",			"a,(b)",
! 	IntALU,			F_CTRL|F_UNCOND|F_INDIRJMP,
! 	DGPR(RA), DNA,		DGPR(RB), DNA, DNA)
  
! #define JSR_COROUTINE_IMPL						\
    {									\
!     SET_TPC(GPR(RB) & ~3);						\
!     SET_NPC(GPR(RB) & ~3);						\
!     SET_GPR(RA, CPC + 4);						\
    }
! DEFINST(JSR_COROUTINE,		0x03,
! 	"jsr_coroutine",	"a,(b)",
! 	IntALU,			F_CTRL|F_UNCOND|F_INDIRJMP,
! 	DGPR(RA), DNA,		DGPR(RB), DNA, DNA)
! 
! 
! /* changed from EXTS to FPTI to include more extensions (FIX,CIX,MVI) */
! CONNECT(FPTI)
  
! /* EV56 BWX extension... */
! DEFLINK(SEXTB_LINK, 0x00, "sextb_link", 12, 1)
! 
! /* EV56 BWX extension... */
! DEFLINK(SEXTW_LINK, 0x01, "sextw_link", 12, 1)
! 
! /* added 02/27/99, plakal@cecil, from Alpha Arch Handbook (Rev.4, EV6) */
!  
! /* CIX extensions */
! 
! /* FIXME: could write a faster version of 1-bit-counting:
!    i.e., count = 0; while (n) { n = n & (n-1); count++; } */
! #define CTPOP_IMPL							\
    {									\
!     int _temp, _i;							\
!     qword_t _qwordhold = GPR(RB);				        \
! 									\
!     _temp = 0;								\
!     for (_i = 0; _i <= 63; _i++)					\
!       if (_qwordhold & (ULL(1) << _i))					\
! 	_temp++;							\
  									\
!     SET_GPR(RC, (qword_t)_temp);					\
    }
! DEFINST(CTPOP,			0x30,  
! 	"ctpop",		"b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RB), DNA, DNA)
  
! /* MVI extensions */
! #define PERR_IMPL							\
    {									\
!     int _i;								\
!     qword_t _sum_diffs, _qwordhold_a, _qwordhold_b;			\
! 									\
!     _qwordhold_a = GPR(RA);						\
!     _qwordhold_b = GPR(RB);						\
!     _sum_diffs = 0;							\
! 									\
!     for (_i = 0; _i <= 7; _i++)						\
!     {									\
!       byte_t _bytehold_a, _bytehold_b;					\
! 									\
!       _bytehold_a = (_qwordhold_a >> (_i*8)) & 0xff;			\
!       _bytehold_b = (_qwordhold_b >> (_i*8)) & 0xff;			\
!       if (_bytehold_a >= _bytehold_b)					\
! 	_sum_diffs += (_bytehold_a - _bytehold_b);			\
!       else								\
! 	_sum_diffs += (_bytehold_b - _bytehold_a);			\
!     }									\
  									\
!     SET_GPR(RC, _sum_diffs);						\
    }
! DEFINST(PERR,			0x31,
! 	"perr",			"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
  
! /* CIX extensions */
! #define CTLZ_IMPL							\
    {									\
!     int _temp, _i;							\
!     qword_t _qwordhold = GPR(RB);					\
! 									\
!     _temp = 0;								\
!     for (_i = 63; _i >= 0; _i--)					\
!     {									\
!       if (_qwordhold & (ULL(1) << _i))					\
! 	break;								\
  									\
!       _temp++;								\
!     }									\
! 									\
!     SET_GPR(RC, (qword_t)_temp);					\
    }
! DEFINST(CTLZ,			0x32,  
! 	"ctlz",		        "b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RB), DNA, DNA)
  
! #define CTTZ_IMPL							\
    {									\
!     int _temp, _i;							\
!     qword_t _qwordhold = GPR(RB);					\
! 									\
!     _temp = 0;								\
!     for (_i = 0; _i <= 63; _i++)					\
!     {									\
!       if (_qwordhold & (ULL(1) << _i))					\
! 	break;								\
  									\
!       _temp++;								\
!     }									\
! 									\
!     SET_GPR(RC, (qword_t)_temp);					\
    }
! DEFINST(CTTZ,			0x33,  
! 	"cttz",		        "b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RB), DNA, DNA)
! 
  
! /* MVI extensions */
! #define UNPKBW_IMPL							\
    {									\
!     qword_t _temp, _qwordhold;						\
  									\
!     _temp = 0;								\
!     _qwordhold = GPR(RB);						\
! 									\
!     _temp |= (_qwordhold & 0xff);					\
!     _temp |= (((_qwordhold >> 8) & 0xff) << 16);			\
!     _temp |= (((_qwordhold >> 16) & 0xff) << 32);			\
!     _temp |= (((_qwordhold >> 24) & 0xff) << 48);			\
! 									\
!     SET_GPR(RC, _temp);							\
    }
! DEFINST(UNPKBW,			0x34,
! 	"unpkbw",		"b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RB), DNA, DNA)
  
! #define UNPKBL_IMPL							\
    {									\
!     qword_t _temp, _qwordhold;						\
  									\
!     _temp = 0;								\
!     _qwordhold = GPR(RB);						\
! 									\
!     _temp |= (_qwordhold & 0xff);					\
!     _temp |= (((_qwordhold >> 8) & 0xff) << 32);			\
! 									\
!     SET_GPR(RC, _temp);							\
    }
! DEFINST(UNPKBL,			0x35,
! 	"unpkbl",		"b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RB), DNA, DNA)
  
! #define PKWB_IMPL							\
    {									\
!     qword_t _temp, _qwordhold;						\
  									\
!     _temp = 0;								\
!     _qwordhold = GPR(RB);						\
! 									\
!     _temp |= (_qwordhold & 0xff);					\
!     _temp |= (((_qwordhold >> 16) & 0xff) << 8);			\
!     _temp |= (((_qwordhold >> 32) & 0xff) << 16);			\
!     _temp |= (((_qwordhold >> 48) & 0xff) << 24);			\
! 									\
!     SET_GPR(RC, _temp);							\
    }
! DEFINST(PKWB,			0x36,
! 	"pkwb",			"b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RB), DNA, DNA)
  
! #define PKLB_IMPL							\
    {									\
!     qword_t _temp, _qwordhold;						\
! 									\
!     _temp = 0;								\
!     _qwordhold = GPR(RB);						\
  									\
!     _temp |= (_qwordhold & 0xff);					\
!     _temp |= (((_qwordhold >> 32) & 0xff) << 8);			\
! 									\
!     SET_GPR(RC, _temp);							\
    }
! DEFINST(PKLB,			0x37,
! 	"pklb",			"b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RB), DNA, DNA)
! 
! /* following MVI entries were script-generated :) */
! 
! DEFLINK(MINSB8_LINK, 0x38, "minsb8_link", 12, 1)
! 
! DEFLINK(MINSW4_LINK, 0x39, "minsw4_link", 12, 1)
! 
! DEFLINK(MINUB8_LINK, 0x3a, "minub8_link", 12, 1)
! 
! DEFLINK(MINUW4_LINK, 0x3b, "minuw4_link", 12, 1)
! 
! DEFLINK(MAXUB8_LINK, 0x3c, "maxub8_link", 12, 1)
  
- DEFLINK(MAXUW4_LINK, 0x3d, "maxuw4_link", 12, 1)
  
! DEFLINK(MAXSB8_LINK, 0x3e, "maxsb8_link", 12, 1)
! 
! DEFLINK(MAXSW4_LINK, 0x3f, "maxsw4_link", 12, 1)
  
! /* FIX extensions */
! #define FTOIT_IMPL							\
    {									\
!     SET_GPR(RC, FPR_Q(RA));                                             \
    }
! DEFINST(FTOIT,			0x70,
! 	"ftoit",	        "A,c",
! 	FloatCVT,	        F_FCOMP,  /* FIXME: are these flags correct? */
! 	DGPR(RC), DNA,		DFPR(RA), DNA, DNA)
  
! #define FTOIS_IMPL							\
    {									\
!     sqword_t _longhold;							\
!     sword_t _inthold;							\
! 									\
!     _longhold = FPR_Q(RA);						\
!     _inthold = (((_longhold >> 32) & ULL(0xc0000000))			\
! 		| ((_longhold >> 29) & ULL(0x3fffffff)));		\
! 									\
!     SET_GPR(RC, (SEXT32(_longhold >> 63) << 32) | _inthold);		\
    }
- DEFINST(FTOIS,			0x78,
- 	"ftois",	        "A,c",
- 	FloatCVT,	        F_FCOMP,  /* FIXME: are these flags correct? */
- 	DGPR(RC), DNA,		DFPR(RA), DNA, DNA)
- 
- 
- /* MVI extensions (contd) */
- CONNECT(MINSB8_LINK)
- 
- #define MINSB8_IMPL							\
- {									\
-   int _i;								\
-   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
- 									\
-   _qwordhold_a = GPR(RA);						\
-   _qwordhold_b = GPR(RB);						\
-   _qwordhold_c = 0;							\
- 									\
-   for (_i = 0; _i <= 7; _i++)						\
-   {									\
-     sbyte_t _bytehold_a, _bytehold_b, _bytehold_c;			\
- 									\
-     _bytehold_a = (_qwordhold_a >> (_i * 8)) & 0xff;			\
-     _bytehold_b = (_qwordhold_b >> (_i * 8)) & 0xff;			\
-     _bytehold_c = MIN(_bytehold_a, _bytehold_b);			\
- 									\
-     _qwordhold_c |= (((qword_t)(byte_t)_bytehold_c & 0xff) << (_i*8));	\
-   }									\
- 									\
-   SET_GPR(RC, _qwordhold_c);						\
- }
- DEFINST(MINSB8,			0x00,
- 	"minsb8",		"a,b,c",
- 	IntALU,			F_ICOMP,
- 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
- 
- #define MINSB8I_IMPL							\
- {									\
-   int _i;								\
-   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
- 									\
-   _qwordhold_a = GPR(RA);						\
-   _qwordhold_b = IMM;							\
-   _qwordhold_c = 0;							\
- 									\
-   for (_i = 0; _i <= 7; _i++)						\
-   {									\
-     sbyte_t _bytehold_a, _bytehold_b, _bytehold_c;			\
- 									\
-     _bytehold_a = (_qwordhold_a >> (_i * 8)) & 0xff;			\
-     _bytehold_b = (_qwordhold_b >> (_i * 8)) & 0xff;			\
-     _bytehold_c = MIN(_bytehold_a, _bytehold_b);			\
- 									\
-     _qwordhold_c |= (((qword_t)(byte_t)_bytehold_c & 0xff) << (_i*8));	\
-   }									\
- 									\
-   SET_GPR(RC, _qwordhold_c);						\
- }
- DEFINST(MINSB8I,		0x01,
- 	"minsb8",		"a,i,c",
- 	IntALU,			F_ICOMP|F_IMM,
- 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
- 
- 
- CONNECT(MINSW4_LINK)
- 
- #define MINSW4_IMPL							\
- {									\
-   int _i;								\
-   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
- 									\
-   _qwordhold_a = GPR(RA);						\
-   _qwordhold_b = GPR(RB);						\
-   _qwordhold_c = 0;							\
- 									\
-   for (_i = 0; _i <= 3; _i++)						\
-   {									\
-     shalf_t _halfhold_a, _halfhold_b, _halfhold_c;			\
- 									\
-     _halfhold_a = (_qwordhold_a >> (_i * 16)) & 0xffff;			\
-     _halfhold_b = (_qwordhold_b >> (_i * 16)) & 0xffff;			\
-     _halfhold_c = MIN(_halfhold_a, _halfhold_b);			\
- 									\
-     _qwordhold_c |= (((qword_t)(half_t)_halfhold_c & 0xffff) << (_i*16));\
-   }									\
- 									\
-   SET_GPR(RC, _qwordhold_c);						\
- }
- DEFINST(MINSW4,			0x00,
- 	"minsw4",		"a,b,c",
- 	IntALU,			F_ICOMP,
- 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
- 
- #define MINSW4I_IMPL							\
- {									\
-   int _i;								\
-   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
- 									\
-   _qwordhold_a = GPR(RA);						\
-   _qwordhold_b = IMM;							\
-   _qwordhold_c = 0;							\
- 									\
-   for (_i = 0; _i <= 3; _i++)						\
-   {									\
-     shalf_t _halfhold_a, _halfhold_b, _halfhold_c;			\
- 									\
-     _halfhold_a = (_qwordhold_a >> (_i * 16)) & 0xffff;			\
-     _halfhold_b = (_qwordhold_b >> (_i * 16)) & 0xffff;			\
-     _halfhold_c = MIN(_halfhold_a, _halfhold_b);			\
- 									\
-     _qwordhold_c |= (((qword_t)(half_t)_halfhold_c & 0xffff) << (_i*16));\
-   }									\
- 									\
-   SET_GPR(RC, _qwordhold_c);						\
- }
- DEFINST(MINSW4I,		0x01,
- 	"minsw4",		"a,i,c",
- 	IntALU,			F_ICOMP|F_IMM,
- 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
- 
- 
- CONNECT(MINUB8_LINK)
- 
- #define MINUB8_IMPL							\
- {									\
-   int _i;								\
-   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
- 									\
-   _qwordhold_a = GPR(RA);						\
-   _qwordhold_b = GPR(RB);						\
-   _qwordhold_c = 0;							\
- 									\
-   for (_i = 0; _i <= 7; _i++)						\
-   {									\
-     byte_t _bytehold_a, _bytehold_b, _bytehold_c;			\
- 									\
-     _bytehold_a = (_qwordhold_a >> (_i * 8)) & 0xff;			\
-     _bytehold_b = (_qwordhold_b >> (_i * 8)) & 0xff;			\
-     _bytehold_c = MIN(_bytehold_a, _bytehold_b);			\
- 									\
-     _qwordhold_c |= (((qword_t)(byte_t)_bytehold_c & 0xff) << (_i*8));	\
-   }									\
- 									\
-   SET_GPR(RC, _qwordhold_c);						\
- }
- DEFINST(MINUB8,			0x00,
- 	"minub8",		"a,b,c",
- 	IntALU,			F_ICOMP,
- 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
- 
- #define MINUB8I_IMPL							\
- {									\
-   int _i;								\
-   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
- 									\
-   _qwordhold_a = GPR(RA);						\
-   _qwordhold_b = IMM;							\
-   _qwordhold_c = 0;							\
- 									\
-   for (_i = 0; _i <= 7; _i++)						\
-   {									\
-     byte_t _bytehold_a, _bytehold_b, _bytehold_c;			\
- 									\
-     _bytehold_a = (_qwordhold_a >> (_i * 8)) & 0xff;			\
-     _bytehold_b = (_qwordhold_b >> (_i * 8)) & 0xff;			\
-     _bytehold_c = MIN(_bytehold_a, _bytehold_b);			\
- 									\
-     _qwordhold_c |= (((qword_t)(byte_t)_bytehold_c & 0xff) << (_i*8));	\
-   }									\
- 									\
-   SET_GPR(RC, _qwordhold_c);						\
- }
- DEFINST(MINUB8I,		0x01,
- 	"minub8",		"a,i,c",
- 	IntALU,			F_ICOMP|F_IMM,
- 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
- 
- 
- CONNECT(MINUW4_LINK)
- 
- #define MINUW4_IMPL							\
- {									\
-   int _i;								\
-   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
- 									\
-   _qwordhold_a = GPR(RA);						\
-   _qwordhold_b = GPR(RB);						\
-   _qwordhold_c = 0;							\
- 									\
-   for (_i = 0; _i <= 3; _i++)						\
-   {									\
-     half_t _halfhold_a, _halfhold_b, _halfhold_c;			\
- 									\
-     _halfhold_a = (_qwordhold_a >> (_i * 16)) & 0xffff;			\
-     _halfhold_b = (_qwordhold_b >> (_i * 16)) & 0xffff;			\
-     _halfhold_c = MIN(_halfhold_a, _halfhold_b);			\
- 									\
-     _qwordhold_c |= (((qword_t)(half_t)_halfhold_c & 0xffff) << (_i*16));\
-   }									\
- 									\
-   SET_GPR(RC, _qwordhold_c);						\
- }
- DEFINST(MINUW4,			0x00,
- 	"minuw4",		"a,b,c",
- 	IntALU,			F_ICOMP,
- 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
- 
- #define MINUW4I_IMPL							\
- {									\
-   int _i;								\
-   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
- 									\
-   _qwordhold_a = GPR(RA);						\
-   _qwordhold_b = IMM;							\
-   _qwordhold_c = 0;							\
- 									\
-   for (_i = 0; _i <= 3; _i++)						\
-   {									\
-     half_t _halfhold_a, _halfhold_b, _halfhold_c;			\
- 									\
-     _halfhold_a = (_qwordhold_a >> (_i * 16)) & 0xffff;			\
-     _halfhold_b = (_qwordhold_b >> (_i * 16)) & 0xffff;			\
-     _halfhold_c = MIN(_halfhold_a, _halfhold_b);			\
- 									\
-     _qwordhold_c |= (((qword_t)(half_t)_halfhold_c & 0xffff) << (_i*16));\
-   }									\
- 									\
-   SET_GPR(RC, _qwordhold_c);						\
- }
- DEFINST(MINUW4I,		0x01,
- 	"minuw4",		"a,i,c",
- 	IntALU,			F_ICOMP|F_IMM,
- 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
- 
- 
- CONNECT(MAXUB8_LINK)
- 
- #define MAXUB8_IMPL							\
- {									\
-   int _i;								\
-   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
- 									\
-   _qwordhold_a = GPR(RA);						\
-   _qwordhold_b = GPR(RB);						\
-   _qwordhold_c = 0;							\
- 									\
-   for (_i = 0; _i <= 7; _i++)						\
-   {									\
-     byte_t _bytehold_a, _bytehold_b, _bytehold_c;			\
- 									\
-     _bytehold_a = (_qwordhold_a >> (_i * 8)) & 0xff;			\
-     _bytehold_b = (_qwordhold_b >> (_i * 8)) & 0xff;			\
-     _bytehold_c = MAX(_bytehold_a, _bytehold_b);			\
- 									\
-     _qwordhold_c |= (((qword_t)(byte_t)_bytehold_c & 0xff) << (_i*8));	\
-   }									\
- 									\
-   SET_GPR(RC, _qwordhold_c);						\
- }
- DEFINST(MAXUB8,			0x00,
- 	"maxub8",		"a,b,c",
- 	IntALU,			F_ICOMP,
- 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
- 
- #define MAXUB8I_IMPL							\
- {									\
-   int _i;								\
-   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
- 									\
-   _qwordhold_a = GPR(RA);						\
-   _qwordhold_b = IMM;							\
-   _qwordhold_c = 0;							\
- 									\
-   for (_i = 0; _i <= 7; _i++)						\
-   {									\
-     byte_t _bytehold_a, _bytehold_b, _bytehold_c;			\
- 									\
-     _bytehold_a = (_qwordhold_a >> (_i * 8)) & 0xff;			\
-     _bytehold_b = (_qwordhold_b >> (_i * 8)) & 0xff;			\
-     _bytehold_c = MAX(_bytehold_a, _bytehold_b);			\
- 									\
-     _qwordhold_c |= (((qword_t)(byte_t)_bytehold_c & 0xff) << (_i*8));	\
-   }									\
- 									\
-   SET_GPR(RC, _qwordhold_c);						\
- }
- DEFINST(MAXUB8I,		0x01,
- 	"maxub8",		"a,i,c",
- 	IntALU,			F_ICOMP|F_IMM,
- 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
  
  
! CONNECT(MAXUW4_LINK)
! 
! #define MAXUW4_IMPL							\
! {									\
!   int _i;								\
!   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
! 									\
!   _qwordhold_a = GPR(RA);						\
!   _qwordhold_b = GPR(RB);						\
!   _qwordhold_c = 0;							\
! 									\
!   for (_i = 0; _i <= 3; _i++)						\
!   {									\
!     half_t _halfhold_a, _halfhold_b, _halfhold_c;			\
! 									\
!     _halfhold_a = (_qwordhold_a >> (_i * 16)) & 0xffff;			\
!     _halfhold_b = (_qwordhold_b >> (_i * 16)) & 0xffff;			\
!     _halfhold_c = MAX(_halfhold_a, _halfhold_b);			\
! 									\
!     _qwordhold_c |= (((qword_t)(half_t)_halfhold_c & 0xffff) << (_i*16));\
!   }									\
! 									\
!   SET_GPR(RC, _qwordhold_c);						\
! }
! DEFINST(MAXUW4,			0x00,
! 	"maxuw4",		"a,b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define MAXUW4I_IMPL							\
! {									\
!   int _i;								\
!   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
! 									\
!   _qwordhold_a = GPR(RA);						\
!   _qwordhold_b = IMM;							\
!   _qwordhold_c = 0;							\
! 									\
!   for (_i = 0; _i <= 3; _i++)						\
!   {									\
!     half_t _halfhold_a, _halfhold_b, _halfhold_c;			\
! 									\
!     _halfhold_a = (_qwordhold_a >> (_i * 16)) & 0xffff;			\
!     _halfhold_b = (_qwordhold_b >> (_i * 16)) & 0xffff;			\
!     _halfhold_c = MAX(_halfhold_a, _halfhold_b);			\
! 									\
!     _qwordhold_c |= (((qword_t)(half_t)_halfhold_c & 0xffff) << (_i*16));\
!   }									\
! 									\
!   SET_GPR(RC, _qwordhold_c);						\
! }
! DEFINST(MAXUW4I,		0x01,
! 	"maxuw4",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(MAXSB8_LINK)
! 
! #define MAXSB8_IMPL							\
! {									\
!   int _i;								\
!   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
! 									\
!   _qwordhold_a = GPR(RA);						\
!   _qwordhold_b = GPR(RB);						\
!   _qwordhold_c = 0;							\
! 									\
!   for (_i = 0; _i <= 7; _i++)						\
    {									\
!     sbyte_t _bytehold_a, _bytehold_b, _bytehold_c;			\
! 									\
!     _bytehold_a = (_qwordhold_a >> (_i * 8)) & 0xff;			\
!     _bytehold_b = (_qwordhold_b >> (_i * 8)) & 0xff;			\
!     _bytehold_c = MAX(_bytehold_a, _bytehold_b);			\
! 									\
!     _qwordhold_c |= (((qword_t)(byte_t)_bytehold_c & 0xff) << (_i*8));	\
!   }									\
! 									\
!   SET_GPR(RC, _qwordhold_c);						\
! }
! DEFINST(MAXSB8,			0x00,
! 	"maxsb8",		"a,b,c",
  	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
  
! #define MAXSB8I_IMPL							\
! {									\
!   int _i;								\
!   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
! 									\
!   _qwordhold_a = GPR(RA);						\
!   _qwordhold_b = IMM;							\
!   _qwordhold_c = 0;							\
! 									\
!   for (_i = 0; _i <= 7; _i++)						\
    {									\
!     sbyte_t _bytehold_a, _bytehold_b, _bytehold_c;			\
! 									\
!     _bytehold_a = (_qwordhold_a >> (_i * 8)) & 0xff;			\
!     _bytehold_b = (_qwordhold_b >> (_i * 8)) & 0xff;			\
!     _bytehold_c = MAX(_bytehold_a, _bytehold_b);			\
! 									\
!     _qwordhold_c |= (((qword_t)(byte_t)_bytehold_c & 0xff) << (_i*8));	\
!   }									\
! 									\
!   SET_GPR(RC, _qwordhold_c);						\
! }
! DEFINST(MAXSB8I,		0x01,
! 	"maxsb8",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
! 
! CONNECT(MAXSW4_LINK)
  
! #define MAXSW4_IMPL							\
! {									\
!   int _i;								\
!   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
! 									\
!   _qwordhold_a = GPR(RA);						\
!   _qwordhold_b = GPR(RB);						\
!   _qwordhold_c = 0;							\
! 									\
!   for (_i = 0; _i <= 3; _i++)						\
    {									\
!     shalf_t _halfhold_a, _halfhold_b, _halfhold_c;			\
! 									\
!     _halfhold_a = (_qwordhold_a >> (_i * 16)) & 0xffff;			\
!     _halfhold_b = (_qwordhold_b >> (_i * 16)) & 0xffff;			\
!     _halfhold_c = MAX(_halfhold_a, _halfhold_b);			\
! 									\
!     _qwordhold_c |= (((qword_t)(half_t)_halfhold_c & 0xffff) << (_i*16));\
!   }									\
  									\
!   SET_GPR(RC, _qwordhold_c);						\
! }
! DEFINST(MAXSW4,			0x00,
! 	"maxsw4",		"a,b,c",
  	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RA), DGPR(RB), DNA)
! 
! #define MAXSW4I_IMPL							\
! {									\
!   int _i;								\
!   qword_t _qwordhold_a, _qwordhold_b, _qwordhold_c;			\
! 									\
!   _qwordhold_a = GPR(RA);						\
!   _qwordhold_b = IMM;							\
!   _qwordhold_c = 0;							\
! 									\
!   for (_i = 0; _i <= 3; _i++)						\
!   {									\
!     shalf_t _halfhold_a, _halfhold_b, _halfhold_c;			\
! 									\
!     _halfhold_a = (_qwordhold_a >> (_i * 16)) & 0xffff;			\
!     _halfhold_b = (_qwordhold_b >> (_i * 16)) & 0xffff;			\
!     _halfhold_c = MAX(_halfhold_a, _halfhold_b);			\
! 									\
!     _qwordhold_c |= (((qword_t)(half_t)_halfhold_c & 0xffff) << (_i*16));\
!   }									\
! 									\
!   SET_GPR(RC, _qwordhold_c);						\
! }
! DEFINST(MAXSW4I,		0x01,
! 	"maxsw4",		"a,i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DGPR(RA), DNA, DNA)
! 
  
! /* EV56 BWX extension... */
! CONNECT(SEXTB_LINK)
! 
! /* EV56 BWX extension... */
! #define SEXTB_IMPL							\
    {									\
!     SET_GPR(RC, (qword_t)(sqword_t)(sbyte_t)(GPR(RB) & 0xff));		\
    }
! DEFINST(SEXTB,			0x00,
! 	"sextb",		"b,c",
! 	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RB), DNA, DNA)
  
! /* EV56 BWX extension... */
! #define SEXTBI_IMPL							\
    {									\
!     SET_GPR(RC, (qword_t)(sqword_t)(sbyte_t)(IMM & 0xff));		\
    }
! DEFINST(SEXTBI,			0x01,
! 	"sextb",		"i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DNA, DNA, DNA)
! 
! 
! /* EV56 BWX extension... */
! CONNECT(SEXTW_LINK)
  
! /* EV56 BWX extension... */
! #define SEXTW_IMPL							\
    {									\
!     SET_GPR(RC, (qword_t)(sqword_t)(shalf_t)(GPR(RB) & 0xffff));	\
    }
! DEFINST(SEXTW,			0x00,
! 	"sextw",		"b,c",
  	IntALU,			F_ICOMP,
! 	DGPR(RC), DNA,		DGPR(RB), DNA, DNA)
  
! /* EV56 BWX extension... */
! #define SEXTWI_IMPL							\
    {									\
!     SET_GPR(RC, (qword_t)(sqword_t)(shalf_t)(IMM & 0xffff));		\
    }
! DEFINST(SEXTWI,			0x01,
! 	"sextw",		"i,c",
! 	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RC), DNA,		DNA, DNA, DNA)
! 
  
  
  /* clean up all definitions... */
! #undef LDA_IMPL
! #undef LDAH_IMPL
! #undef LDBU_IMPL
! #undef LDQ_U_IMPL
! #undef LDWU_IMPL
! #undef STW_IMPL
! #undef STB_IMPL
! #undef STQ_U_IMPL
! #undef FLTV_IMPL
! #undef LDF_IMPL
! #undef LDG_IMPL
! #undef LDS_IMPL
! #undef LDT_IMPL
! #undef STF_IMPL
! #undef STG_IMPL
! #undef STS_IMPL
! #undef STT_IMPL
! #undef LDL_IMPL
! #undef LDQ_IMPL
! #undef LDL_L_IMPL
! #undef LDQ_L_IMPL
! #undef STL_IMPL
! #undef STQ_IMPL
! #undef STL_C_IMPL
! #undef STQ_C_IMPL
! #undef BR_IMPL
! #undef FBEQ_IMPL
! #undef FBLT_IMPL
! #undef FBLE_IMPL
! #undef BSR_IMPL
! #undef FBNE_IMPL
! #undef FBGE_IMPL
! #undef FBGT_IMPL
! #undef BLBC_IMPL
  #undef BEQ_IMPL
- #undef BLT_IMPL
- #undef BLE_IMPL
- #undef BLBS_IMPL
  #undef BNE_IMPL
! #undef BGE_IMPL
! #undef BGT_IMPL
! #undef PAL_CALLSYS_IMPL
! #undef PAL_RDUNIQ_IMPL
! #undef PAL_WRUNIQ_IMPL
! #undef ADDL_IMPL
! #undef ADDLI_IMPL
! #undef S4ADDL_IMPL
! #undef S4ADDLI_IMPL
! #undef SUBL_IMPL
! #undef SUBLI_IMPL
! #undef S4SUBL_IMPL
! #undef S4SUBLI_IMPL
! #undef CMPBGE_IMPL
! #undef CMPBGEI_IMPL
! #undef S8ADDL_IMPL
! #undef S8ADDLI_IMPL
! #undef S8SUBL_IMPL
! #undef S8SUBLI_IMPL
! #undef CMPULT_IMPL
! #undef CMPULTI_IMPL
! #undef ADDQ_IMPL
! #undef ADDQI_IMPL
! #undef S4ADDQ_IMPL
! #undef S4ADDQI_IMPL
! #undef SUBQ_IMPL
! #undef SUBQI_IMPL
! #undef S4SUBQ_IMPL
! #undef S4SUBQI_IMPL
! #undef CMPEQ_IMPL
! #undef CMPEQI_IMPL
! #undef S8ADDQ_IMPL
! #undef S8ADDQI_IMPL
! #undef S8SUBQ_IMPL
! #undef S8SUBQI_IMPL
! #undef CMPULE_IMPL
! #undef CMPULEI_IMPL
! #undef ADDLV_IMPL
! #undef ADDLVI_IMPL
! #undef SUBLV_IMPL
! #undef SUBLVI_IMPL
! #undef CMPLT_IMPL
! #undef CMPLTI_IMPL
! #undef ADDQV_IMPL
! #undef ADDQVI_IMPL
! #undef SUBQV_IMPL
! #undef SUBQVI_IMPL
! #undef CMPLE_IMPL
! #undef CMPLEI_IMPL
! #undef AND_IMPL
  #undef ANDI_IMPL
! #undef BIC_IMPL
! #undef BICI_IMPL
! #undef CMOVLBS_IMPL
! #undef CMOVLBSI_IMPL
! #undef CMOVLBC_IMPL
! #undef CMOVLBCI_IMPL
! #undef BIS_IMPL
! #undef BISI_IMPL
! #undef CMOVEQ_IMPL
! #undef CMOVEQI_IMPL
! #undef CMOVNE_IMPL
! #undef CMOVNEI_IMPL
! #undef ORNOT_IMPL
! #undef ORNOTI_IMPL
  #undef XOR_IMPL
  #undef XORI_IMPL
! #undef CMOVLT_IMPL
! #undef CMOVLTI_IMPL
! #undef CMOVGE_IMPL
! #undef CMOVGEI_IMPL
! #undef EQV_IMPL
! #undef EQVI_IMPL
! #undef AMASK_IMPL
! #undef AMASKI_IMPL
! #undef CMOVLE_IMPL
! #undef CMOVLEI_IMPL
! #undef CMOVGT_IMPL
! #undef CMOVGTI_IMPL
! #undef IMPLVER_IMPL
! #undef MSKBL_IMPL
! #undef MSKBLI_IMPL
! #undef EXTBL_IMPL
! #undef EXTBLI_IMPL
! #undef INSBL_IMPL
! #undef INSBLI_IMPL
! #undef MSKWL_IMPL
! #undef MSKWLI_IMPL
! #undef EXTWL_IMPL
! #undef EXTWLI_IMPL
! #undef INSWL_IMPL
! #undef INSWLI_IMPL
! #undef MSKLL_IMPL
! #undef MSKLLI_IMPL
! #undef EXTLL_IMPL
! #undef EXTLLI_IMPL
! #undef INSLL_IMPL
! #undef INSLLI_IMPL
! #undef ZAP_IMPL
! #undef ZAPI_IMPL
! #undef ZAPNOT_IMPL
! #undef ZAPNOTI_IMPL
! #undef MSKQL_IMPL
! #undef MSKQLI_IMPL
! #undef SRL_IMPL
! #undef SRLI_IMPL
! #undef EXTQL_IMPL
! #undef EXTQLI_IMPL
  #undef SLL_IMPL
! #undef SLLI_IMPL
! #undef INSQL_IMPL
! #undef INSQLI_IMPL
  #undef SRA_IMPL
! #undef SRAI_IMPL
! #undef MSKWH_IMPL
! #undef MSKWHI_IMPL
! #undef INSWH_IMPL
! #undef INSWHI_IMPL
! #undef EXTWH_IMPL
! #undef EXTWHI_IMPL
! #undef MSKLH_IMPL
! #undef MSKLHI_IMPL
! #undef INSLH_IMPL
! #undef INSLHI_IMPL
! #undef EXTLH_IMPL
! #undef EXTLHI_IMPL
! #undef MSKQH_IMPL
! #undef MSKQHI_IMPL
! #undef INSQH_IMPL
! #undef INSQHI_IMPL
! #undef EXTQH_IMPL
! #undef EXTQHI_IMPL
! #undef MULL_IMPL
! #undef MULLI_IMPL
! #undef MULQ_IMPL
! #undef MULQI_IMPL
! #undef UMULH_IMPL
! #undef UMULHI_IMPL
! #undef ITOFS_IMPL
! #undef SQRTF_IMPL
! #undef SQRTS_IMPL
! #undef ITOFF_IMPL
! #undef ITOFT_IMPL
! #undef SQRTG_IMPL
! #undef SQRTT_IMPL
! #undef ADDS_IMPL
! #undef SUBS_IMPL
! #undef MULS_IMPL
! #undef DIVS_IMPL
! #undef ADDT_IMPL
! #undef SUBT_IMPL
! #undef MULT_IMPL
! #undef DIVT_IMPL
! #undef CMPTUN_IMPL
! #undef CMPTEQ_IMPL
! #undef CMPTLT_IMPL
! #undef CMPTLE_IMPL
! #undef CVTTS_IMPL
! #undef CVTTQ_IMPL
! #undef CVTQS_IMPL
! #undef CVTQT_IMPL
! #undef CVTLQ_IMPL
! #undef CPYS_IMPL
! #undef CPYSN_IMPL
! #undef CPYSE_IMPL
! #undef MT_FPCR_IMPL
! #undef MF_FPCR_IMPL
! #undef FCMOVEQ_IMPL
! #undef FCMOVNE_IMPL
! #undef FCMOVLT_IMPL
! #undef FCMOVGE_IMPL
! #undef FCMOVLE_IMPL
! #undef FCMOVGT_IMPL
! #undef CVTQL_IMPL
! #undef TRAPB_IMPL
! #undef EXCB_IMPL
! #undef MB_IMPL
! #undef WMB_IMPL
! #undef FETCH_IMPL
! #undef FETCH_M_IMPL
! #undef RPCC_IMPL
! #undef _RC_IMPL
! #undef ECB_IMPL
! #undef _RS_IMPL
! #undef WH64_IMPL
! #undef JMP_IMPL
! #undef JSR_IMPL
! #undef RETN_IMPL
! #undef JSR_COROUTINE_IMPL
! #undef SEXTB_IMPL
! #undef SEXTBI_IMPL
! #undef SEXTW_IMPL
! #undef SEXTWI_IMPL
! #undef CTPOP_IMPL
! #undef PERR_IMPL
! #undef CTLZ_IMPL
! #undef CTTZ_IMPL
! #undef UNPKBW_IMPL
! #undef UNPKBL_IMPL
! #undef PKWB_IMPL
! #undef PKLB_IMPL
! #undef MINSB8_IMPL
! #undef MINSW4_IMPL
! #undef MINUB8_IMPL
! #undef MINUW4_IMPL
! #undef MAXUB8_IMPL
! #undef MAXUW4_IMPL
! #undef MAXSB8_IMPL
! #undef MAXSW4_IMPL
! #undef FTOIT_IMPL
! #undef FTOIS_IMPL
  
  #undef DEFINST
  #undef DEFLINK
--- 189,2257 ----
   *		    TALIGN(T)	   - check jump target T alignment
   */
  
! /* no operation */
! #define NOP_IMPL							\
!   {									\
!     /* nada... */							\
!   }
! DEFINST(NOP,		0x00,
! 	"nop",		"",
! 	IntALU,		F_ICOMP,
! 	DNA, DNA,	DNA, DNA, DNA)
  
! /*
!  * control operations
!  */
  
! #define JUMP_IMPL							\
    {									\
!     SET_TPC((CPC & 036000000000) | (TARG << 2));			\
!     SET_NPC((CPC & 036000000000) | (TARG << 2));			\
    }
! DEFINST(JUMP,			0x01,
! 	"j",			"J",
! 	NA, 			F_CTRL|F_UNCOND|F_DIRJMP,
! 	DNA, DNA, 		DNA, DNA, DNA)
  
! #define JAL_IMPL							\
    {									\
!     SET_TPC((CPC & 036000000000) | (TARG << 2));			\
!     SET_NPC((CPC & 036000000000) | (TARG << 2));			\
!     SET_GPR(31, CPC + 8);						\
    }
! DEFINST(JAL,			0x02,
! 	"jal",			"J",
! 	IntALU,			F_CTRL|F_UNCOND|F_DIRJMP|F_CALL,
! 	DGPR(31), DNA,	 	DNA, DNA, DNA)
  
! #define JR_IMPL								\
    {									\
!     if (GPR(RS) & 0x7)							\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_TPC(GPR(RS));							\
!     SET_NPC(GPR(RS));							\
!   }
! DEFINST(JR, 			0x03,
! 	"jr", 			"s", 
! 	NA, 			F_CTRL|F_UNCOND|F_INDIRJMP,
! 	DNA, DNA,		DGPR(RS), DNA, DNA)
! 
! #define JALR_IMPL							\
!   {									\
!     if (GPR(RS) & 0x7)							\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_GPR(RD, CPC + 8);						\
!     SET_TPC(GPR(RS));							\
!     SET_NPC(GPR(RS));							\
!   }
! DEFINST(JALR,	 		0x04,
! 	"jalr", 		"d,s",
! 	IntALU,			F_CTRL|F_UNCOND|F_INDIRJMP|F_CALL,
! 	DGPR(RD), DNA,		DGPR(RS), DNA, DNA)
! 
! #define BEQ_IMPL							\
!   {									\
!     SET_TPC(CPC + 8 + (OFS << 2));					\
!     if (GPR(RS) == GPR(RT))						\
!       SET_NPC(CPC + 8 + (OFS << 2));					\
!   }
! DEFINST(BEQ,			0x05,
! 	"beq",			"s,t,j",
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RS), DGPR(RT), DNA)
! 
! #define BNE_IMPL							\
!   {									\
!     SET_TPC(CPC + 8 + (OFS << 2));					\
!     if (GPR(RS) != GPR(RT))						\
!       SET_NPC(CPC + 8 + (OFS << 2));					\
!   }
! DEFINST(BNE,			0x06,
! 	"bne",			"s,t,j",
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RS), DGPR(RT), DNA)
! 
! #define BLEZ_IMPL							\
!   {									\
!     SET_TPC(CPC + 8 + (OFS << 2));					\
!     if (GPR(RS) <= 0)							\
!       SET_NPC(CPC + 8 + (OFS << 2));					\
!   }
! DEFINST(BLEZ,			0x07,
! 	"blez",			"s,j",
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RS), DNA, DNA)
! 
! #define BGTZ_IMPL							\
!   {									\
!     SET_TPC(CPC + 8 + (OFS << 2));					\
!     if (GPR(RS) > 0)							\
!       SET_NPC(CPC + 8 + (OFS << 2));					\
!   }
! DEFINST(BGTZ,			0x08,
! 	"bgtz",			"s,j",
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RS), DNA, DNA)
! 
! #define BLTZ_IMPL							\
!   {									\
!     SET_TPC(CPC + 8 + (OFS << 2));					\
!     if (GPR(RS) < 0)							\
!       SET_NPC(CPC + 8 + (OFS << 2));					\
!   }
! DEFINST(BLTZ,	 		0x09,
! 	"bltz", 		"s,j", 
! 	IntALU, 		F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RS), DNA, DNA)
! 
! #define BGEZ_IMPL							\
!   {									\
!     SET_TPC(CPC + 8 + (OFS << 2));					\
!     if (GPR(RS) >= 0)							\
!       SET_NPC(CPC + 8 + (OFS << 2));					\
!   }
! DEFINST(BGEZ, 			0x0a,
! 	"bgez", 		"s,j", 
! 	IntALU, 		F_CTRL|F_COND|F_DIRJMP,
! 	DNA, DNA,		DGPR(RS), DNA, DNA)
! 
! #define BC1F_IMPL							\
!   {									\
!     SET_TPC(CPC + 8 + (OFS << 2));					\
!     if (!FCC)								\
!       SET_NPC(CPC + 8 + (OFS << 2));					\
!   }
! DEFINST(BC1F, 			0x0b,
! 	"bc1f", 		"j", 
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP|F_FPCOND,
! 	DNA, DNA,		DFCC, DNA, DNA)
! 
! #define BC1T_IMPL							\
!   {									\
!     SET_TPC(CPC + 8 + (OFS << 2));					\
!     if (FCC)								\
!       SET_NPC(CPC + 8 + (OFS << 2));					\
!   }
! DEFINST(BC1T, 			0x0c,
! 	"bc1t", 		"j", 
! 	IntALU,			F_CTRL|F_COND|F_DIRJMP|F_FPCOND,
! 	DNA, DNA,		DFCC, DNA, DNA)
! 
! 
! /*
!  * load/store operations
!  *
!  * NOTE: the out-of-order issue simulator(s) require that load and store
!  * address computation input dependencies be placed in slots 1 and 2 of
!  * the input dependency list slot 0 is reserved for the input dependency
!  * of store values for store instructions
!  */
! 
! #define LB_IMPL								\
!   {									\
!     sbyte_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_BYTE(GPR(BS) + OFS, _fault);				\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
!     SET_GPR(RT, (word_t)(sword_t)_result);				\
    }
! DEFINST(LB,			0x20,
! 	"lb",			"t,o(b)",
  	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
  
! #define LBU_IMPL							\
    {									\
!     byte_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_BYTE(GPR(BS) + OFS, _fault);				\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
+     SET_GPR(RT, (word_t)_result);					\
+   }
+ DEFINST(LBU, 			0x22, 
+ 	"lbu", 			"t,o(b)",
+ 	RdPort, 		F_MEM|F_LOAD|F_DISP,
+ 	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
+ 
+ #define LH_IMPL								\
+   {									\
+     shalf_t _result;							\
+     enum md_fault_type _fault;						\
  									\
!     _result = READ_HALF(GPR(BS) + OFS, _fault);				\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
!     SET_GPR(RT, (word_t)(sword_t)_result);				\
    }
! DEFINST(LH, 			0x24,
! 	"lh",			"t,o(b)",
  	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
  
! #define LHU_IMPL							\
    {									\
      half_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_HALF(GPR(BS) + OFS, _fault);				\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
!     SET_GPR(RT, (word_t)_result);					\
    }
! DEFINST(LHU, 			0x26, 
! 	"lhu", 			"t,o(b)",
! 	RdPort, 		F_MEM|F_LOAD|F_DISP,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
  
! #define LW_IMPL								\
    {									\
+     word_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_WORD(GPR(BS) + OFS, _fault);				\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
+     SET_GPR(RT, _result);						\
    }
! DEFINST(LW,			0x28,
! 	"lw", 			"t,o(b)",
! 	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
  
! #define DLW_IMPL							\
    {									\
+     word_t _result_hi, _result_lo;					\
      enum md_fault_type _fault;						\
  									\
!     if ((RT) & 01)							\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     _result_hi = READ_WORD(GPR(BS) + OFS, _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
!     _result_lo = READ_WORD(GPR(BS) + OFS + 4, _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
+ 									\
+     SET_GPR(RT, _result_hi);						\
+     SET_GPR((RT) + 1, _result_lo);					\
    }
! DEFINST(DLW,			0x29,
! 	"dlw",			"t,o(b)",
! 	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR_D(RT), DNA,	DNA, DGPR(BS), DNA)
  
! #define L_S_IMPL							\
    {									\
+     word_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_WORD(GPR(BS) + OFS, _fault);				\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
+     SET_FPR_L(FT, _result);						\
    }
! DEFINST(L_S, 			0x2a,
! 	"l.s",			"T,o(b)",
! 	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DFPR_L(FT), DNA,	DNA, DGPR(BS), DNA)
  
! #define L_D_IMPL							\
    {									\
!     word_t _result_hi, _result_lo;					\
!     enum md_fault_type _fault;						\
! 									\
!     if ((FT) & 01)							\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     _result_hi = READ_WORD(GPR(BS) + OFS, _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
!     _result_lo = READ_WORD(GPR(BS) + OFS + 4, _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_FPR_L(FT, _result_hi);						\
!     SET_FPR_L((FT) + 1, _result_lo);					\
    }
  
! DEFINST(L_D,			0x2b,
! 	"l.d",			"T,o(b)",
! 	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DFPR_D(FT), DNA,	DNA, DGPR(BS), DNA)
  
! #if (!defined(MD_CROSS_ENDIAN) && defined(BYTES_BIG_ENDIAN)) || (defined(MD_CROSS_ENDIAN) && defined(BYTES_LITTLE_ENDIAN))
! #define LWL_IMPL							\
    {									\
!     md_addr_t _temp_bs;							\
!     word_t _lr_temp;							\
!     enum md_fault_type _fault;						\
! 									\
!     /* BS may == RT */							\
!     _temp_bs = GPR(BS);							\
!     _lr_temp = READ_WORD(WL_BASE(_temp_bs + OFS), _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_GPR(RT, ((GPR(RT) & WL_PROT_MASK1(_temp_bs + OFS))		\
! 		 | ((_lr_temp << (8 * WL_SIZE(_temp_bs + OFS)))		\
! 		    & ~WL_PROT_MASK1(_temp_bs + OFS))));		\
!   }
! DEFINST(LWL,			0x2c,
!         "lwl",			"t,o(b)",
!         RdPort,			F_MEM|F_LOAD|F_DISP,
!         DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
  
! #define LWR_IMPL							\
    {									\
!     md_addr_t _temp_bs;							\
!     word_t _lr_temp;							\
!     enum md_fault_type _fault;						\
! 									\
!     /* BS may == RT */							\
!     _temp_bs = GPR(BS);							\
!     _lr_temp = READ_WORD(WR_BASE(_temp_bs + OFS), _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_GPR(RT, ((GPR(RT) & ~WR_PROT_MASK1(_temp_bs + OFS))		\
! 		 | ((_lr_temp >> (8 * (4 - WR_SIZE(_temp_bs + OFS))))	\
! 		    & WR_PROT_MASK1(_temp_bs + OFS))));			\
!   }
! DEFINST(LWR,			0x2d,
!         "lwr",			"t,o(b)",
!         RdPort,			F_MEM|F_LOAD|F_DISP,
!         DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
! #else /* defined BYTES_LITTLE_ENDIAN */
! #define LWL_IMPL							\
!   {									\
!     md_addr_t _temp_bs;							\
!     word_t _lr_temp;							\
!     enum md_fault_type _fault;						\
! 									\
!     /* BS may == RT */							\
!     _temp_bs = GPR(BS);							\
!     _lr_temp = READ_WORD(WL_BASE(_temp_bs + OFS), _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_GPR(RT, ((GPR(RT) & WR_PROT_MASK1(_temp_bs + OFS))		\
! 		 | ((_lr_temp << (8 * (WL_SIZE(_temp_bs + OFS)-1)))	\
! 		    & ~WR_PROT_MASK1(_temp_bs + OFS))));		\
!   }
! DEFINST(LWL,			0x2c,
!         "lwl",			"t,o(b)",
!         RdPort,			F_MEM|F_LOAD|F_DISP,
!         DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
  
! #define LWR_IMPL							\
    {									\
!     md_addr_t _temp_bs;							\
!     word_t _lr_temp;							\
      enum md_fault_type _fault;						\
  									\
!     /* BS may == RT */							\
!     _temp_bs = GPR(BS);							\
!     _lr_temp = READ_WORD(WR_BASE(_temp_bs + OFS), _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
  									\
!     SET_GPR(RT, ((GPR(RT) & ~WL_PROT_MASK2(_temp_bs + OFS))		\
! 		 | ((_lr_temp >> (8 * (WR_SIZE(_temp_bs + OFS)-1)))	\
! 		    & WL_PROT_MASK2(_temp_bs + OFS))));			\
!   }
! DEFINST(LWR,			0x2d,
!         "lwr",			"t,o(b)",
!         RdPort,			F_MEM|F_LOAD|F_DISP,
!         DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
! #endif
!   
! #if 0
! #define LWL_IMPL							\
!   {									\
!     md_addr_t _temp_bs;							\
!     word_t _lr_temp;							\
!     enum md_fault_type _fault;						\
! 									\
!     /* BS may == RT */							\
!     _temp_bs = GPR(BS);							\
!     _lr_temp = READ_WORD(WL_BASE(_temp_bs + OFS), _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_GPR(RT, ((GPR(RT) & WL_PROT_MASK(_temp_bs + OFS)) |		\
!                       (_lr_temp & ~WL_PROT_MASK(_temp_bs + OFS))));	\
    }
! DEFINST(LWL,			0x2c,
! 	"lwl",			"t,o(b)",
! 	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
! /* #else */
! DEFINST(LWL,			0x2c,
! 	"lwl",			"t,o(b)",
  	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DNA,
! 	(ss_lr_temp = READ_WORD(WL_BASE(GPR(BS) + OFS)),
! 	 SET_GPR(RT, ((GPR(RT) & WL_PROT_MASK1(GPR(BS) + OFS)) |
! 		      ((ss_lr_temp << (8 * WL_SIZE(GPR(BS) + OFS))) 
! 		       & ~WL_PROT_MASK1(GPR(BS) + OFS))))))
! #endif
  
! #if 0
! #define LWR_IMPL							\
    {									\
!     md_addr_t _temp_bs;							\
!     word_t _lr_temp;							\
      enum md_fault_type _fault;						\
  									\
!     /* BS may == RT */							\
!     _temp_bs = GPR(BS);							\
!     _lr_temp = READ_WORD(WR_BASE(_temp_bs + OFS), _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
  									\
!     SET_GPR(RT, ((GPR(RT) & WR_PROT_MASK(_temp_bs + OFS)) |		\
!                       (_lr_temp & ~WR_PROT_MASK(_temp_bs + OFS))));	\
    }
! DEFINST(LWR,			0x2d,
! 	"lwr",			"t,o(b)",
  	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DNA)
! /* #else */
! DEFINST(LWR,			0x2d,
! 	"lwr",			"t,o(b)",
! 	RdPort,			F_MEM|F_LOAD|F_DISP,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DNA,
! 	(ss_lr_temp = READ_WORD(WR_BASE(GPR(BS) + OFS)),
! 	 SET_GPR(RT, ((GPR(RT) & ~WR_PROT_MASK1(GPR(BS) + OFS)) |
! 		      ((ss_lr_temp >> (8 * (4 - WR_SIZE(GPR(BS) + OFS)))) 
! 		       & WR_PROT_MASK1(GPR(BS) + OFS))))))
! #endif
  
! #define SB_IMPL								\
    {									\
!     byte_t _src;							\
!     enum md_fault_type _fault;						\
! 									\
!     _src = (byte_t)(word_t)GPR(RT);					\
!     WRITE_BYTE(_src, GPR(BS) + OFS, _fault);				\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(SB, 			0x30, 
! 	"sb", 			"t,o(b)",
! 	WrPort, 		F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,	 	DGPR(RT), DGPR(BS), DNA)
  
! #define SH_IMPL								\
    {									\
!     half_t _src;							\
!     enum md_fault_type _fault;						\
! 									\
!     _src = (half_t)(word_t)GPR(RT);					\
!     WRITE_HALF(_src, GPR(BS) + OFS, _fault);				\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(SH, 			0x32, 
! 	"sh", 			"t,o(b)",
! 	WrPort, 		F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,	 	DGPR(RT), DGPR(BS), DNA)
! 
! #define SW_IMPL								\
!   {									\
!     word_t _src;							\
!     enum md_fault_type _fault;						\
! 									\
!     _src = (word_t)GPR(RT);						\
!     WRITE_WORD(_src, GPR(BS) + OFS, _fault);				\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
!   }
! DEFINST(SW, 			0x34, 
! 	"sw", 			"t,o(b)",
! 	WrPort, 		F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,	 	DGPR(RT), DGPR(BS), DNA)
  
! /* FIXME: this code not fault-safe, yet... */
! #define DSW_IMPL							\
    {									\
      enum md_fault_type _fault;						\
  									\
!     if ((RT) & 01)							\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     WRITE_WORD(GPR(RT), GPR(BS) + OFS, _fault);				\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
!     WRITE_WORD(GPR((RT) + 1), GPR(BS) + OFS + 4, _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(DSW,			0x35,
! 	"dsw",			"t,o(b)",
  	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DGPR_D(RT), DGPR(BS), DNA)
  
! /* FIXME: this code not fault-safe, yet... */
! #define DSZ_IMPL							\
    {									\
      enum md_fault_type _fault;						\
  									\
!     WRITE_WORD(GPR(0), GPR(BS) + OFS, _fault);				\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
!     WRITE_WORD(GPR(0), GPR(BS) + OFS + 4, _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(DSZ,			0x38,
! 	"dsz",			"o(b)",
  	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DNA, DGPR(BS), DNA)
  
! #define S_S_IMPL							\
    {									\
      enum md_fault_type _fault;						\
  									\
!     WRITE_WORD(FPR_L(FT), GPR(BS) + OFS, _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
+   }
+ DEFINST(S_S, 			0x36, 
+ 	"s.s", 			"T,o(b)",
+ 	WrPort, 		F_MEM|F_STORE|F_DISP,
+ 	DNA, DNA,		DFPR_L(FT), DGPR(BS), DNA)
+ 
+ /* FIXME: this code not fault-safe, yet... */
+ #define S_D_IMPL							\
+   {									\
+     enum md_fault_type _fault;						\
  									\
!     if ((FT) & 01)							\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     WRITE_WORD(FPR_L(FT), GPR(BS) + OFS, _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
!     WRITE_WORD(FPR_L((FT)+1), GPR(BS) + OFS + 4, _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(S_D,			0x37,
! 	"s.d",			"T,o(b)",
! 	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DFPR_D(FT), DGPR(BS), DNA)
  
! #if (!defined(MD_CROSS_ENDIAN) && defined(BYTES_BIG_ENDIAN)) || (defined(MD_CROSS_ENDIAN) && defined(BYTES_LITTLE_ENDIAN))
! #define SWL_IMPL							\
    {									\
!     word_t _lr_temp;							\
      enum md_fault_type _fault;						\
  									\
!     _lr_temp = READ_WORD(WL_BASE(GPR(BS) + OFS), _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
  									\
!     _lr_temp = (((GPR(RT) >> (8 * WL_SIZE(GPR(BS) + OFS)))		\
! 		 & WL_PROT_MASK2(GPR(BS) + OFS))			\
! 		| (_lr_temp & ~WL_PROT_MASK2(GPR(BS) + OFS)));		\
!     WRITE_WORD(_lr_temp, WL_BASE(GPR(BS) + OFS), _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(SWL,			0x39,
!         "swl",			"t,o(b)",
!         WrPort,			F_MEM|F_STORE|F_DISP,
!         DNA, DNA,		DGPR(RT), DGPR(BS), DNA)
  
! #define SWR_IMPL							\
    {									\
!     word_t _lr_temp;							\
      enum md_fault_type _fault;						\
  									\
!     _lr_temp = READ_WORD(WR_BASE(GPR(BS) + OFS), _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
  									\
!     _lr_temp = (((GPR(RT) << (8 * (4 - WR_SIZE(GPR(BS) + OFS))))	\
! 		 & ~WR_PROT_MASK2(GPR(BS) + OFS))			\
! 		| (_lr_temp & WR_PROT_MASK2(GPR(BS) + OFS)));		\
!     WRITE_WORD(_lr_temp, WR_BASE(GPR(BS) + OFS), _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(SWR,			0x3a,
!         "swr",			"t,o(b)",
!         WrPort,			F_MEM|F_STORE|F_DISP,
!         DNA, DNA,		DGPR(RT), DGPR(BS), DNA)
! #else /* BYTES_LITTLE_ENDIAN */
! #define SWL_IMPL							\
    {									\
!     word_t _lr_temp;							\
      enum md_fault_type _fault;						\
  									\
!     _lr_temp = READ_WORD(WL_BASE(GPR(BS) + OFS), _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
  									\
!     _lr_temp = (((GPR(RT) >> (8 * (4 - WR_SIZE(GPR(BS) + OFS))))	\
! 		 & WR_PROT_MASK2(GPR(BS) + OFS))			\
! 		| (_lr_temp & ~WR_PROT_MASK2(GPR(BS) + OFS)));		\
!     WRITE_WORD(_lr_temp, WL_BASE(GPR(BS)+OFS), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(SWL,			0x39,
!         "swl",			"t,o(b)",
!         WrPort,			F_MEM|F_STORE|F_DISP,
!         DNA, DNA,		DGPR(RT), DGPR(BS), DNA)
  
! #define SWR_IMPL							\
    {									\
!     word_t _lr_temp;							\
      enum md_fault_type _fault;						\
  									\
!     _lr_temp = READ_WORD(WR_BASE(GPR(BS) + OFS), _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     _lr_temp = (((GPR(RT) << (8 * (4 - WL_SIZE(GPR(BS) + OFS))))	\
! 		   & ~WL_PROT_MASK1(GPR(BS) + OFS))			\
! 		  | (_lr_temp & WL_PROT_MASK1(GPR(BS) + OFS)));		\
!     WRITE_WORD(_lr_temp, WR_BASE(GPR(BS) + OFS), _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(SWR,			0x3a,
!         "swr",			"t,o(b)",
!         WrPort,			F_MEM|F_STORE|F_DISP,
!         DNA, DNA,		DGPR(RT), DGPR(BS), DNA)
! #endif
  
! #if 0
! #define SWL_IMPL							\
    {									\
+     word_t _lr_temp;							\
      enum md_fault_type _fault;						\
  									\
!     _lr_temp = READ_WORD(WL_BASE(GPR(BS) + OFS), _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     _lr_temp = ((GPR(RT) & ~WL_PROT_MASK(GPR(BS) + OFS)) |		\
!                        (_lr_temp & WL_PROT_MASK(GPR(BS) + OFS)));	\
!     WRITE_WORD(_lr_temp, WL_BASE(GPR(BS) + OFS), _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(SWL,			0x39,
! 	"swl",			"t,o(b)",
  	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DGPR(RT), DGPR(BS), DNA)
! /* #else */
! DEFINST(SWL,			0x39,
! 	"swl",			"t,o(b)",
! 	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DGPR(RT), DGPR(BS), DNA,
! 	(ss_lr_temp = READ_WORD(WL_BASE(GPR(BS) + OFS)),
! 	 ss_lr_temp = (((GPR(RT) >> (8 * WL_SIZE(GPR(BS) + OFS))) 
! 			& WL_PROT_MASK2(GPR(BS) + OFS)) |
! 		       (ss_lr_temp & ~WL_PROT_MASK2(GPR(BS) + OFS))),
! 	 WRITE_WORD(ss_lr_temp, WL_BASE(GPR(BS) + OFS))))
! #endif
  
! #if 0
! #define SWR_IMPL							\
    {									\
!     word_t _lr_temp;							\
      enum md_fault_type _fault;						\
  									\
!     _lr_temp = READ_WORD(WR_BASE(GPR(BS) + OFS), _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     _lr_temp = ((GPR(RT) & ~WR_PROT_MASK(GPR(BS) + OFS)) |		\
!                        (_lr_temp & WR_PROT_MASK(GPR(BS) + OFS)));	\
!     WRITE_WORD(_lr_temp, WR_BASE(GPR(BS) + OFS), _fault);		\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
    }
! DEFINST(SWR,			0x3a,
! 	"swr",			"t,o(b)",
! 	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DGPR(RT), DGPR(BS), DNA)
! /* #else */
! DEFINST(SWR,			0x3a,
! 	"swr",			"t,o(b)",
  	WrPort,			F_MEM|F_STORE|F_DISP,
! 	DNA, DNA,		DGPR(RT), DGPR(BS), DNA,
! 	(ss_lr_temp = READ_WORD(WR_BASE(GPR(BS)+OFS)),
! 	 ss_lr_temp = (((GPR(RT) << (8 * (4 - WR_SIZE(GPR(BS) + OFS)))) 
! 			& ~WR_PROT_MASK2(GPR(BS)+OFS)) |
! 		       (ss_lr_temp & WR_PROT_MASK2(GPR(BS)+OFS))),
! 	 WRITE_WORD(ss_lr_temp, WR_BASE(GPR(BS)+OFS))))
! #endif
! 
! /* reg+reg loads and stores */
  
! #define LB_RR_IMPL							\
    {									\
+     sbyte_t _result;							\
      enum md_fault_type _fault;						\
  									\
!     _result = READ_BYTE(GPR(BS) + GPR(RD), _fault);			\
      if (_fault != md_fault_none)					\
        DECLARE_FAULT(_fault);						\
+ 									\
+     SET_GPR(RT, (word_t)(sword_t)_result);				\
    }
! DEFINST(LB_RR,			0xc0,
! 	"lb",			"t,(b+d)",
! 	RdPort,			F_MEM|F_LOAD|F_RR,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DGPR(RD))
  
! #define LBU_RR_IMPL							\
    {									\
!     byte_t _result;							\
!     enum md_fault_type _fault;						\
! 									\
!     _result = READ_BYTE(GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_GPR(RT, (word_t)_result);					\
    }
! DEFINST(LBU_RR,			0xc1, 
! 	"lbu", 			"t,(b+d)",
! 	RdPort, 		F_MEM|F_LOAD|F_RR,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DGPR(RD))
  
! #define LH_RR_IMPL							\
    {									\
!     shalf_t _result;							\
!     enum md_fault_type _fault;						\
! 									\
!     _result = READ_HALF(GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_GPR(RT, (word_t)(sword_t)_result);				\
    }
! DEFINST(LH_RR,	 		0xc2,
! 	"lh",			"t,(b+d)",
! 	RdPort,			F_MEM|F_LOAD|F_RR,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DGPR(RD))
  
! #define LHU_RR_IMPL							\
    {									\
!     half_t _result;							\
!     enum md_fault_type _fault;						\
! 									\
!     _result = READ_HALF(GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_GPR(RT, (word_t)_result);					\
    }
! DEFINST(LHU_RR,			0xc3, 
! 	"lhu", 			"t,(b+d)",
! 	RdPort, 		F_MEM|F_LOAD|F_RR,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DGPR(RD))
  
! #define LW_RR_IMPL							\
    {									\
!     word_t _result;							\
!     enum md_fault_type _fault;						\
! 									\
!     _result = READ_WORD(GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_GPR(RT, _result);						\
    }
! DEFINST(LW_RR,			0xc4,
! 	"lw", 			"t,(b+d)",
! 	RdPort,			F_MEM|F_LOAD|F_RR,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DGPR(RD))
  
! #define DLW_RR_IMPL							\
    {									\
!     word_t _result_hi, _result_lo;					\
!     enum md_fault_type _fault;						\
! 									\
!     if ((RT) & 01)							\
!       DECLARE_FAULT(md_fault_alignment)					\
! 									\
!     _result_hi = READ_WORD(GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
!     _result_lo = READ_WORD(GPR(BS) + GPR(RD) + 4, _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_GPR(RT, _result_hi);						\
!     SET_GPR((RT) + 1, _result_lo);					\
    }
! DEFINST(DLW_RR,			0xce,
! 	"dlw",			"t,(b+d)",
! 	RdPort,			F_MEM|F_LOAD|F_RR,
! 	DGPR_D(RT), DNA,	DNA, DGPR(BS), DGPR(RD))
  
! #define L_S_RR_IMPL							\
    {									\
!     word_t _result;							\
!     enum md_fault_type _fault;						\
! 									\
!     _result = READ_WORD(GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_FPR_L(FT, _result);						\
    }
! DEFINST(L_S_RR,			0xc5,
! 	"l.s",	 		"T,(b+d)",
! 	RdPort,			F_MEM|F_LOAD|F_RR,
! 	DFPR_L(FT), DNA,	DNA, DGPR(BS), DGPR(RD))
  
! #define L_D_RR_IMPL							\
    {									\
!     word_t _result_hi, _result_lo;					\
!     enum md_fault_type _fault;						\
! 									\
!     if ((FT) & 01)							\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     _result_hi = READ_WORD(GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
!     _result_lo = READ_WORD(GPR(BS) + GPR(RD) + 4, _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_FPR_L(FT, _result_hi);						\
!     SET_FPR_L((FT) + 1, _result_lo);					\
    }
! DEFINST(L_D_RR,			0xcf,
! 	"l.d",			"T,(b+d)",
! 	RdPort,			F_MEM|F_LOAD|F_RR,
! 	DFPR_D(FT), DNA,	DNA, DGPR(BS), DGPR(RD))
  
! #define SB_RR_IMPL							\
    {									\
!     byte_t _src;							\
!     enum md_fault_type _fault;						\
! 									\
!     _src = (byte_t)(word_t)GPR(RT);					\
!     WRITE_BYTE(_src, GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(SB_RR, 			0xc6, 
! 	"sb", 			"t,(b+d)", 
! 	WrPort, 		F_MEM|F_STORE|F_RR,
! 	DNA, DNA,	 	DGPR(RT), DGPR(BS), DGPR(RD))
  
! #define SH_RR_IMPL							\
    {									\
!     half_t _src;							\
!     enum md_fault_type _fault;						\
! 									\
!     _src = (half_t)(word_t)GPR(RT);					\
!     WRITE_HALF(_src, GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(SH_RR,	 		0xc7, 
! 	"sh", 			"t,(b+d)", 
! 	WrPort,			F_MEM|F_STORE|F_RR,
! 	DNA, DNA,	 	DGPR(RT), DGPR(BS), DGPR(RD))
  
! #define SW_RR_IMPL							\
    {									\
!     word_t _src;							\
!     enum md_fault_type _fault;						\
! 									\
!     _src = (word_t)GPR(RT);						\
!     WRITE_WORD(_src, GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(SW_RR,	 		0xc8, 
! 	"sw", 			"t,(b+d)", 
! 	WrPort, 		F_MEM|F_STORE|F_RR,
! 	DNA, DNA,		DGPR(RT), DGPR(BS), DGPR(RD))
  
! /* FIXME: this code not fault-safe, yet... */
! #define DSW_RR_IMPL							\
    {									\
!     enum md_fault_type _fault;						\
! 									\
!     if ((RT) & 01)							\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     WRITE_WORD(GPR(RT), GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
!     WRITE_WORD(GPR((RT)+1), GPR(BS) + GPR(RD) + 4, _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(DSW_RR,			0xd0,
! 	"dsw",			"t,(b+d)",
! 	WrPort,			F_MEM|F_STORE|F_RR,
! 	DNA, DNA,		DGPR_D(RT), DGPR(BS), DGPR(RD))
  
! /* FIXME: this code not fault-safe, yet... */
! #define DSZ_RR_IMPL							\
    {									\
!     enum md_fault_type _fault;						\
! 									\
!     WRITE_WORD(GPR(0), GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
!     WRITE_WORD(GPR(0), GPR(BS) + GPR(RD) + 4, _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(DSZ_RR,			0xd1,
! 	"dsz",			"(b+d)",
! 	WrPort,			F_MEM|F_STORE|F_RR,
! 	DNA, DNA,		DNA, DGPR(BS), DGPR(RD))
  
! #define S_S_RR_IMPL							\
    {									\
!     enum md_fault_type _fault;						\
! 									\
!     WRITE_WORD(FPR_L(FT), GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(S_S_RR,			0xc9, 
! 	"s.s",	 		"T,(b+d)", 
! 	WrPort, 		F_MEM|F_STORE|F_RR,
! 	DNA, DNA,		DFPR_L(FT), DGPR(BS), DGPR(RD))
  
! /* FIXME: this code not fault-safe, yet... */
! #define S_D_RR_IMPL							\
    {									\
!     enum md_fault_type _fault;						\
! 									\
!     if ((FT) & 01)							\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     WRITE_WORD(FPR_L(FT), GPR(BS) + GPR(RD), _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
!     WRITE_WORD(FPR_L((FT)+1), GPR(BS) + GPR(RD) + 4, _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(S_D_RR,			0xd2,
! 	"s.d",			"T,(b+d)",
! 	WrPort,			F_MEM|F_STORE|F_RR,
! 	DNA, DNA,		DFPR_D(FT), DGPR(BS), DGPR(RD))
  
  
! /* reg + reg + 4 addressing mode, used to synthesize `l.d r,(s+t)^++' */
! /* FIXME: obsolete, but do not delete or predecoded state images will break! */
! #define L_S_RR_R2_IMPL							\
    {									\
!     word_t _result;							\
!     enum md_fault_type _fault;						\
! 									\
!     _result = READ_WORD(GPR(BS) + GPR(RD) + 4, _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_FPR_L(FT, _result);						\
    }
! DEFINST(L_S_RR_R2,		0xca,
! 	"l.s.r2", 		"T,(b+d)",
! 	RdPort,			F_MEM|F_LOAD|F_RR,
! 	DFPR_L(FT), DNA,	DNA, DGPR(BS), DGPR(RD))
  
  
! /* FIXME: obsolete, but do not delete or predecoded state images will break! */
! #define S_S_RR_R2_IMPL							\
    {									\
!     enum md_fault_type _fault;						\
! 									\
!     WRITE_WORD(FPR_L(FT), GPR(BS) + GPR(RD) + 4, _fault);		\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(S_S_RR_R2,		0xcb,
! 	"s.s.r2", 		"T,(b+d)", 
! 	WrPort, 		F_MEM|F_STORE|F_RR,
! 	DNA, DNA,		DFPR_L(FT), DGPR(BS), DGPR(RD))
  
! /* FIXME: obsolete, but do not delete or predecoded state images will break! */
! #define LW_RR_R2_IMPL							\
    {									\
!     word_t _result;							\
!     enum md_fault_type _fault;						\
! 									\
!     _result = READ_WORD(GPR(BS) + GPR(RD) + 4, _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
! 									\
!     SET_GPR(RT, _result);						\
    }
! DEFINST(LW_RR_R2,		0xcc,
! 	"lw.r2",		"t,(b+d)",
! 	RdPort,			F_MEM|F_LOAD|F_RR,
! 	DGPR(RT), DNA,		DNA, DGPR(BS), DGPR(RD))
  
! /* FIXME: obsolete, but do not delete or predecoded state images will break! */
! #define SW_RR_R2_IMPL							\
    {									\
!     enum md_fault_type _fault;						\
! 									\
!     WRITE_WORD(GPR(RT), GPR(BS) + GPR(RD) + 4, _fault);			\
!     if (_fault != md_fault_none)					\
!       DECLARE_FAULT(_fault);						\
    }
! DEFINST(SW_RR_R2,		0xcd, 
! 	"sw.r2", 		"t,(b+d)",
! 	WrPort, 		F_MEM|F_STORE|F_RR,
! 	DNA, DNA,		DGPR(RT), DGPR(BS), DGPR(RD))
! 
  
! /*
!  * Integer ALU operations
!  */
  
! #define ADD_IMPL							\
    {									\
!     if (OVER(GPR(RS), GPR(RT)))						\
!       DECLARE_FAULT(md_fault_overflow);					\
! 									\
!     SET_GPR(RD, GPR(RS) + GPR(RT));					\
    }
! DEFINST(ADD,	 		0x40,
! 	"add", 			"d,s,t",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)
  
! #define ADDI_IMPL							\
    {									\
!     if (OVER(GPR(RS), IMM))						\
!       DECLARE_FAULT(md_fault_overflow);					\
! 									\
!     SET_GPR(RT, GPR(RS) + IMM);						\
    }
! DEFINST(ADDI,			0x41,
! 	"addi",			"t,s,i",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RT), DNA, 		DGPR(RS), DNA, DNA)
  
! #define ADDU_IMPL							\
    {									\
!     SET_GPR(RD, GPR(RS) + GPR(RT));					\
    }
! DEFINST(ADDU, 			0x42,
! 	"addu", 		"d,s,t",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)
  
! #define ADDIU_IMPL							\
    {									\
!     SET_GPR(RT, GPR(RS) + IMM);						\
    }
! DEFINST(ADDIU,			0x43,
! 	"addiu",		"t,s,i",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RT), DNA, 		DGPR(RS), DNA, DNA)
  
! #define SUB_IMPL							\
    {									\
!     if (UNDER(GPR(RS), GPR(RT)))					\
!       DECLARE_FAULT(md_fault_overflow);					\
! 									\
!     SET_GPR(RD, GPR(RS) - GPR(RT));					\
    }
! DEFINST(SUB, 			0x44,
! 	"sub", 			"d,s,t",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)
  
! #define SUBU_IMPL							\
    {									\
!     SET_GPR(RD, GPR(RS) - GPR(RT));					\
    }
! DEFINST(SUBU, 			0x45,
! 	"subu", 		"d,s,t",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)
  
! #define MULT_IMPL							\
    {									\
+     bool_t _sign1, _sign2;						\
      int _i;								\
!     sword_t _op1, _op2;							\
  									\
!     /* HI,LO <- [rs] * [rt], integer product of [rs] & [rt] to HI/LO */	\
!     _sign1 = _sign2 = FALSE;						\
!     SET_HI(0);								\
!     SET_LO(0);								\
!     _op1 = GPR(RS);							\
!     _op2 = GPR(RT);							\
! 									\
!     /* for multiplication, treat -ve numbers as +ve numbers by		\
!        converting 2's complement -ve numbers to ordinary notation */	\
!     if (_op1 & 020000000000)						\
!       {									\
! 	_sign1 = TRUE;							\
! 	_op1 = (~_op1) + 1;						\
!       }									\
!     if (_op2 & 020000000000)						\
!       {									\
! 	_sign2 = TRUE;							\
! 	_op2 = (~_op2) + 1;						\
!       }									\
!     if (_op1 & 020000000000)						\
!       SET_LO(_op2);							\
  									\
!     for (_i = 0; _i < 31; _i++)						\
        {									\
! 	SET_HI(HI << 1);						\
! 	SET_HI(HI + extractl(LO, 31, 1));				\
! 	SET_LO(LO << 1);						\
! 	if ((extractl(_op1, 30 - _i, 1)) == 1)				\
! 	  {								\
! 	    if (((unsigned)037777777777 - (unsigned)LO) < (unsigned)_op2)\
! 	      {								\
! 		SET_HI(HI + 1);						\
! 	      }								\
! 	    SET_LO(LO + _op2);						\
! 	  }								\
!       }									\
! 									\
!     /* take 2's complement of the result if the result is negative */	\
!     if (_sign1 ^ _sign2)						\
!       {									\
! 	SET_LO(~LO);							\
! 	SET_HI(~HI);							\
! 	if ((unsigned)LO == 037777777777)				\
! 	  {								\
! 	    SET_HI(HI + 1);						\
! 	  }								\
! 	SET_LO(LO + 1);							\
        }									\
    }
! DEFINST(MULT, 			0x46,
! 	"mult", 		"s,t", 
! 	IntMULT, 		F_ICOMP|F_LONGLAT,
! 	DHI, DLO,		DGPR(RT), DGPR(RS), DNA)
  
! #define MULTU_IMPL							\
    {									\
      int _i;								\
  									\
!     /* HI,LO <- [rs] * [rt], integer product of [rs] & [rt] to HI/LO */	\
!     SET_HI(0);								\
!     SET_LO(0);								\
!     if (GPR(RS) & 020000000000)						\
!       SET_LO(GPR(RT));							\
  									\
!     for (_i = 0; _i < 31; _i++)						\
        {									\
! 	SET_HI(HI << 1);						\
! 	SET_HI(HI + extractl(LO, 31, 1));				\
! 	SET_LO(LO << 1);						\
! 	if ((extractl(GPR(RS), 30 - _i, 1)) == 1)			\
! 	  {								\
! 	    if (((unsigned)037777777777 - (unsigned)LO) < (unsigned)GPR(RT))\
! 	      {								\
! 		SET_HI(HI + 1);						\
! 	      }								\
! 	    SET_LO(LO + GPR(RT));					\
! 	  }								\
        }									\
    }
! DEFINST(MULTU, 			0x47,
! 	"multu", 		"s,t", 
! 	IntMULT, 		F_ICOMP|F_LONGLAT,
! 	DHI, DLO,		DGPR(RT), DGPR(RS), DNA)
  
! #define DIV_IMPL							\
    {									\
!     if (GPR(RT) == 0)							\
!       DECLARE_FAULT(md_fault_div0);					\
! 									\
!     SET_LO(GPR(RS) / GPR(RT));						\
!     SET_HI(GPR(RS) % GPR(RT));						\
    }
! DEFINST(DIV, 			0x48,
! 	"div", 			"s,t", 
! 	IntDIV, 		F_ICOMP|F_LONGLAT,
! 	DHI, DLO,		DGPR(RT), DGPR(RS), DNA)
! 
! #define DIVU_IMPL							\
    {									\
!     if (GPR(RT) == 0)							\
!       DECLARE_FAULT(md_fault_div0);					\
! 									\
!     SET_LO(((unsigned)GPR(RS)) / ((unsigned)GPR(RT)));			\
!     SET_HI(((unsigned)GPR(RS)) % ((unsigned)GPR(RT)));			\
    }
! DEFINST(DIVU, 			0x49,
! 	"divu", 		"s,t", 
! 	IntDIV, 		F_ICOMP|F_LONGLAT,
! 	DHI, DLO,		DGPR(RT), DGPR(RS), DNA)
  
! #define MFHI_IMPL							\
    {									\
!     SET_GPR(RD, HI);							\
    }
! DEFINST(MFHI, 			0x4a,
! 	"mfhi", 		"d",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DHI, DNA, DNA)
! 
! #define MTHI_IMPL							\
    {									\
!     SET_HI(GPR(RS));							\
    }
! DEFINST(MTHI, 			0x4b,
! 	"mthi", 		"s",
! 	IntALU, 		F_ICOMP,
! 	DHI, DNA,		DGPR(RS), DNA, DNA)
  
! #define MFLO_IMPL							\
    {									\
!     SET_GPR(RD, LO);							\
    }
! DEFINST(MFLO, 			0x4c,
! 	"mflo", 		"d", 
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DLO, DNA, DNA)
  
! #define MTLO_IMPL							\
    {									\
!     SET_LO(GPR(RS));							\
    }
! DEFINST(MTLO, 			0x4d,
! 	"mtlo", 		"s", 
! 	IntALU, 		F_ICOMP,
! 	DLO, DNA,		DGPR(RS), DNA, DNA)
  
! /* AND conflicts with GNU defs */
! #define AND__IMPL							\
    {									\
!     SET_GPR(RD, GPR(RS) & GPR(RT));					\
    }
! DEFINST(AND_, 			0x4e,
! 	"and", 			"d,s,t",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)
! 
! #define ANDI_IMPL							\
    {									\
!     SET_GPR(RT, GPR(RS) & UIMM);					\
    }
! DEFINST(ANDI,			0x4f,
! 	"andi",			"t,s,u",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RT), DNA,	 	DGPR(RS), DNA, DNA)
  
! #define OR_IMPL								\
    {									\
!     SET_GPR(RD, GPR(RS) | GPR(RT));					\
    }
! DEFINST(OR, 			0x50,
! 	"or", 			"d,s,t",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)
  
! #define ORI_IMPL							\
    {									\
!     SET_GPR(RT, GPR(RS) | UIMM);					\
    }
! DEFINST(ORI, 			0x51,
! 	"ori",			"t,s,u",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RT), DNA, 		DGPR(RS), DNA, DNA)
  
! #define XOR_IMPL							\
    {									\
!     SET_GPR(RD, GPR(RS) ^ GPR(RT));					\
    }
! DEFINST(XOR, 			0x52,
! 	"xor", 			"d,s,t",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)
  
! #define XORI_IMPL							\
    {									\
!     SET_GPR(RT, GPR(RS) ^ UIMM);					\
    }
! DEFINST(XORI, 			0x53,
! 	"xori",			"t,s,u",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RT), DNA, 		DGPR(RS), DNA, DNA)
  
! #define NOR_IMPL							\
    {									\
!     SET_GPR(RD, ~(GPR(RS) | GPR(RT)));					\
    }
! DEFINST(NOR, 			0x54,
! 	"nor", 			"d,s,t",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)
  
! #define SLL_IMPL							\
    {									\
!     SET_GPR(RD, GPR(RT) << SHAMT);					\
    }
! DEFINST(SLL, 			0x55,
! 	"sll", 			"d,t,H", 
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RT), DNA, DNA)
  
! #define SLLV_IMPL							\
    {									\
!     SET_GPR(RD, GPR(RT) << (GPR(RS) & 037));				\
    }
! DEFINST(SLLV, 			0x56,
! 	"sllv", 		"d,t,s", 
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RT), DGPR(RS), DNA)
  
! #ifdef FAST_SRL
! #define SRL_IMPL							\
    {									\
!     SET_GPR(RD, ((unsigned)GPR(RT)) >> SHAMT);				\
    }
! #else /* !FAST_SRL */
! #define SRL_IMPL							\
    {									\
!     /* C standard says >> is implementation specific;			\
!        could be SRL, SRA, or dependent on signdness of operand */	\
!     if ((SHAMT) != 0)							\
!       {									\
! 	word_t _rd;							\
! 									\
! 	_rd = (((unsigned)GPR(RT)) >> 1) & ~0x80000000;	/* first bit */	\
! 	SET_GPR(RD, (_rd >> ((SHAMT) - 1)));		/* rest */	\
!       }									\
!     else								\
!       {									\
! 	SET_GPR(RD, GPR(RT));						\
!       }									\
    }
! #endif /* FAST_SRL */
! DEFINST(SRL, 			0x57,
! 	"srl", 			"d,t,H", 
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RT), DNA, DNA)
  
! #ifdef FAST_SRL
! #define SRLV_IMPL							\
    {									\
!     SET_GPR(RD, ((unsigned)GPR(RT)) >> (GPR(RS) & 037));		\
    }
! #else /* !FAST_SRL */
! #define SRLV_IMPL							\
    {									\
!     int _shamt = GPR(RS) & 037;						\
! 									\
!     /* C standard says >> is implementation specific;			\
!        could be SRL, SRA, or dependent on signdness of operand */	\
!     if (_shamt != 0)							\
!       {									\
! 	word_t _rd;							\
! 									\
! 	_rd = (((unsigned)GPR(RT)) >> 1) & ~0x80000000;	/* first bit */	\
! 	SET_GPR(RD, (_rd >> (_shamt - 1)));		/* rest */	\
!       }									\
!     else								\
!       {									\
! 	SET_GPR(RD, GPR(RT));						\
!       }									\
    }
! #endif /* FAST_SRL */
! DEFINST(SRLV, 			0x58,
! 	"srlv", 		"d,t,s", 
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RT), DGPR(RS), DNA)
  
! #ifdef FAST_SRA
! #define SRA_IMPL							\
    {									\
!     SET_GPR(RD, ((signed)GPR(RT)) >> SHAMT);				\
    }
! #else /* !FAST_SRA */
! #define SRA_IMPL							\
    {									\
!     int _i;								\
! 									\
!     /* C standard says >> is implementation specific;			\
!        could be SRL, SRA, or dependent on sign-ness of operand */	\
!     /* rd <- [rt] >> SHAMT */						\
!     if (GPR(RT) & 0x80000000)						\
!       {									\
!         SET_GPR(RD, GPR(RT));						\
!         for (_i = 0; _i < SHAMT; _i++)					\
! 	  {								\
! 	    SET_GPR(RD, (GPR(RD) >> 1) | 0x80000000);			\
! 	  }								\
!       }									\
!     else								\
!       {									\
! 	SET_GPR(RD, GPR(RT) >> SHAMT);					\
!       }									\
    }
! #endif /* FAST_SRA */
! DEFINST(SRA, 			0x59,
! 	"sra", 			"d,t,H", 
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RT), DNA, DNA)
  
! #ifdef FAST_SRA
! #define SRAV_IMPL							\
    {									\
!     SET_GPR(RD, ((signed)GPR(RT)) >> (GPR(RS) & 037));			\
    }
! #else /* !FAST_SRA */
! #define SRAV_IMPL							\
!   {									\
!     int _i;								\
!     int _shamt = GPR(RS) & 037;						\
! 									\
!     /* C standard says >> is implementation specific;			\
!        could be SRL, SRA, or dependent on sign-ness of operand */	\
!     /* rd <- [rt] >> SHAMT */						\
!     if (GPR(RT) & 0x80000000)						\
!       {									\
!         SET_GPR(RD, GPR(RT));						\
!         for (_i = 0; _i < _shamt; _i++)					\
! 	  {								\
! 	    SET_GPR(RD, (GPR(RD) >> 1) | 0x80000000);			\
! 	  }								\
!       }									\
!     else								\
!       {									\
! 	SET_GPR(RD, GPR(RT) >> _shamt);					\
!       }									\
!   }
! #endif /* FAST_SRA */
! DEFINST(SRAV, 			0x5a,
! 	"srav", 		"d,t,s",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RT), DGPR(RS), DNA)
  
! #define SLT_IMPL							\
    {									\
!     if (GPR(RS) < GPR(RT))						\
!       SET_GPR(RD, 1);							\
!     else								\
!       SET_GPR(RD, 0);							\
    }
! DEFINST(SLT,			0x5b,
! 	"slt", 			"d,s,t",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)
  
! #define SLTI_IMPL							\
    {									\
!     if (GPR(RS) < IMM)							\
!       SET_GPR(RT, 1);							\
!     else								\
!       SET_GPR(RT, 0);							\
    }
! DEFINST(SLTI, 			0x5c,
! 	"slti",			"t,s,i",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RT), DNA, 		DGPR(RS), DNA, DNA)
  
! #define SLTU_IMPL							\
    {									\
!     if (((unsigned)GPR(RS)) < ((unsigned)GPR(RT)))			\
!       SET_GPR(RD, 1);							\
!     else								\
!       SET_GPR(RD, 0);							\
    }
! DEFINST(SLTU, 			0x5d,
! 	"sltu", 		"d,s,t",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RD), DNA,		DGPR(RS), DGPR(RT), DNA)
  
! #define SLTIU_IMPL							\
    {									\
!     if ((unsigned)GPR(RS) < (unsigned)IMM)				\
!       SET_GPR(RT, 1);							\
!     else								\
!       SET_GPR(RT, 0);							\
    }
! DEFINST(SLTIU,			0x5e,
! 	"sltiu",		"t,s,i",
  	IntALU,			F_ICOMP|F_IMM,
! 	DGPR(RT), DNA, 		DGPR(RS), DNA, DNA)
  
  
! /*
!  * Floating Point ALU operations
!  */
  
! #define FADD_S_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_F(FD, FPR_F(FS) + FPR_F(FT));				\
    }
! DEFINST(FADD_S,			0x70,
! 	"add.s",		"D,S,T",
! 	FloatADD,		F_FCOMP,
! 	DFPR_F(FD), DNA,	DFPR_F(FS), DFPR_F(FT), DNA)
  
! #define FADD_D_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_D(FD, FPR_D(FS) + FPR_D(FT));				\
    }
! DEFINST(FADD_D,			0x71,
! 	"add.d",		"D,S,T",
! 	FloatADD,		F_FCOMP,
! 	DFPR_D(FD), DNA,	DFPR_D(FS), DFPR_D(FT), DNA)
  
! #define FSUB_S_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_F(FD, FPR_F(FS) - FPR_F(FT));				\
    }
! DEFINST(FSUB_S,			0x72,
! 	"sub.s",		"D,S,T",
! 	FloatADD, 		F_FCOMP,
! 	DFPR_F(FD), DNA,	DFPR_F(FS), DFPR_F(FT), DNA)
  
! #define FSUB_D_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_D(FD, FPR_D(FS) - FPR_D(FT));				\
    }
! DEFINST(FSUB_D,			0x73,
! 	"sub.d",		"D,S,T",
! 	FloatADD, 		F_FCOMP,
! 	DFPR_D(FD), DNA,	DFPR_D(FS), DFPR_D(FT), DNA)
  
+ #define FMUL_S_IMPL							\
+   {									\
+     if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
+       DECLARE_FAULT(md_fault_alignment);				\
+ 									\
+     SET_FPR_F(FD, FPR_F(FS) * FPR_F(FT));				\
+   }
+ DEFINST(FMUL_S,			0x74,
+ 	"mul.s",		"D,S,T",
+ 	FloatMULT, 		F_FCOMP|F_LONGLAT,
+ 	DFPR_F(FD), DNA,	DFPR_F(FS), DFPR_F(FT), DNA)
  
! #define FMUL_D_IMPL							\
!   {									\
!     if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_D(FD, FPR_D(FS) * FPR_D(FT));				\
!   }
! DEFINST(FMUL_D, 		0x75,
! 	"mul.d",		"D,S,T",
! 	FloatMULT, 		F_FCOMP|F_LONGLAT,
! 	DFPR_D(FD), DNA,	DFPR_D(FS), DFPR_D(FT), DNA)
  
! #define FDIV_S_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_F(FD, FPR_F(FS) / FPR_F(FT));				\
    }
! DEFINST(FDIV_S,			0x76,
! 	"div.s",		"D,S,T",
! 	FloatDIV,		F_FCOMP|F_LONGLAT,
! 	DFPR_F(FD), DNA,	DFPR_F(FS), DFPR_F(FT), DNA)
  
! #define FDIV_D_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01) || ((FT) & 01))			\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_D(FD, FPR_D(FS) / FPR_D(FT));				\
    }
! DEFINST(FDIV_D,			0x77,
! 	"div.d",		"D,S,T",
! 	FloatDIV,		F_FCOMP|F_LONGLAT,
! 	DFPR_D(FD), DNA,	DFPR_D(FS), DFPR_D(FT), DNA)
  
+ #define FABS_S_IMPL							\
+   {									\
+     if (((FD) & 01) || ((FS) & 01))					\
+       DECLARE_FAULT(md_fault_alignment);				\
+ 									\
+     SET_FPR_F(FD, (sfloat_t)fabs((dfloat_t)FPR_F(FS)));			\
+   }
+ DEFINST(FABS_S,			0x78,
+ 	"abs.s",		"D,S",
+ 	FloatADD,		F_FCOMP,
+ 	DFPR_F(FD), DNA,	DFPR_F(FS), DNA, DNA)
  
! #define FABS_D_IMPL							\
!   {									\
!     if (((FD) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_D(FD, fabs(FPR_D(FS)));					\
!   }
! DEFINST(FABS_D,			0x79,
! 	"abs.d",		"D,S",
! 	FloatADD,		F_FCOMP,
! 	DFPR_D(FD), DNA,	DFPR_D(FS), DNA, DNA)
  
! #define FMOV_S_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_F(FD, FPR_F(FS));						\
    }
! DEFINST(FMOV_S,			0x7a,
! 	"mov.s",		"D,S",
! 	FloatADD,		F_FCOMP,
! 	DFPR_F(FD), DNA,	DFPR_F(FS), DNA, DNA)
  
! #define FMOV_D_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_D(FD, FPR_D(FS));						\
    }
! DEFINST(FMOV_D,			0x7b,
! 	"mov.d",		"D,S",
! 	FloatADD,		F_FCOMP,
! 	DFPR_D(FD), DNA,	DFPR_D(FS), DNA, DNA)
  
+ #define FNEG_S_IMPL							\
+   {									\
+     if (((FD) & 01) || ((FS) & 01))					\
+       DECLARE_FAULT(md_fault_alignment);				\
+ 									\
+     SET_FPR_F(FD, -FPR_F(FS));						\
+   }
+ DEFINST(FNEG_S,			0x7c,
+ 	"neg.s",		"D,S",
+ 	FloatADD,		F_FCOMP,
+ 	DFPR_F(FD), DNA,	DFPR_F(FS), DNA, DNA)
  
! #define FNEG_D_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
  									\
!     SET_FPR_D(FD, -FPR_D(FS));						\
    }
! DEFINST(FNEG_D,			0x7d,
! 	"neg.d",		"D,S",
  	FloatADD,		F_FCOMP,
! 	DFPR_D(FD), DNA,	DFPR_D(FS), DNA, DNA)
  
! #define CVT_S_D_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_F(FD, (float)FPR_D(FS));					\
    }
! DEFINST(CVT_S_D,		0x80, 
! 	"cvt.s.d", 		"D,S",
! 	FloatCVT,		F_FCOMP,
! 	DFPR_F(FD), DNA,	DFPR_D(FS), DNA, DNA)
  
! #define CVT_S_W_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_F(FD, (float)FPR_L(FS));					\
    }
! DEFINST(CVT_S_W,		0x81,
! 	"cvt.s.w", 		"D,S",
! 	FloatCVT,		F_FCOMP,
! 	DFPR_F(FD), DNA,	DFPR_L(FS), DNA, DNA)
  
! #define CVT_D_S_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_D(FD, (dfloat_t)FPR_F(FS));					\
    }
! DEFINST(CVT_D_S,		0x82,
! 	"cvt.d.s",		"D,S",
! 	FloatCVT,		F_FCOMP,
! 	DFPR_D(FD), DNA,	DFPR_F(FS), DNA, DNA)
  
! #define CVT_D_W_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_D(FD, (dfloat_t)FPR_L(FS));					\
    }
! DEFINST(CVT_D_W,		0x83,
! 	"cvt.d.w",		"D,S",
! 	FloatCVT,		F_FCOMP,
! 	DFPR_D(FD), DNA,	DFPR_L(FS), DNA, DNA)
  
! #define CVT_W_S_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_L(FD, (sword_t)FPR_F(FS));					\
    }
! DEFINST(CVT_W_S,		0x84,
! 	"cvt.w.s", 		"D,S",
! 	FloatCVT,		F_FCOMP,
! 	DFPR_L(FD), DNA,	DFPR_F(FS), DNA, DNA)
  
! #define CVT_W_D_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_L(FD, (sword_t)FPR_D(FS));					\
    }
! DEFINST(CVT_W_D,		0x85,
! 	"cvt.w.d", 		"D,S",
! 	FloatCVT,		F_FCOMP,
! 	DFPR_L(FD), DNA,	DFPR_D(FS), DNA, DNA)
  
! #define C_EQ_S_IMPL							\
    {									\
!     if (((FS) & 01) || ((FT) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
  									\
!     SET_FCC(FPR_F(FS) == FPR_F(FT));					\
    }
! DEFINST(C_EQ_S,			0x90,
! 	"c.eq.s", 		"S,T",
! 	FloatCMP,		F_FCOMP,
! 	DFCC, DNA,		DFPR_F(FS), DFPR_F(FT), DNA)
  
! #define C_EQ_D_IMPL							\
    {									\
!     if (((FS) & 01) || ((FT) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
  									\
!     SET_FCC(FPR_D(FS) == FPR_D(FT));					\
    }
! DEFINST(C_EQ_D,			0x91,
! 	"c.eq.d", 		"S,T",
! 	FloatCMP,		F_FCOMP,
! 	DFCC, DNA,		DFPR_D(FS), DFPR_D(FT), DNA)
  
! #define C_LT_S_IMPL							\
    {									\
!     if (((FS) & 01) || ((FT) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
  									\
!     SET_FCC(FPR_F(FS) < FPR_F(FT));					\
    }
! DEFINST(C_LT_S,			0x92,
! 	"c.lt.s", 		"S,T",
! 	FloatCMP,		F_FCOMP,
! 	DFCC, DNA,		DFPR_F(FS), DFPR_F(FT), DNA)
  
! #define C_LT_D_IMPL							\
    {									\
!     if (((FS) & 01) || ((FT) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
  									\
!     SET_FCC(FPR_D(FS) < FPR_D(FT));					\
    }
! DEFINST(C_LT_D,			0x93,
! 	"c.lt.d", 		"S,T",
! 	FloatCMP,		F_FCOMP,
! 	DFCC, DNA,		DFPR_D(FS), DFPR_D(FT), DNA)
  
! #define C_LE_S_IMPL							\
    {									\
!     if (((FS) & 01) || ((FT) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
  									\
!     SET_FCC(FPR_F(FS) <= FPR_F(FT));					\
    }
! DEFINST(C_LE_S,			0x94,
! 	"c.le.s", 		"S,T",
! 	FloatCMP,		F_FCOMP,
! 	DFCC, DNA,		DFPR_F(FS), DFPR_F(FT), DNA)
  
! #define C_LE_D_IMPL							\
    {									\
!     if (((FS) & 01) || ((FT) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
  									\
!     SET_FCC(FPR_D(FS) <= FPR_D(FT));					\
    }
! DEFINST(C_LE_D,			0x95,
! 	"c.le.d", 		"S,T",
! 	FloatCMP,		F_FCOMP,
! 	DFCC, DNA,		DFPR_D(FS), DFPR_D(FT), DNA)
  
! #define FSQRT_S_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
  									\
!     SET_FPR_F(FD, (sfloat_t)sqrt((dfloat_t)FPR_F(FS)));			\
    }
! DEFINST(FSQRT_S,		0x96,
! 	"sqrt.s",		"D,S",
! 	FloatSQRT,		F_FCOMP|F_LONGLAT,
! 	DFPR_F(FD), DNA,	DFPR_F(FS), DNA, DNA)
  
! #define FSQRT_D_IMPL							\
    {									\
!     if (((FD) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
  									\
!     SET_FPR_D(FD, sqrt(FPR_D(FS)));					\
    }
! DEFINST(FSQRT_D,		0x97,
! 	"sqrt.d",		"D,S",
! 	FloatSQRT,		F_FCOMP|F_LONGLAT,
! 	DFPR_D(FD), DNA,	DFPR_D(FS), DNA, DNA)
  
  
! /*
!  * miscellaneous
!  */
  
! #define SYSCALL_IMPL							\
    {									\
!     SYSCALL(inst);							\
    }
! DEFINST(SYSCALL, 		0xa0,
! 	"syscall", 		"",
! 	NA, 			F_TRAP,
! 	DNA, DNA,		DNA, DNA, DNA)
  
! #define BREAK_IMPL							\
    {									\
!     /* NOTE: these are decoded speculatively, as they occur in integer	\
!        divide sequences, however, they should NEVER be executed under	\
!        non-exception conditions */					\
!     DECLARE_FAULT(md_fault_break);					\
    }
  
+ DEFINST(BREAK,			0xa1,
+ 	"break",		"B",
+ 	NA,			F_TRAP,
+ 	DNA, DNA,		DNA, DNA, DNA)
  
! #define LUI_IMPL							\
    {									\
!     SET_GPR(RT, UIMM << 16);						\
!   }
! DEFINST(LUI, 			0xa2,
! 	"lui",			"t,U",
  	IntALU,			F_ICOMP,
! 	DGPR(RT), DNA, 		DNA, DNA, DNA)
  
! #define MFC1_IMPL							\
    {									\
!     SET_GPR(RT, FPR_L(FS));						\
!   }
! DEFINST(MFC1,	 		0xa3,
! 	"mfc1", 		"t,S",
! 	IntALU, 		F_ICOMP,
! 	DGPR(RT), DNA,		DFPR_L(FS), DNA, DNA)
  
! #define DMFC1_IMPL							\
    {									\
!     if (((RT) & 01) || ((FS) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
  									\
!     SET_GPR(RT, FPR_L(FS));						\
!     SET_GPR((RT)+1, FPR_L((FS)+1));					\
!   }
! DEFINST(DMFC1, 			0xa7,
! 	"dmfc1",		"t,S",
  	IntALU,			F_ICOMP,
! 	DGPR_D(RT), DNA, 	DFPR_D(FS), DNA, DNA)
  
! #define CFC1_IMPL							\
    {									\
!     /* FIXME: is this needed??? */					\
    }
! DEFINST(CFC1, 			0xa4,
! 	"cfc1", 		"t,S",
! 	IntALU, 		F_ICOMP,
! 	DNA, DNA,		DNA, DNA, DNA)
  
! #define MTC1_IMPL							\
    {									\
!     SET_FPR_L(FS, GPR(RT));						\
    }
! DEFINST(MTC1, 			0xa5,
! 	"mtc1", 		"t,S",
! 	IntALU, 		F_ICOMP,
! 	DFPR_L(FS), DNA,	DGPR(RT), DNA, DNA)
  
! #define DMTC1_IMPL							\
    {									\
!     if (((FS) & 01) || ((RT) & 01))					\
!       DECLARE_FAULT(md_fault_alignment);				\
! 									\
!     SET_FPR_L(FS, GPR(RT));						\
!     SET_FPR_L((FS)+1, GPR((RT)+1));					\
    }
! DEFINST(DMTC1,	 		0xa8,
! 	"dmtc1",		"t,S",
  	IntALU,			F_ICOMP,
! 	DFPR_D(FS), DNA,	DGPR_D(RT), DNA, DNA)
  
! #define CTC1_IMPL							\
    {									\
!     /* FIXME: is this needed??? */					\
    }
! DEFINST(CTC1, 			0xa6,
! 	"ctc1", 		"t,S",
! 	IntALU, 		F_ICOMP,
! 	DNA, DNA,		DNA, DNA, DNA)
  
  
  /* clean up all definitions... */
! #undef NOP_IMPL
! #undef JUMP_IMPL
! #undef JAL_IMPL
! #undef JR_IMPL
! #undef JALR_IMPL
  #undef BEQ_IMPL
  #undef BNE_IMPL
! #undef BLEZ_IMPL
! #undef BGTZ_IMPL
! #undef BLTZ_IMPL
! #undef BGEZ_IMPL
! #undef BC1F_IMPL
! #undef BC1T_IMPL
! #undef LB_IMPL
! #undef LBU_IMPL
! #undef LH_IMPL
! #undef LHU_IMPL
! #undef LW_IMPL
! #undef DLW_IMPL
! #undef L_S_IMPL
! #undef L_D_IMPL
! #undef SB_IMPL
! #undef SH_IMPL
! #undef SW_IMPL
! #undef DSW_IMPL
! #undef DSZ_IMPL
! #undef S_S_IMPL
! #undef S_D_IMPL
! #undef LB_RR_IMPL
! #undef LBU_RR_IMPL
! #undef LH_RR_IMPL
! #undef LHU_RR_IMPL
! #undef LW_RR_IMPL
! #undef DLW_RR_IMPL
! #undef L_S_RR_IMPL
! #undef L_D_RR_IMPL
! #undef SB_RR_IMPL
! #undef SH_RR_IMPL
! #undef SW_RR_IMPL
! #undef DSW_RR_IMPL
! #undef DSZ_RR_IMPL
! #undef S_S_RR_IMPL
! #undef S_D_RR_IMPL
! #undef L_S_RR_R2_IMPL
! #undef S_S_RR_R2_IMPL
! #undef LW_RR_R2_IMPL
! #undef SW_RR_R2_IMPL
! #undef ADD_IMPL
! #undef ADDI_IMPL
! #undef ADDU_IMPL
! #undef ADDIU_IMPL
! #undef SUB_IMPL
! #undef SUBU_IMPL
! #undef MULT_IMPL
! #undef MULTU_IMPL
! #undef DIV_IMPL
! #undef DIVU_IMPL
! #undef MFHI_IMPL
! #undef MTHI_IMPL
! #undef MFLO_IMPL
! #undef MTLO_IMPL
! #undef AND__IMPL
  #undef ANDI_IMPL
! #undef OR_IMPL
! #undef ORI_IMPL
  #undef XOR_IMPL
  #undef XORI_IMPL
! #undef NOR_IMPL
  #undef SLL_IMPL
! #undef SLLV_IMPL
! #undef SRL_IMPL
! #undef SRLV_IMPL
  #undef SRA_IMPL
! #undef SRAV_IMPL
! #undef SLT_IMPL
! #undef SLTI_IMPL
! #undef SLTU_IMPL
! #undef SLTIU_IMPL
! #undef FADD_S_IMPL
! #undef FADD_D_IMPL
! #undef FSUB_S_IMPL
! #undef FSUB_D_IMPL
! #undef FMUL_S_IMPL
! #undef FMUL_D_IMPL
! #undef FDIV_S_IMPL
! #undef FDIV_D_IMPL
! #undef FABS_S_IMPL
! #undef FABS_D_IMPL
! #undef FMOV_S_IMPL
! #undef FMOV_D_IMPL
! #undef FNEG_S_IMPL
! #undef FNEG_D_IMPL
! #undef CVT_S_D_IMPL
! #undef CVT_S_W_IMPL
! #undef CVT_D_S_IMPL
! #undef CVT_D_W_IMPL
! #undef CVT_W_S_IMPL
! #undef CVT_W_D_IMPL
! #undef C_EQ_S_IMPL
! #undef C_EQ_D_IMPL
! #undef C_LT_S_IMPL
! #undef C_LT_D_IMPL
! #undef C_LE_S_IMPL
! #undef C_LE_D_IMPL
! #undef FSQRT_S_IMPL
! #undef FSQRT_D_IMPL
! #undef SYSCALL_IMPL
! #undef BREAK_IMPL
! #undef LUI_IMPL
! #undef MFC1_IMPL
! #undef DMFC1_IMPL
! #undef CFC1_IMPL
! #undef MTC1_IMPL
! #undef DMTC1_IMPL
! #undef CTC1_IMPL
  
  #undef DEFINST
  #undef DEFLINK
diff -crB tmp/simplesim-3.0/machine.h simplesim-3.0/machine.h
*** tmp/simplesim-3.0/machine.h	2011-03-11 22:46:51.000000000 -0600
--- simplesim-3.0/machine.h	2003-10-08 21:23:34.000000000 -0500
***************
*** 1,4 ****
! /* alpha.h - Alpha ISA definitions */
  
  /* SimpleScalar(TM) Tool Suite
   * Copyright (C) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
--- 1,4 ----
! /* pisa.h - SimpleScaler portable ISA (pisa) definitions */
  
  /* SimpleScalar(TM) Tool Suite
   * Copyright (C) 1994-2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.
***************
*** 49,56 ****
   */
  
  
! #ifndef ALPHA_H
! #define ALPHA_H
  
  #include <stdio.h>
  
--- 49,56 ----
   */
  
  
! #ifndef PISA_H
! #define PISA_H
  
  #include <stdio.h>
  
***************
*** 59,75 ****
  #include "config.h"
  #include "endian.h"
  
- 
  /*
   * This file contains various definitions needed to decode, disassemble, and
!  * execute Alpha AXP instructions.
   */
  
! /* build for Alpha AXP target */
! #define TARGET_ALPHA
  
  /* probe cross-endian execution */
! #if defined(BYTES_BIG_ENDIAN)
  #define MD_CROSS_ENDIAN
  #endif
  
--- 59,88 ----
  #include "config.h"
  #include "endian.h"
  
  /*
   * This file contains various definitions needed to decode, disassemble, and
!  * execute PISA (portable ISA) instructions.
   */
  
! /* build for PISA target */
! #define TARGET_PISA
! 
! #ifndef TARGET_PISA_BIG
! #ifndef TARGET_PISA_LITTLE
! /* no cross-endian support, default to host endian */
! #ifdef BYTES_BIG_ENDIAN
! #define TARGET_PISA_BIG
! #else
! #define TARGET_PISA_LITTLE
! #endif
! #endif /* TARGET_PISA_LITTLE */
! #endif /* TARGET_PISA_BIG */
  
  /* probe cross-endian execution */
! #if defined(BYTES_BIG_ENDIAN) && defined(TARGET_PISA_LITTLE)
! #define MD_CROSS_ENDIAN
! #endif
! #if defined(BYTES_LITTLE_ENDIAN) && defined(TARGET_PISA_BIG)
  #define MD_CROSS_ENDIAN
  #endif
  
***************
*** 81,90 ****
   */
  
  /* define MD_QWORD_ADDRS if the target requires 64-bit (qword) addresses */
! #define MD_QWORD_ADDRS
  
  /* address type definition */
! typedef qword_t md_addr_t;
  
  
  /*
--- 94,103 ----
   */
  
  /* define MD_QWORD_ADDRS if the target requires 64-bit (qword) addresses */
! #undef MD_QWORD_ADDRS
  
  /* address type definition */
! typedef word_t md_addr_t;
  
  
  /*
***************
*** 92,99 ****
   */
  
  /* physical memory page size (must be a power-of-two) */
! #define MD_PAGE_SIZE		8192
! #define MD_LOG_PAGE_SIZE	13
  
  
  /*
--- 105,112 ----
   */
  
  /* physical memory page size (must be a power-of-two) */
! #define MD_PAGE_SIZE		4096
! #define MD_LOG_PAGE_SIZE	12
  
  
  /*
***************
*** 106,113 ****
    md_fault_alignment,		/* storage alignment fault */
    md_fault_overflow,		/* signed arithmetic overflow fault */
    md_fault_div0,		/* division by zero fault */
-   md_fault_invalid,             /* invalid arithmetic operation */ 
-                                 /* added to allow SQRT{S,T} in FIX exts */
    md_fault_break,		/* BREAK instruction fault */
    md_fault_unimpl,		/* unimplemented instruction fault */
    md_fault_internal		/* internal S/W fault */
--- 119,124 ----
***************
*** 125,166 ****
  #define MD_NUM_FREGS		32
  
  /* number of control registers */
! #define MD_NUM_CREGS		2
  
  /* total number of registers, excluding PC and NPC */
  #define MD_TOTAL_REGS							\
!   (/*int*/32 + /*fp*/32 + /*misc*/2 + /*tmp*/1 + /*mem*/1 + /*ctrl*/1)
  
  /* general purpose (integer) register file entry type */
! typedef qword_t md_gpr_t[MD_NUM_IREGS];
  
  /* floating point register file entry type */
  typedef union {
!   qword_t q[MD_NUM_FREGS];	/* integer qword view */
!   dfloat_t d[MD_NUM_FREGS];	/* double-precision floating point view */
  } md_fpr_t;
  
  /* control register file contents */
  typedef struct {
!   qword_t fpcr;			/* floating point condition codes */
!   qword_t uniq;			/* process-unique register */
  } md_ctrl_t;
  
  /* well known registers */
  enum md_reg_names {
!   MD_REG_V0 = 0,	/* return value reg */
!   MD_REG_ERR = 7,
!   MD_REG_FP = 15,	/* frame pointer */
!   MD_REG_A0 = 16,	/* argument regs */
!   MD_REG_A1 = 17,
!   MD_REG_A2 = 18,
!   MD_REG_A3 = 19,
!   MD_REG_A4 = 20,
!   MD_REG_A5 = 21,
!   MD_REG_RA = 26,	/* return address reg */
!   MD_REG_GP = 29,	/* global data section pointer */
!   MD_REG_SP = 30,	/* stack pointer */
!   MD_REG_ZERO = 31	/* zero register */
  };
  
  
--- 136,169 ----
  #define MD_NUM_FREGS		32
  
  /* number of control registers */
! #define MD_NUM_CREGS		3
  
  /* total number of registers, excluding PC and NPC */
  #define MD_TOTAL_REGS							\
!   (/*int*/32 + /*fp*/32 + /*misc*/3 + /*tmp*/1 + /*mem*/1 + /*ctrl*/1)
  
  /* general purpose (integer) register file entry type */
! typedef sword_t md_gpr_t[MD_NUM_IREGS];
  
  /* floating point register file entry type */
  typedef union {
!   sword_t l[MD_NUM_FREGS];	/* integer word view */
!   sfloat_t f[MD_NUM_FREGS];	/* single-precision floating point view */
!   dfloat_t d[MD_NUM_FREGS/2];	/* double-prediction floating point view */
  } md_fpr_t;
  
  /* control register file contents */
  typedef struct {
!   sword_t hi, lo;		/* multiplier HI/LO result registers */
!   int fcc;			/* floating point condition codes */
  } md_ctrl_t;
  
  /* well known registers */
  enum md_reg_names {
!   MD_REG_ZERO = 0,	/* zero register */
!   MD_REG_GP = 28,	/* global data section pointer */
!   MD_REG_SP = 29,	/* stack pointer */
!   MD_REG_FP = 30	/* frame pointer */
  };
  
  
***************
*** 169,175 ****
   */
  
  /* instruction formats */
! typedef word_t md_inst_t;
  
  /* preferred nop instruction definition */
  extern md_inst_t MD_NOP_INST;
--- 172,181 ----
   */
  
  /* instruction formats */
! typedef struct {
!   word_t a;		/* simplescalar opcode (must be unsigned) */
!   word_t b;		/* simplescalar unsigned immediate fields */
! } md_inst_t;
  
  /* preferred nop instruction definition */
  extern md_inst_t MD_NOP_INST;
***************
*** 180,186 ****
  #define MD_SWAPH(X)		SWAP_HALF(X)
  #define MD_SWAPW(X)		SWAP_WORD(X)
  #define MD_SWAPQ(X)		SWAP_QWORD(X)
! #define MD_SWAPI(X)		SWAP_WORD(X)
  
  #else /* !MD_CROSS_ENDIAN */
  
--- 186,193 ----
  #define MD_SWAPH(X)		SWAP_HALF(X)
  #define MD_SWAPW(X)		SWAP_WORD(X)
  #define MD_SWAPQ(X)		SWAP_QWORD(X)
! #define MD_SWAPI(X)		((X).a = SWAP_WORD((X).a),		\
! 				 (X).b = SWAP_WORD((X).b))
  
  #else /* !MD_CROSS_ENDIAN */
  
***************
*** 194,205 ****
  
  /* fetch an instruction */
  #define MD_FETCH_INST(INST, MEM, PC)					\
!   { (INST) = MEM_READ_WORD((MEM), (PC)); }
  
  /*
   * target-dependent loader module configuration
   */
  
  /* maximum size of argc+argv+envp environment */
  #define MD_MAX_ENVIRON		16384
  
--- 201,218 ----
  
  /* fetch an instruction */
  #define MD_FETCH_INST(INST, MEM, PC)					\
!   { inst.a = MEM_READ_WORD(mem, (PC));					\
!     inst.b = MEM_READ_WORD(mem, (PC) + sizeof(word_t)); }
  
  /*
   * target-dependent loader module configuration
   */
  
+ /* virtual memory segment limits */
+ #define MD_TEXT_BASE		0x00400000
+ #define MD_DATA_BASE		0x10000000
+ #define MD_STACK_BASE 		0x7fffc000
+ 
  /* maximum size of argc+argv+envp environment */
  #define MD_MAX_ENVIRON		16384
  
***************
*** 208,224 ****
   * machine.def specific definitions
   */
  
! /* inst -> enum md_opcode mapping, use this macro to decode insts */
! #define MD_TOP_OP(INST)		(((INST) >> 26) & 0x3f)
! #define MD_SET_OPCODE(OP, INST)						\
!   { OP = md_mask2op[MD_TOP_OP(INST)];					\
!     while (md_opmask[OP])						\
!       OP = md_mask2op[((INST >> md_opshift[OP]) & md_opmask[OP])	\
! 		      + md_opoffset[OP]]; }
  
  /* largest opcode field value (currently upper 8-bit are used for pre/post-
!     incr/decr operation specifiers */
! #define MD_MAX_MASK		2048
  
  /* global opcode names, these are returned by the decoder (MD_OP_ENUM()) */
  enum md_opcode {
--- 221,233 ----
   * machine.def specific definitions
   */
  
! /* returns the opcode field value of SimpleScalar instruction INST */
! #define MD_OPFIELD(INST)		(INST.a & 0xff)
! #define MD_SET_OPCODE(OP, INST)	((OP) = ((INST).a & 0xff))
  
  /* largest opcode field value (currently upper 8-bit are used for pre/post-
!    incr/decr operation specifiers */
! #define MD_MAX_MASK		255
  
  /* global opcode names, these are returned by the decoder (MD_OP_ENUM()) */
  enum md_opcode {
***************
*** 230,240 ****
    OP_MAX	/* number of opcodes + NA */
  };
  
! /* internal decoder state */
  extern enum md_opcode md_mask2op[];
- extern unsigned int md_opoffset[];
- extern unsigned int md_opmask[];
- extern unsigned int md_opshift[];
  
  /* enum md_opcode -> description string */
  #define MD_OP_NAME(OP)		(md_op2name[OP])
--- 239,247 ----
    OP_MAX	/* number of opcodes + NA */
  };
  
! /* inst -> enum md_opcode mapping, use this macro to decode insts */
! #define MD_OP_ENUM(MSK)		(md_mask2op[MSK])
  extern enum md_opcode md_mask2op[];
  
  /* enum md_opcode -> description string */
  #define MD_OP_NAME(OP)		(md_op2name[OP])
***************
*** 246,252 ****
  
  /* function unit classes, update md_fu2name if you update this definition */
  enum md_fu_class {
!   FUClamd_NA = 0,	/* inst does not use a functional unit */
    IntALU,		/* integer ALU */
    IntMULT,		/* integer multiplier */
    IntDIV,		/* integer divider */
--- 253,259 ----
  
  /* function unit classes, update md_fu2name if you update this definition */
  enum md_fu_class {
!   FUClass_NA = 0,	/* inst does not use a functional unit */
    IntALU,		/* integer ALU */
    IntMULT,		/* integer multiplier */
    IntDIV,		/* integer divider */
***************
*** 293,367 ****
  #define MD_OP_FLAGS(OP)		(md_op2flags[OP])
  extern unsigned int md_op2flags[];
  
- 
  /* integer register specifiers */
! #define RA		((inst >> 21) & 0x1f)		/* reg source #1 */
! #define RB		((inst >> 16) & 0x1f)		/* reg source #2 */
! #define RC		(inst & 0x1f)			/* reg dest */
! 
! /* returns 8-bit unsigned immediate field value */
! #define IMM		((qword_t)((inst >> 13) & 0xff))
! 
! /* returns 21-bit unsigned absolute jump target field value */
! #define TARG		(inst & 0x1fffff)
! 
! /* load/store 16-bit unsigned offset field value */
! #define OFS		(inst & 0xffff)
! 
! /* sign-extend operands */
! #define SEXT(X)								\
!   (((X) & 0x8000) ? ((sqword_t)(X) | LL(0xffffffffffff0000)) : (sqword_t)(X))
! 
! #define SEXT21(X)							\
!   (((X) & 0x100000) ? ((sqword_t)(X) | LL(0xffffffffffe00000)) : (sqword_t)(X))
! 
! #define SEXT32(X)							\
!   (((X) & 0x80000000) ? ((sqword_t)(X)|LL(0xffffffff00000000)) : (sqword_t)(X))
! 
! /* test for arithmetic overflow */
! #define ARITH_OVFL(RESULT, OP1, OP2) ((RESULT) < (OP1) || (RESULT) < (OP2))
! 
! /* test for NaN */
! #define IEEEFP_DBL_SIGN(Q)	((Q) >> 63)
! #define IEEEFP_DBL_EXPONENT(Q)	(((Q) >> 52) & 0x7ff)
! #define IEEEFP_DBL_FRACTION(Q)	((Q) & ULL(0xfffffffffffff))
! #define IS_IEEEFP_DBL_NAN(Q)						\
!   ((IEEEFP_DBL_EXPONENT(Q) == 0x7ff) && (IEEEFP_DBL_FRACTION(Q)))
  
  /* default target PC handling */
  #ifndef SET_TPC
  #define SET_TPC(PC)	(void)0
  #endif /* SET_TPC */
  
  
  /*
   * various other helper macros/functions
   */
  
  /* non-zero if system call is an exit() */
! #define OSF_SYS_exit			1
! #define MD_EXIT_SYSCALL(REGS)						\
!   ((REGS)->regs_R[MD_REG_V0] == OSF_SYS_exit)
  
  /* non-zero if system call is a write to stdout/stderr */
! #define OSF_SYS_write			4
  #define MD_OUTPUT_SYSCALL(REGS)						\
!   ((REGS)->regs_R[MD_REG_V0] == OSF_SYS_write				\
!    && ((REGS)->regs_R[MD_REG_A0] == /* stdout */1			\
!        || (REGS)->regs_R[MD_REG_A0] == /* stderr */2))
  
  /* returns stream of an output system call, translated to host */
! #define MD_STREAM_FILENO(REGS)		((REGS)->regs_R[MD_REG_A0])
  
  /* returns non-zero if instruction is a function call */
! #define MD_IS_CALL(OP)			((OP) == JSR || (OP) == BSR)
  
  /* returns non-zero if instruction is a function return */
! #define MD_IS_RETURN(OP)		((OP) == RETN)
  
  /* returns non-zero if instruction is an indirect jump */
! #define MD_IS_INDIR(OP)							\
!   ((OP) == JMP || (OP) == JSR || (OP) == RETN || (OP) == JSR_COROUTINE)
  
  /* addressing mode probe, enums and strings */
  enum md_amode_type {
--- 300,440 ----
  #define MD_OP_FLAGS(OP)		(md_op2flags[OP])
  extern unsigned int md_op2flags[];
  
  /* integer register specifiers */
! #undef  RS	/* defined in /usr/include/sys/syscall.h on HPUX boxes */
! #define RS		(inst.b >> 24)			/* reg source #1 */
! #define RT		((inst.b >> 16) & 0xff)		/* reg source #2 */
! #define RD		((inst.b >> 8) & 0xff)		/* reg dest */
! 
! /* returns shift amount field value */
! #define SHAMT		(inst.b & 0xff)
! 
! /* floating point register field synonyms */
! #define FS		RS
! #define FT		RT
! #define FD		RD
! 
! /* returns 16-bit signed immediate field value */
! #define IMM		((int)((/* signed */short)(inst.b & 0xffff)))
! 
! /* returns 16-bit unsigned immediate field value */
! #define UIMM		(inst.b & 0xffff)
! 
! /* returns 26-bit unsigned absolute jump target field value */
! #define TARG		(inst.b & 0x3ffffff)
! 
! /* returns break code immediate field value */
! #define BCODE		(inst.b & 0xfffff)
! 
! /* load/store 16-bit signed offset field value, synonym for imm field */
! #define OFS		IMM		/* alias to IMM */
! 
! /* load/store base register specifier, synonym for RS field */
! #define BS		RS		/* alias to rs */
! 
! /* largest signed integer */
! #define MAXINT_VAL	0x7fffffff
! 
! /* check for overflow in X+Y, both signed */
! #define OVER(X,Y)							\
!   ((((X) > 0) && ((Y) > 0) && (MAXINT_VAL - (X) < (Y)))			\
!    || (((X) < 0) && ((Y) < 0) && (-MAXINT_VAL - (X) > (Y))))
! 
! /* check for underflow in X-Y, both signed */
! #define UNDER(X,Y)							\
!   ((((X) > 0) && ((Y) < 0) && (MAXINT_VAL + (Y) < (X)))			\
!    || (((X) < 0) && ((Y) > 0) && (-MAXINT_VAL + (Y) > (X))))
  
  /* default target PC handling */
  #ifndef SET_TPC
  #define SET_TPC(PC)	(void)0
  #endif /* SET_TPC */
  
+ #ifdef BYTES_BIG_ENDIAN
+ /* lwl/swl defs */
+ #define WL_SIZE(ADDR)		((ADDR) & 0x03)
+ #define WL_BASE(ADDR)		((ADDR) & ~0x03)
+ #define WL_PROT_MASK(ADDR)	(md_lr_masks[4-WL_SIZE(ADDR)])
+ #define WL_PROT_MASK1(ADDR)	(md_lr_masks[WL_SIZE(ADDR)])
+ #define WL_PROT_MASK2(ADDR)	(md_lr_masks[4-WL_SIZE(ADDR)])
+ 
+ /* lwr/swr defs */
+ #define WR_SIZE(ADDR)		(((ADDR) & 0x03)+1)
+ #define WR_BASE(ADDR)		((ADDR) & ~0x03)
+ #define WR_PROT_MASK(ADDR)	(~(md_lr_masks[WR_SIZE(ADDR)]))
+ #define WR_PROT_MASK1(ADDR)	((md_lr_masks[WR_SIZE(ADDR)]))
+ #define WR_PROT_MASK2(ADDR)	(md_lr_masks[4-WR_SIZE(ADDR)])
+ #else /* BYTES_LITTLE_ENDIAN */
+ /* lwl/swl defs */
+ #define WL_SIZE(ADDR)		(4-((ADDR) & 0x03))
+ #define WL_BASE(ADDR)		((ADDR) & ~0x03)
+ #define WL_PROT_MASK(ADDR)	(md_lr_masks[4-WL_SIZE(ADDR)])
+ #define WL_PROT_MASK1(ADDR)	(md_lr_masks[WL_SIZE(ADDR)])
+ #define WL_PROT_MASK2(ADDR)	(md_lr_masks[4-WL_SIZE(ADDR)])
+ 
+ /* lwr/swr defs */
+ #define WR_SIZE(ADDR)		(((ADDR) & 0x03)+1)
+ #define WR_BASE(ADDR)		((ADDR) & ~0x03)
+ #define WR_PROT_MASK(ADDR)	(~(md_lr_masks[WR_SIZE(ADDR)]))
+ #define WR_PROT_MASK1(ADDR)	((md_lr_masks[WR_SIZE(ADDR)]))
+ #define WR_PROT_MASK2(ADDR)	(md_lr_masks[4-WR_SIZE(ADDR)])
+ #endif
+   
+ /* mask table used to speed up LWL/LWR implementation */
+ extern word_t md_lr_masks[];
+ 
+ #if 0
+ /* lwl/swl defs */
+ #define WL_SIZE(ADDR)       (4-((ADDR) & 0x03))
+ #define WL_BASE(ADDR)       ((ADDR) & ~0x03)
+ #define WL_PROT_MASK(ADDR)  (md_lr_masks[4-WL_SIZE(ADDR)])
+ 
+ /* lwr/swr defs */
+ #define WR_SIZE(ADDR)       (((ADDR) & 0x03)+1)
+ #define WR_BASE(ADDR)       ((ADDR) & ~0x03)
+ #define WR_PROT_MASK(ADDR)  (~(md_lr_masks[WR_SIZE(ADDR)]))
+ /* #else */
+ /* lwl/swl stuff */
+ #define WL_SIZE(ADDR)		((ADDR) & 0x03)
+ #define WL_BASE(ADDR)		((ADDR) & ~0x03)
+ #define WL_PROT_MASK1(ADDR)	(md_lr_masks[WL_SIZE(ADDR)])
+ #define WL_PROT_MASK2(ADDR)	(md_lr_masks[4-WL_SIZE(ADDR)])
+ 
+ /* lwr/swr stuff */
+ #define WR_SIZE(ADDR)		(((ADDR) & 0x03)+1)
+ #define WR_BASE(ADDR)		((ADDR) & ~0x03)
+ #define WR_PROT_MASK1(ADDR)	((md_lr_masks[WR_SIZE(ADDR)]))
+ #define WR_PROT_MASK2(ADDR)	(md_lr_masks[4-WR_SIZE(ADDR)])
+ #endif
+ 
  
  /*
   * various other helper macros/functions
   */
  
  /* non-zero if system call is an exit() */
! #define	SS_SYS_exit			1
! #define MD_EXIT_SYSCALL(REGS)		((REGS)->regs_R[2] == SS_SYS_exit)
  
  /* non-zero if system call is a write to stdout/stderr */
! #define	SS_SYS_write		4
  #define MD_OUTPUT_SYSCALL(REGS)						\
!   ((REGS)->regs_R[2] == SS_SYS_write					\
!    && ((REGS)->regs_R[4] == /* stdout */1				\
!        || (REGS)->regs_R[4] == /* stderr */2))
  
  /* returns stream of an output system call, translated to host */
! #define MD_STREAM_FILENO(REGS)		((REGS)->regs_R[4])
  
  /* returns non-zero if instruction is a function call */
! #define MD_IS_CALL(OP)							\
!   ((MD_OP_FLAGS(OP) & (F_CTRL|F_CALL)) == (F_CTRL|F_CALL))
  
  /* returns non-zero if instruction is a function return */
! #define MD_IS_RETURN(OP)		((OP) == JR && (RS) == 31)
  
  /* returns non-zero if instruction is an indirect jump */
! #define MD_IS_INDIR(OP)			((OP) == JR)
  
  /* addressing mode probe, enums and strings */
  enum md_amode_type {
***************
*** 376,393 ****
  extern char *md_amode_str[md_amode_NUM];
  
  /* addressing mode pre-probe FSM, must see all instructions */
! #define MD_AMODE_PREPROBE(OP, FSM)		{ (FSM) = 0; }
  
  /* compute addressing mode, only for loads/stores */
  #define MD_AMODE_PROBE(AM, OP, FSM)					\
    {									\
      if (MD_OP_FLAGS(OP) & F_DISP)					\
        {									\
! 	if ((RB) == MD_REG_GP)						\
  	  (AM) = md_amode_gp;						\
! 	else if ((RB) == MD_REG_SP)					\
  	  (AM) = md_amode_sp;						\
! 	else if ((RB) == MD_REG_FP) /* && bind_to_seg(addr) == seg_stack */\
  	  (AM) = md_amode_fp;						\
  	else								\
  	  (AM) = md_amode_disp;						\
--- 449,469 ----
  extern char *md_amode_str[md_amode_NUM];
  
  /* addressing mode pre-probe FSM, must see all instructions */
! #define MD_AMODE_PREPROBE(OP, FSM)					\
!   { if ((OP) == LUI) (FSM) = (RT); }
  
  /* compute addressing mode, only for loads/stores */
  #define MD_AMODE_PROBE(AM, OP, FSM)					\
    {									\
      if (MD_OP_FLAGS(OP) & F_DISP)					\
        {									\
! 	if ((BS) == (FSM))						\
! 	  (AM) = md_amode_imm;						\
! 	else if ((BS) == MD_REG_GP)					\
  	  (AM) = md_amode_gp;						\
! 	else if ((BS) == MD_REG_SP)					\
  	  (AM) = md_amode_sp;						\
! 	else if ((BS) == MD_REG_FP) /* && bind_to_seg(addr) == seg_stack */\
  	  (AM) = md_amode_fp;						\
  	else								\
  	  (AM) = md_amode_disp;						\
***************
*** 399,405 ****
    }
  
  /* addressing mode pre-probe FSM, after all loads and stores */
! #define MD_AMODE_POSTPROBE(FSM)			/* nada... */
  
  
  /*
--- 475,482 ----
    }
  
  /* addressing mode pre-probe FSM, after all loads and stores */
! #define MD_AMODE_POSTPROBE(FSM)						\
!   { (FSM) = MD_REG_ZERO; }
  
  
  /*
***************
*** 407,428 ****
   */
  
  /* expected EIO file format */
! #define MD_EIO_FILE_FORMAT		EIO_ALPHA_FORMAT
  
  #define MD_MISC_REGS_TO_EXO(REGS)					\
    exo_new(ec_list,							\
  	  /*icnt*/exo_new(ec_integer, (exo_integer_t)sim_num_insn),	\
  	  /*PC*/exo_new(ec_address, (exo_integer_t)(REGS)->regs_PC),	\
  	  /*NPC*/exo_new(ec_address, (exo_integer_t)(REGS)->regs_NPC),	\
! 	  /*FPCR*/exo_new(ec_integer, (exo_integer_t)(REGS)->regs_C.fpcr),\
! 	  /*UNIQ*/exo_new(ec_integer, (exo_integer_t)(REGS)->regs_C.uniq),\
  	  NULL)
  
  #define MD_IREG_TO_EXO(REGS, IDX)					\
    exo_new(ec_address, (exo_integer_t)(REGS)->regs_R[IDX])
  
  #define MD_FREG_TO_EXO(REGS, IDX)					\
!   exo_new(ec_address, (exo_integer_t)(REGS)->regs_F.q[IDX])
  
  #define MD_EXO_TO_MISC_REGS(EXO, ICNT, REGS)				\
    /* check EXO format for errors... */					\
--- 484,506 ----
   */
  
  /* expected EIO file format */
! #define MD_EIO_FILE_FORMAT		EIO_PISA_FORMAT
  
  #define MD_MISC_REGS_TO_EXO(REGS)					\
    exo_new(ec_list,							\
  	  /*icnt*/exo_new(ec_integer, (exo_integer_t)sim_num_insn),	\
  	  /*PC*/exo_new(ec_address, (exo_integer_t)(REGS)->regs_PC),	\
  	  /*NPC*/exo_new(ec_address, (exo_integer_t)(REGS)->regs_NPC),	\
! 	  /*HI*/exo_new(ec_integer, (exo_integer_t)(REGS)->regs_C.hi),	\
! 	  /*LO*/exo_new(ec_integer, (exo_integer_t)(REGS)->regs_C.lo),	\
! 	  /*FCC*/exo_new(ec_integer, (exo_integer_t)(REGS)->regs_C.fcc),\
  	  NULL)
  
  #define MD_IREG_TO_EXO(REGS, IDX)					\
    exo_new(ec_address, (exo_integer_t)(REGS)->regs_R[IDX])
  
  #define MD_FREG_TO_EXO(REGS, IDX)					\
!   exo_new(ec_address, (exo_integer_t)(REGS)->regs_F.l[IDX])
  
  #define MD_EXO_TO_MISC_REGS(EXO, ICNT, REGS)				\
    /* check EXO format for errors... */					\
***************
*** 438,468 ****
        || exo->as_list.head->next->next->next->ec != ec_integer		\
        || !exo->as_list.head->next->next->next->next			\
        || exo->as_list.head->next->next->next->next->ec != ec_integer	\
!       || exo->as_list.head->next->next->next->next->next != NULL)	\
      fatal("could not read EIO misc regs");				\
    (ICNT) = (counter_t)exo->as_list.head->as_integer.val;		\
!   (REGS)->regs_PC = (md_addr_t)exo->as_list.head->next->as_integer.val;	\
    (REGS)->regs_NPC =							\
!     (md_addr_t)exo->as_list.head->next->next->as_integer.val;		\
!   (REGS)->regs_C.fpcr =							\
!     (qword_t)exo->as_list.head->next->next->next->as_integer.val;	\
!   (REGS)->regs_C.uniq =							\
!     (qword_t)exo->as_list.head->next->next->next->next->as_integer.val;
  
  #define MD_EXO_TO_IREG(EXO, REGS, IDX)					\
!   ((REGS)->regs_R[IDX] = (qword_t)(EXO)->as_integer.val)
  
  #define MD_EXO_TO_FREG(EXO, REGS, IDX)					\
!   ((REGS)->regs_F.q[IDX] = (qword_t)(EXO)->as_integer.val)
  
  #define MD_EXO_CMP_IREG(EXO, REGS, IDX)					\
!   ((REGS)->regs_R[IDX] != (qword_t)(EXO)->as_integer.val)
  
! #define MD_FIRST_IN_REG			0
! #define MD_LAST_IN_REG			21
  
! #define MD_FIRST_OUT_REG		0
! #define MD_LAST_OUT_REG			21
  
  
  /*
--- 516,550 ----
        || exo->as_list.head->next->next->next->ec != ec_integer		\
        || !exo->as_list.head->next->next->next->next			\
        || exo->as_list.head->next->next->next->next->ec != ec_integer	\
!       || !exo->as_list.head->next->next->next->next->next		\
!       || exo->as_list.head->next->next->next->next->next->ec != ec_integer\
!       || exo->as_list.head->next->next->next->next->next->next != NULL)	\
      fatal("could not read EIO misc regs");				\
    (ICNT) = (counter_t)exo->as_list.head->as_integer.val;		\
!   (REGS)->regs_PC = (md_addr_t)exo->as_list.head->next->as_address.val;	\
    (REGS)->regs_NPC =							\
!     (md_addr_t)exo->as_list.head->next->next->as_address.val;		\
!   (REGS)->regs_C.hi =							\
!     (word_t)exo->as_list.head->next->next->next->as_integer.val;	\
!   (REGS)->regs_C.lo =							\
!     (word_t)exo->as_list.head->next->next->next->next->as_integer.val;	\
!   (REGS)->regs_C.fcc =							\
!     (int)exo->as_list.head->next->next->next->next->next->as_integer.val;
  
  #define MD_EXO_TO_IREG(EXO, REGS, IDX)					\
!   ((REGS)->regs_R[IDX] = (word_t)(EXO)->as_integer.val)
  
  #define MD_EXO_TO_FREG(EXO, REGS, IDX)					\
!   ((REGS)->regs_F.l[IDX] = (word_t)(EXO)->as_integer.val)
  
  #define MD_EXO_CMP_IREG(EXO, REGS, IDX)					\
!   ((REGS)->regs_R[IDX] != (sword_t)(EXO)->as_integer.val)
  
! #define MD_FIRST_IN_REG			2
! #define MD_LAST_IN_REG			7
  
! #define MD_FIRST_OUT_REG		2
! #define MD_LAST_OUT_REG			7
  
  
  /*
***************
*** 484,495 ****
   */
  
  /* counter stats */
  #define stat_reg_counter		stat_reg_sqword
  #define sc_counter			sc_sqword
  #define for_counter			for_sqword
  
  /* address stats */
! #define stat_reg_addr			stat_reg_qword
  
  
  /*
--- 566,583 ----
   */
  
  /* counter stats */
+ #ifdef HOST_HAS_QWORD
  #define stat_reg_counter		stat_reg_sqword
  #define sc_counter			sc_sqword
  #define for_counter			for_sqword
+ #else /* !HOST_HAS_QWORD */
+ #define stat_reg_counter		stat_reg_double
+ #define sc_counter			sc_double
+ #define for_counter			for_double
+ #endif /* HOST_HAS_QWORD */
  
  /* address stats */
! #define stat_reg_addr			stat_reg_uint
  
  
  /*
***************
*** 543,548 ****
--- 631,639 ----
  void md_print_creg(md_ctrl_t regs, int reg, FILE *stream);
  void md_print_cregs(md_ctrl_t regs, FILE *stream);
  
+ /* compute CRC of all registers */
+ word_t md_crc_regs(struct regs_t *regs);
+ 
  /* xor checksum registers */
  word_t md_xor_regs(struct regs_t *regs);
  
***************
*** 552,568 ****
   */
  
  /* primitive operation used to compute addresses within pipeline */
! #define MD_AGEN_OP		ADDQ
  
  /* NOP operation when injected into the pipeline */
! #define MD_NOP_OP		OP_NA
  
  /* non-zero for a valid address, used to determine if speculative accesses
     should access the DL1 data cache */
  #define MD_VALID_ADDR(ADDR)						\
    (((ADDR) >= ld_text_base && (ADDR) < (ld_text_base + ld_text_size))	\
!    || ((ADDR) >= ld_data_base && (ADDR) < ld_brk_point)			\
!    || ((ADDR) >= (ld_stack_base - 16*1024*1024) && (ADDR) < ld_stack_base))
  
  /*
   * configure branch predictors
--- 643,659 ----
   */
  
  /* primitive operation used to compute addresses within pipeline */
! #define MD_AGEN_OP		ADD
  
  /* NOP operation when injected into the pipeline */
! #define MD_NOP_OP		NOP
  
  /* non-zero for a valid address, used to determine if speculative accesses
     should access the DL1 data cache */
  #define MD_VALID_ADDR(ADDR)						\
    (((ADDR) >= ld_text_base && (ADDR) < (ld_text_base + ld_text_size))	\
!    || ((ADDR) >= ld_data_base && (ADDR) < ld_stack_base))
! 
  
  /*
   * configure branch predictors
***************
*** 570,576 ****
  
  /* shift used to ignore branch address least significant bits, usually
     log2(sizeof(md_inst_t)) */
! #define MD_BR_SHIFT		2	/* log2(4) */
  
  
  /*
--- 661,667 ----
  
  /* shift used to ignore branch address least significant bits, usually
     log2(sizeof(md_inst_t)) */
! #define MD_BR_SHIFT		3	/* log2(8) */
  
  
  /*
***************
*** 580,592 ****
  /* intialize the inst decoder, this function builds the ISA decode tables */
  void md_init_decoder(void);
  
! /* disassemble a SimpleScalar instruction */
  void
  md_print_insn(md_inst_t inst,		/* instruction to disassemble */
  	      md_addr_t pc,		/* addr of inst, used for PC-rels */
  	      FILE *stream);		/* output stream */
  
! #endif /* ALPHA_H */
  
  
  
--- 671,689 ----
  /* intialize the inst decoder, this function builds the ISA decode tables */
  void md_init_decoder(void);
  
! /* disassemble an instruction */
  void
  md_print_insn(md_inst_t inst,		/* instruction to disassemble */
  	      md_addr_t pc,		/* addr of inst, used for PC-rels */
  	      FILE *stream);		/* output stream */
  
! #endif /* PISA_H */
! 
! 
! 
! 
! 
! 
  
  
  
***************
*** 594,621 ****
  
  
  
- #if 0
  
- /* instruction/address formats */
- typedef qword_t MD_ADDR_TYPE;
- typedef qword_t MD_PTR_TYPE;
- typedef word_t MD_INST_TYPE;
- #define MD_INST_SIZE		sizeof(MD_INST_TYPE)
  
- /* virtual memory segment limits */
- #define MD_TEXT_BASE		0x20000000ULL
- #define MD_STACK_BASE 		(MD_TEXT_BASE - (409600+4096))
  
! /* well known registers */
! enum { REG_V0, REG_A0=16, REG_A1, REG_A2, REG_A3, REG_A4, REG_A5, REG_ERR=7,
!        REG_GP=29, REG_SP, REG_ZERO, REG_RA=26 };
  
  /* total number of register in processor 32I+32F+HI+LO+FCC+TMP+MEM+CTRL */
! #define MD_TOTAL_REGS							\
!   (MD_NUM_REGS+MD_NUM_REGS+/*FPCR*/1+/*UNIQ*/1+/*MEM*/1+/*CTRL*/1)
  
! /* inst check macros, activated if NO_ICHECKS is not defined (default) */
! #ifndef NO_ICHECKS
  
  /* instruction failure notification macro, this can be defined by the
     target simulator if, for example, the simulator wants to handle the
--- 691,751 ----
  
  
  
  
  
  
! 
! #if 0
! 
! /* virtual memory page size, this should be user configurable */
! #define SS_PAGE_SIZE		4096
! 
! /* total number of registers in each register file (int and FP) */
! #define SS_NUM_REGS		32
  
  /* total number of register in processor 32I+32F+HI+LO+FCC+TMP+MEM+CTRL */
! #define SS_TOTAL_REGS							\
!   (SS_NUM_REGS+SS_NUM_REGS+/*HI*/1+/*LO*/1+/*FCC*/1+/*TMP*/1+		\
!    /*MEM*/1+/*CTRL*/1)
! 
! /* returns pre/post-incr/decr operation field value */
! #define SS_COMP_OP		((inst.a & 0xff00) >> 8)
! 
! /* pre/post-incr/decr operation field specifiers */
! #define SS_COMP_NOP		0x00
! #define SS_COMP_POST_INC	0x01
! #define SS_COMP_POST_DEC	0x02
! #define SS_COMP_PRE_INC		0x03
! #define SS_COMP_PRE_DEC		0x04
! #define SS_COMP_POST_DBL_INC	0x05	/* for double word accesses */
! #define SS_COMP_POST_DBL_DEC	0x06
! #define SS_COMP_PRE_DBL_INC	0x07
! #define SS_COMP_PRE_DBL_DEC	0x08
! 
! /* the instruction expression modifications required for an expression to
!    support pre/post-incr/decr operations is accomplished by the INC_DEC()
!    macro, it looks so contorted to reduce the control complexity of the
!    equation (and thus reducing the compilation time greatly with GNU GCC -
!    the key is to only emit EXPR one time) */
! #define INC_DEC(EXPR, REG, SIZE)					\
!   (SET_GPR((REG), GPR(REG) + ss_fore_tab[(SIZE)-1][SS_COMP_OP]),	\
!    (EXPR),								\
!    SET_GPR((REG), GPR(REG) + ss_aft_tab[(SIZE)-1][SS_COMP_OP]))
! 
! /* INC_DEC expression step tables, they map (operation, size) -> step value */
! extern int ss_fore_tab[8][5];
! extern int ss_aft_tab[8][5];
! 
! /* pre-defined registers */
! #define Rgp		28		/* global data pointer */
! #define Rsp		29		/* stack pointer */
! #define Rfp		30		/* frame pointer */
! 
! /* FIXME: non-reentrant LWL/LWR implementation workspace */
! extern SS_ADDR_TYPE ss_lr_temp;
  
! /* FIXME: non-reentrant temporary variables */
! extern SS_ADDR_TYPE temp_bs, temp_rd;
  
  /* instruction failure notification macro, this can be defined by the
     target simulator if, for example, the simulator wants to handle the
***************
*** 625,646 ****
  #define IFAIL(S)	fatal(S)
  #endif /* IFAIL */
  
- /* check for overflow in X+Y, both signed */
- #define OVER(X,Y)	(((((X) > 0) && ((Y) > 0)			\
- 			   && (MAXINT_VAL - (X) < (Y)))			\
- 			  ? IFAIL("+ overflow") : (void)0),		\
- 			 ((((X) < 0) && ((Y) < 0)			\
- 			   && (-MAXINT_VAL - (X) > (Y)))		\
- 			  ? IFAIL("+ underflow") : (void)0))
- 
- /* check for underflow in X-Y, both signed */
- #define UNDER(X,Y)	(((((X) > 0) && ((Y) < 0)			\
- 			   && (MAXINT_VAL + (Y) < (X)))			\
- 			  ? IFAIL("- overflow") : (void)0),		\
- 			 ((((X) < 0) && ((Y) > 0)			\
- 			   && (-MAXINT_VAL + (Y) > (X)))		\
- 			  ? IFAIL("- underflow") : (void)0))
- 
  /* check for divide by zero error, N is denom */
  #define DIV0(N)		(((N) == 0) ? IFAIL("divide by 0") : (void)0)
  
--- 755,760 ----
***************
*** 655,663 ****
  /* check target address TARG for required jump target alignment */
  #define TALIGN(TARG)	(((TARG) & 0x7)					\
  			 ? IFAIL("bad jump alignment") : (void)0)
- 
- #else /* NO_ICHECKS */
- 
  /* inst checks disables, change all checks to NOP expressions */
  #define OVER(X,Y)	((void)0)
  #define UNDER(X,Y)	((void)0)
--- 769,774 ----
***************
*** 666,673 ****
  #define FPALIGN(N)	((void)0)
  #define TALIGN(TARG)	((void)0)
  
- #endif /* NO_ICHECKS */
- 
  /* default division operator semantics, this operation is accessed through a
     macro because some simulators need to check for divide by zero faults
     before executing this operation */
--- 777,782 ----
diff -crB tmp/simplesim-3.0/symbol.c simplesim-3.0/symbol.c
*** tmp/simplesim-3.0/symbol.c	2003-10-08 21:17:17.000000000 -0500
--- simplesim-3.0/symbol.c	2003-10-08 21:24:24.000000000 -0500
***************
*** 54,67 ****
  
  #include "host.h"
  #include "misc.h"
- #include "loader.h"
- #include "symbol.h"
- 
  #ifdef BFD_LOADER
  #include <bfd.h>
  #else /* !BFD_LOADER */
! #include "target-alpha/ecoff.h"
  #endif /* BFD_LOADER */
  
  /* #define PRINT_SYMS */
  
--- 54,66 ----
  
  #include "host.h"
  #include "misc.h"
  #ifdef BFD_LOADER
  #include <bfd.h>
  #else /* !BFD_LOADER */
! #include "target-pisa/ecoff.h"
  #endif /* BFD_LOADER */
+ #include "loader.h"
+ #include "symbol.h"
  
  /* #define PRINT_SYMS */
  
***************
*** 401,407 ****
  #else /* !BFD_LOADER */
  
    /* load the program into memory, try both endians */
! #if defined(_MSC_VER)
    fobj = fopen(fname, "rb");
  #else
    fobj = fopen(fname, "r");
--- 400,406 ----
  #else /* !BFD_LOADER */
  
    /* load the program into memory, try both endians */
! #if defined(__CYGWIN32__) || defined(_MSC_VER)
    fobj = fopen(fname, "rb");
  #else
    fobj = fopen(fname, "r");
***************
*** 413,426 ****
      fatal("cannot read header from executable `%s'", fname);
  
    /* record endian of target */
!   if (fhdr.f_magic != ECOFF_ALPHAMAGIC)
      fatal("bad magic number in executable `%s'", fname);
  
    if (fread(&ahdr, sizeof(struct ecoff_aouthdr), 1, fobj) < 1)
      fatal("cannot read AOUT header from executable `%s'", fname);
  
    /* seek to the beginning of the symbolic header */
!   fseek(fobj, (long)fhdr.f_symptr, 0);
  
    if (fread(&symhdr, sizeof(struct ecoff_symhdr_t), 1, fobj) < 1)
      fatal("could not read symbolic header from executable `%s'", fname);
--- 412,425 ----
      fatal("cannot read header from executable `%s'", fname);
  
    /* record endian of target */
!   if (fhdr.f_magic != ECOFF_EB_MAGIC && fhdr.f_magic != ECOFF_EL_MAGIC)
      fatal("bad magic number in executable `%s'", fname);
  
    if (fread(&ahdr, sizeof(struct ecoff_aouthdr), 1, fobj) < 1)
      fatal("cannot read AOUT header from executable `%s'", fname);
  
    /* seek to the beginning of the symbolic header */
!   fseek(fobj, fhdr.f_symptr, 0);
  
    if (fread(&symhdr, sizeof(struct ecoff_symhdr_t), 1, fobj) < 1)
      fatal("could not read symbolic header from executable `%s'", fname);
***************
*** 435,441 ****
      fatal("out of virtual memory");
  
    /* read all the symbol names into memory */
!   fseek(fobj, (long)symhdr.cbSsExtOffset /* cbSsOffset */, 0);
    if (fread(strtab, len, 1, fobj) < 0)
      fatal("error while reading symbol table names");
  
--- 434,440 ----
      fatal("out of virtual memory");
  
    /* read all the symbol names into memory */
!   fseek(fobj, symhdr.cbSsOffset, 0);
    if (fread(strtab, len, 1, fobj) < 0)
      fatal("error while reading symbol table names");
  
***************
*** 453,459 ****
    if (!extr)
      fatal("out of virtual memory");
  
!   fseek(fobj, (long)symhdr.cbExtOffset, 0);
    if (fread(extr, sizeof(struct ecoff_EXTR), symhdr.iextMax, fobj) < 0)
      fatal("error reading external symbol entries");
  
--- 452,458 ----
    if (!extr)
      fatal("out of virtual memory");
  
!   fseek(fobj, symhdr.cbExtOffset, 0);
    if (fread(extr, sizeof(struct ecoff_EXTR), symhdr.iextMax, fobj) < 0)
      fatal("error reading external symbol entries");
  
***************
*** 511,520 ****
  
  	default:
  	  /* FIXME: ignored... */;
- #if 0
- 	  fprintf(stderr, "** skipping: %s...\n", &strtab[str_offset]);
- 	  break;
- #endif
  	}
      }
    free(extr);
--- 510,515 ----
***************
*** 643,650 ****
  sym_dumpsym(struct sym_sym_t *sym,	/* symbol to display */
  	    FILE *fd)			/* output stream */
  {
!   myfprintf(fd,
!     "sym `%s': %s seg, init-%s, pub-%s, local-%s, addr=0x%08p, size=%d\n",
  	  sym->name,
  	  sym->seg == ss_data ? "data" : "text",
  	  sym->initialized ? "y" : "n",
--- 638,645 ----
  sym_dumpsym(struct sym_sym_t *sym,	/* symbol to display */
  	    FILE *fd)			/* output stream */
  {
!   fprintf(fd,
!     "sym `%s': %s seg, init-%s, pub-%s, local-%s, addr=0x%08x, size=%d\n",
  	  sym->name,
  	  sym->seg == ss_data ? "data" : "text",
  	  sym->initialized ? "y" : "n",
***************
*** 703,709 ****
     requested symbol database is returned in *PINDEX if the pointer is
     non-NULL */
  struct sym_sym_t *			/* symbol found, or NULL */
! sym_bind_addr(md_addr_t addr,	/* address of symbol to locate */
  	      int *pindex,		/* ptr to index result var */
  	      int exact,		/* require exact address match? */
  	      enum sym_db_t db)		/* symbol database to search */
--- 698,704 ----
     requested symbol database is returned in *PINDEX if the pointer is
     non-NULL */
  struct sym_sym_t *			/* symbol found, or NULL */
! sym_bind_addr(md_addr_t addr,		/* address of symbol to locate */
  	      int *pindex,		/* ptr to index result var */
  	      int exact,		/* require exact address match? */
  	      enum sym_db_t db)		/* symbol database to search */
diff -crB tmp/simplesim-3.0/syscall.c simplesim-3.0/syscall.c
*** tmp/simplesim-3.0/syscall.c	2011-03-11 23:57:48.000000000 -0600
--- simplesim-3.0/syscall.c	2011-09-30 20:50:13.000000000 -0500
***************
*** 51,66 ****
  
  #include <stdio.h>
  #include <stdlib.h>
! 
! /* only enable a minimal set of systen call proxies if on limited
!    hosts or if in cross endian live execution mode */
! #ifndef MIN_SYSCALL_MODE
! #if defined(_MSC_VER) || defined(__CYGWIN32__) || defined(MD_CROSS_ENDIAN)
! #define MIN_SYSCALL_MODE
! #endif
! #endif /* !MIN_SYSCALL_MODE */
  
  /* live execution only support on same-endian hosts... */
  #ifdef _MSC_VER
  #include <io.h>
  #else /* !_MSC_VER */
--- 51,70 ----
  
  #include <stdio.h>
  #include <stdlib.h>
! #include "host.h"
! #include "misc.h"
! #include "machine.h"
! #include "regs.h"
! #include "memory.h"
! #include "loader.h"
! #include "sim.h"
! #include "endian.h"
! #include "eio.h"
! #include "syscall.h"
  
  /* live execution only support on same-endian hosts... */
+ #ifndef MD_CROSS_ENDIAN
+ 
  #ifdef _MSC_VER
  #include <io.h>
  #else /* !_MSC_VER */
***************
*** 80,88 ****
  #include <sys/resource.h>
  #endif
  #include <signal.h>
! #ifndef _MSC_VER
! #include <sys/file.h>
! #endif
  #include <sys/stat.h>
  #ifndef _MSC_VER
  #include <sys/uio.h>
--- 84,92 ----
  #include <sys/resource.h>
  #endif
  #include <signal.h>
! 
! /* #include <sys/file.h> */
! 
  #include <sys/stat.h>
  #ifndef _MSC_VER
  #include <sys/uio.h>
***************
*** 95,154 ****
  #ifndef _MSC_VER
  #include <sys/ioctl.h>
  #endif
! #if defined(__FreeBSD__)
! #include <utime.h>
! #include <dirent.h>
! #endif
! #if defined(linux)
! #include <utime.h>
! #include <dirent.h>
! #include <sys/vfs.h>
! #endif
! #if defined(_AIX)
! #include <sys/statfs.h>
! #else /* !_AIX */
! #ifndef _MSC_VER
! #include <sys/mount.h>
! #endif
! #endif /* !_AIX */
! #if !defined(linux) && !defined(sparc) && !defined(hpux) && !defined(__hpux) && !defined(__CYGWIN32__) && !defined(ultrix)
  #ifndef _MSC_VER
  #include <sys/select.h>
  #endif
  #endif
  #ifdef linux
  #include <sgtty.h>
- #include <netinet/tcp.h>
- #include <netinet/udp.h>
- #include <netinet/in.h>
  #endif /* linux */
  
! #ifdef __FreeBSD__
! #include <netinet/tcp.h>
! #include <netinet/udp.h>
! #include <netinet/in.h>
! #endif /* __FreeBSD__ */
! 
! #if defined(__svr4__)
! #include <sys/dirent.h>
! #include <sys/filio.h>
! #elif defined(__osf__)
! #include <dirent.h>
! /* -- For some weird reason, getdirentries() is not declared in any
!  * -- header file under /usr/include on the Alpha boxen that I tried
!  * -- SS-Alpha on. But the function exists in the libraries.
!  */
! int getdirentries(int fd, char *buf, int nbytes, long *basep);
  #endif
  
! #if defined(__svr4__) || defined(__osf__)
! #include <sys/statvfs.h>
! #define statfs statvfs
! #include <sys/time.h>
! #include <utime.h>
! #include <sgtty.h>
! #include <netinet/in.h>
! #include <netinet/tcp.h>
  #endif
  
  #if defined(sparc) && defined(__unix__)
--- 99,120 ----
  #ifndef _MSC_VER
  #include <sys/ioctl.h>
  #endif
! #if !defined(linux) && !defined(sparc) && !defined(hpux) && !defined(__hpux) && !defined(__CYGWIN32__) && !defined(ultrix) && !defined(__APPLE__)
  #ifndef _MSC_VER
  #include <sys/select.h>
  #endif
  #endif
  #ifdef linux
+ #include <utime.h>
  #include <sgtty.h>
  #endif /* linux */
  
! #if defined(hpux) || defined(__hpux)
! #include <sgtty.h>
  #endif
  
! #ifdef __svr4__
! #include "utime.h"
  #endif
  
  #if defined(sparc) && defined(__unix__)
***************
*** 184,193 ****
  #undef CR0
  #endif
  
! #ifdef __FreeBSD__
  #include <termios.h>
  /*#include <sys/ioctl_compat.h>*/
! #else
  #ifndef _MSC_VER
  #include <termio.h>
  #endif
--- 150,159 ----
  #undef CR0
  #endif
  
! #if defined(__FreeBSD__) || defined(__APPLE__)
  #include <termios.h>
  /*#include <sys/ioctl_compat.h>*/
! #else /* !__FreeBSD__ */
  #ifndef _MSC_VER
  #include <termio.h>
  #endif
***************
*** 234,242 ****
  #include <utime.h>
  #endif
  
- #include <sys/socket.h>
- #include <sys/poll.h>
- 
  #ifdef _MSC_VER
  #define access		_access
  #define chmod		_chmod
--- 200,205 ----
***************
*** 258,550 ****
  #include <sys/utime.h>
  #endif /* _MSC_VER */
  
! #include "host.h"
! #include "misc.h"
! #include "machine.h"
! #include "regs.h"
! #include "memory.h"
! #include "loader.h"
! #include "sim.h"
! #include "endian.h"
! #include "eio.h"
! #include "syscall.h"
! 
! #define OSF_SYS_syscall     0
! /* OSF_SYS_exit moved to alpha.h */
! #define OSF_SYS_fork        2
! #define OSF_SYS_read        3
! /* OSF_SYS_write moved to alpha.h */
! #define OSF_SYS_old_open    5       /* 5 is old open */
! #define OSF_SYS_close       6
! #define OSF_SYS_wait4       7
! #define OSF_SYS_old_creat   8       /* 8 is old creat */
! #define OSF_SYS_link        9
! #define OSF_SYS_unlink      10
! #define OSF_SYS_execv       11
! #define OSF_SYS_chdir       12
! #define OSF_SYS_fchdir      13
! #define OSF_SYS_mknod       14
! #define OSF_SYS_chmod       15
! #define OSF_SYS_chown       16
! #define OSF_SYS_obreak      17
! #define OSF_SYS_getfsstat   18
! #define OSF_SYS_lseek       19
! #define OSF_SYS_getpid      20
! #define OSF_SYS_mount       21
! #define OSF_SYS_unmount     22
! #define OSF_SYS_setuid      23
! #define OSF_SYS_getuid      24
! #define OSF_SYS_exec_with_loader    25
! #define OSF_SYS_ptrace      26
! #ifdef  COMPAT_43
! #define OSF_SYS_nrecvmsg    27
! #define OSF_SYS_nsendmsg    28
! #define OSF_SYS_nrecvfrom   29
! #define OSF_SYS_naccept     30
! #define OSF_SYS_ngetpeername        31
! #define OSF_SYS_ngetsockname        32
! #else
! #define OSF_SYS_recvmsg     27
! #define OSF_SYS_sendmsg     28
! #define OSF_SYS_recvfrom    29
! #define OSF_SYS_accept      30
! #define OSF_SYS_getpeername 31
! #define OSF_SYS_getsockname 32
! #endif
! #define OSF_SYS_access      33
! #define OSF_SYS_chflags     34
! #define OSF_SYS_fchflags    35
! #define OSF_SYS_sync        36
! #define OSF_SYS_kill        37
! #define OSF_SYS_old_stat    38      /* 38 is old stat */
! #define OSF_SYS_setpgid     39
! #define OSF_SYS_old_lstat   40      /* 40 is old lstat */
! #define OSF_SYS_dup 41
! #define OSF_SYS_pipe        42
! #define OSF_SYS_set_program_attributes      43
! #define OSF_SYS_profil      44
! #define OSF_SYS_open        45
!                                 /* 46 is obsolete osigaction */
! #define OSF_SYS_getgid      47
! #define OSF_SYS_sigprocmask 48
! #define OSF_SYS_getlogin    49
! #define OSF_SYS_setlogin    50
! #define OSF_SYS_acct        51
! #define OSF_SYS_sigpending  52
! #define OSF_SYS_ioctl       54
! #define OSF_SYS_reboot      55
! #define OSF_SYS_revoke      56
! #define OSF_SYS_symlink     57
! #define OSF_SYS_readlink    58
! #define OSF_SYS_execve      59
! #define OSF_SYS_umask       60
! #define OSF_SYS_chroot      61
! #define OSF_SYS_old_fstat   62      /* 62 is old fstat */
! #define OSF_SYS_getpgrp     63
! #define OSF_SYS_getpagesize 64
! #define OSF_SYS_mremap      65
! #define OSF_SYS_vfork       66
! #define OSF_SYS_stat        67
! #define OSF_SYS_lstat       68
! #define OSF_SYS_sbrk        69
! #define OSF_SYS_sstk        70
! #define OSF_SYS_mmap        71
! #define OSF_SYS_ovadvise    72
! #define OSF_SYS_munmap      73
! #define OSF_SYS_mprotect    74
! #define OSF_SYS_madvise     75
! #define OSF_SYS_old_vhangup 76      /* 76 is old vhangup */
! #define OSF_SYS_kmodcall    77
! #define OSF_SYS_mincore     78
! #define OSF_SYS_getgroups   79
! #define OSF_SYS_setgroups   80
! #define OSF_SYS_old_getpgrp 81      /* 81 is old getpgrp */
! #define OSF_SYS_setpgrp     82
! #define OSF_SYS_setitimer   83
! #define OSF_SYS_old_wait    84      /* 84 is old wait */
! #define OSF_SYS_table       85
! #define OSF_SYS_getitimer   86
! #define OSF_SYS_gethostname 87
! #define OSF_SYS_sethostname 88
! #define OSF_SYS_getdtablesize       89
! #define OSF_SYS_dup2        90
! #define OSF_SYS_fstat       91
! #define OSF_SYS_fcntl       92
! #define OSF_SYS_select      93
! #define OSF_SYS_poll        94
! #define OSF_SYS_fsync       95
! #define OSF_SYS_setpriority 96
! #define OSF_SYS_socket      97
! #define OSF_SYS_connect     98
! #ifdef  COMPAT_43
! #define OSF_SYS_accept      99
! #else
! #define OSF_SYS_old_accept  99      /* 99 is old accept */
! #endif
! #define OSF_SYS_getpriority 100
! #ifdef  COMPAT_43
! #define OSF_SYS_send        101
! #define OSF_SYS_recv        102
! #else
! #define OSF_SYS_old_send    101     /* 101 is old send */
! #define OSF_SYS_old_recv    102     /* 102 is old recv */
! #endif
! #define OSF_SYS_sigreturn   103
! #define OSF_SYS_bind        104
! #define OSF_SYS_setsockopt  105
! #define OSF_SYS_listen      106
! #define OSF_SYS_plock       107
! #define OSF_SYS_old_sigvec  108     /* 108 is old sigvec */
! #define OSF_SYS_old_sigblock        109     /* 109 is old sigblock */
! #define OSF_SYS_old_sigsetmask      110     /* 110 is old sigsetmask */
! #define OSF_SYS_sigsuspend  111
! #define OSF_SYS_sigstack    112
! #ifdef  COMPAT_43
! #define OSF_SYS_recvmsg     113
! #define OSF_SYS_sendmsg     114
! #else
! #define OSF_SYS_old_recvmsg 113     /* 113 is old recvmsg */
! #define OSF_SYS_old_sendmsg 114     /* 114 is old sendmsg */
! #endif
!                                 /* 115 is obsolete vtrace */
! #define OSF_SYS_gettimeofday        116
! #define OSF_SYS_getrusage   117
! #define OSF_SYS_getsockopt  118
! #define OSF_SYS_readv       120
! #define OSF_SYS_writev      121
! #define OSF_SYS_settimeofday        122
! #define OSF_SYS_fchown      123
! #define OSF_SYS_fchmod      124
! #ifdef  COMPAT_43
! #define OSF_SYS_recvfrom    125
! #else
! #define OSF_SYS_old_recvfrom        125     /* 125 is old recvfrom */
! #endif
! #define OSF_SYS_setreuid    126
! #define OSF_SYS_setregid    127
! #define OSF_SYS_rename      128
! #define OSF_SYS_truncate    129
! #define OSF_SYS_ftruncate   130
! #define OSF_SYS_flock       131
! #define OSF_SYS_setgid      132
! #define OSF_SYS_sendto      133
! #define OSF_SYS_shutdown    134
! #define OSF_SYS_socketpair  135
! #define OSF_SYS_mkdir       136
! #define OSF_SYS_rmdir       137
! #define OSF_SYS_utimes      138
!                                 /* 139 is obsolete 4.2 sigreturn */
! #define OSF_SYS_adjtime     140
! #ifdef  COMPAT_43
! #define OSF_SYS_getpeername 141
! #else
! #define OSF_SYS_old_getpeername     141     /* 141 is old getpeername */
! #endif
! #define OSF_SYS_gethostid   142
! #define OSF_SYS_sethostid   143
! #define OSF_SYS_getrlimit   144
! #define OSF_SYS_setrlimit   145
! #define OSF_SYS_old_killpg  146     /* 146 is old killpg */
! #define OSF_SYS_setsid      147
! #define OSF_SYS_quotactl    148
! #define OSF_SYS_oldquota    149
! #ifdef  COMPAT_43
! #define OSF_SYS_getsockname 150
! #else
! #define OSF_SYS_old_getsockname     150     /* 150 is old getsockname */
! #endif
! #define OSF_SYS_pid_block   153
! #define OSF_SYS_pid_unblock 154
! #define OSF_SYS_sigaction   156
! #define OSF_SYS_sigwaitprim 157
! #define OSF_SYS_nfssvc      158
! #define OSF_SYS_getdirentries       159
! #define OSF_SYS_statfs      160
! #define OSF_SYS_fstatfs     161
! #define OSF_SYS_async_daemon        163
! #define OSF_SYS_getfh       164
! #define OSF_SYS_getdomainname       165
! #define OSF_SYS_setdomainname       166
! #define OSF_SYS_exportfs    169
! #define OSF_SYS_alt_plock   181     /* 181 is alternate plock */
! #define OSF_SYS_getmnt      184
! #define OSF_SYS_alt_sigpending      187     /* 187 is alternate sigpending */
! #define OSF_SYS_alt_setsid  188     /* 188 is alternate setsid */
! #define OSF_SYS_swapon      199
! #define OSF_SYS_msgctl      200
! #define OSF_SYS_msgget      201
! #define OSF_SYS_msgrcv      202
! #define OSF_SYS_msgsnd      203
! #define OSF_SYS_semctl      204
! #define OSF_SYS_semget      205
! #define OSF_SYS_semop       206
! #define OSF_SYS_uname       207
! #define OSF_SYS_lchown      208
! #define OSF_SYS_shmat       209
! #define OSF_SYS_shmctl      210
! #define OSF_SYS_shmdt       211
! #define OSF_SYS_shmget      212
! #define OSF_SYS_mvalid      213
! #define OSF_SYS_getaddressconf      214
! #define OSF_SYS_msleep      215
! #define OSF_SYS_mwakeup     216
! #define OSF_SYS_msync       217
! #define OSF_SYS_signal      218
! #define OSF_SYS_utc_gettime 219
! #define OSF_SYS_utc_adjtime 220
! #define OSF_SYS_security    222
! #define OSF_SYS_kloadcall   223
! #define OSF_SYS_getpgid     233
! #define OSF_SYS_getsid      234
! #define OSF_SYS_sigaltstack 235
! #define OSF_SYS_waitid      236
! #define OSF_SYS_priocntlset 237
! #define OSF_SYS_sigsendset  238
! #define OSF_SYS_set_speculative     239
! #define OSF_SYS_msfs_syscall        240
! #define OSF_SYS_sysinfo     241
! #define OSF_SYS_uadmin      242
! #define OSF_SYS_fuser       243
! #define OSF_SYS_proplist_syscall    244
! #define OSF_SYS_ntp_adjtime 245
! #define OSF_SYS_ntp_gettime 246
! #define OSF_SYS_pathconf    247
! #define OSF_SYS_fpathconf   248
! #define OSF_SYS_uswitch     250
! #define OSF_SYS_usleep_thread       251
! #define OSF_SYS_audcntl     252
! #define OSF_SYS_audgen      253
! #define OSF_SYS_sysfs       254
! #define OSF_SYS_subOSF_SYS_info 255
! #define OSF_SYS_getsysinfo  256
! #define OSF_SYS_setsysinfo  257
! #define OSF_SYS_afs_syscall 258
! #define OSF_SYS_swapctl     259
! #define OSF_SYS_memcntl     260
! #define OSF_SYS_fdatasync   261
! 
! /* translate system call arguments */
! struct xlate_table_t
! {
!   int target_val;
!   int host_val;
! };
! 
! int
! xlate_arg(int target_val, struct xlate_table_t *map, int map_sz, char *name)
! {
!   int i;
! 
!   for (i=0; i < map_sz; i++)
!     {
!       if (target_val == map[i].target_val)
! 	return map[i].host_val;
!     }
! 
!   /* not found, issue warning and return target_val */
!   warn("could not translate argument for `%s': %d", name, target_val);
!   return target_val;
! }
  
  /* internal system call buffer size, used primarily for file name arguments,
     argument larger than this will be truncated */
--- 221,460 ----
  #include <sys/utime.h>
  #endif /* _MSC_VER */
  
! /* SimpleScalar SStrix (a derivative of Ultrix) system call codes, note these
!    codes reside in register $r2 at the point a `syscall' inst is executed,
!    not all of these codes are implemented, see the main switch statement in
!    syscall.c for a list of implemented system calls */
! 
! #define SS_SYS_syscall		0
! /* SS_SYS_exit was moved to pisa.h */
! #define	SS_SYS_fork		2
! #define	SS_SYS_read		3
! /* SS_SYS_write was moved to pisa.h */
! #define	SS_SYS_open		5
! #define	SS_SYS_close		6
! 						/*  7 is old: wait */
! #define	SS_SYS_creat		8
! #define	SS_SYS_link		9
! #define	SS_SYS_unlink		10
! #define	SS_SYS_execv		11
! #define	SS_SYS_chdir		12
! 						/* 13 is old: time */
! #define	SS_SYS_mknod		14
! #define	SS_SYS_chmod		15
! #define	SS_SYS_chown		16
! #define	SS_SYS_brk		17		/* 17 is old: sbreak */
! 						/* 18 is old: stat */
! #define	SS_SYS_lseek		19
! #define	SS_SYS_getpid		20
! #define	SS_SYS_mount		21
! #define	SS_SYS_umount		22
! 						/* 23 is old: setuid */
! #define	SS_SYS_getuid		24
! 						/* 25 is old: stime */
! #define	SS_SYS_ptrace		26
! 						/* 27 is old: alarm */
! 						/* 28 is old: fstat */
! 						/* 29 is old: pause */
! 						/* 30 is old: utime */
! 						/* 31 is old: stty */
! 						/* 32 is old: gtty */
! #define	SS_SYS_access		33
! 						/* 34 is old: nice */
! 						/* 35 is old: ftime */
! #define	SS_SYS_sync		36
! #define	SS_SYS_kill		37
! #define	SS_SYS_stat		38
! 						/* 39 is old: setpgrp */
! #define	SS_SYS_lstat		40
! #define	SS_SYS_dup		41
! #define	SS_SYS_pipe		42
! 						/* 43 is old: times */
! #define	SS_SYS_profil		44
! 						/* 45 is unused */
! 						/* 46 is old: setgid */
! #define	SS_SYS_getgid		47
! 						/* 48 is old: sigsys */
! 						/* 49 is unused */
! 						/* 50 is unused */
! #define	SS_SYS_acct		51
! 						/* 52 is old: phys */
! 						/* 53 is old: syslock */
! #define	SS_SYS_ioctl		54
! #define	SS_SYS_reboot		55
! 						/* 56 is old: mpxchan */
! #define	SS_SYS_symlink		57
! #define	SS_SYS_readlink		58
! #define	SS_SYS_execve		59
! #define	SS_SYS_umask		60
! #define	SS_SYS_chroot		61
! #define	SS_SYS_fstat		62
! 						/* 63 is unused */
! #define	SS_SYS_getpagesize 	64
! #define	SS_SYS_mremap		65
! #define SS_SYS_vfork		66		/* 66 is old: vfork */
! 						/* 67 is old: vread */
! 						/* 68 is old: vwrite */
! #define	SS_SYS_sbrk		69
! #define	SS_SYS_sstk		70
! #define	SS_SYS_mmap		71
! #define SS_SYS_vadvise		72		/* 72 is old: vadvise */
! #define	SS_SYS_munmap		73
! #define	SS_SYS_mprotect		74
! #define	SS_SYS_madvise		75
! #define	SS_SYS_vhangup		76
! 						/* 77 is old: vlimit */
! #define	SS_SYS_mincore		78
! #define	SS_SYS_getgroups	79
! #define	SS_SYS_setgroups	80
! #define	SS_SYS_getpgrp		81
! #define	SS_SYS_setpgrp		82
! #define	SS_SYS_setitimer	83
! #define	SS_SYS_wait3		84
! #define	SS_SYS_wait		SYS_wait3
! #define	SS_SYS_swapon		85
! #define	SS_SYS_getitimer	86
! #define	SS_SYS_gethostname	87
! #define	SS_SYS_sethostname	88
! #define	SS_SYS_getdtablesize	89
! #define	SS_SYS_dup2		90
! #define	SS_SYS_getdopt		91
! #define	SS_SYS_fcntl		92
! #define	SS_SYS_select		93
! #define	SS_SYS_setdopt		94
! #define	SS_SYS_fsync		95
! #define	SS_SYS_setpriority	96
! #define	SS_SYS_socket		97
! #define	SS_SYS_connect		98
! #define	SS_SYS_accept		99
! #define	SS_SYS_getpriority	100
! #define	SS_SYS_send		101
! #define	SS_SYS_recv		102
! #define SS_SYS_sigreturn	103		/* new sigreturn */
! 						/* 103 was socketaddr */
! #define	SS_SYS_bind		104
! #define	SS_SYS_setsockopt	105
! #define	SS_SYS_listen		106
! 						/* 107 was vtimes */
! #define	SS_SYS_sigvec		108
! #define	SS_SYS_sigblock		109
! #define	SS_SYS_sigsetmask	110
! #define	SS_SYS_sigpause		111
! #define	SS_SYS_sigstack		112
! #define	SS_SYS_recvmsg		113
! #define	SS_SYS_sendmsg		114
! 						/* 115 is old vtrace */
! #define	SS_SYS_gettimeofday	116
! #define	SS_SYS_getrusage	117
! #define	SS_SYS_getsockopt	118
! 						/* 119 is old resuba */
! #define	SS_SYS_readv		120
! #define	SS_SYS_writev		121
! #define	SS_SYS_settimeofday	122
! #define	SS_SYS_fchown		123
! #define	SS_SYS_fchmod		124
! #define	SS_SYS_recvfrom		125
! #define	SS_SYS_setreuid		126
! #define	SS_SYS_setregid		127
! #define	SS_SYS_rename		128
! #define	SS_SYS_truncate		129
! #define	SS_SYS_ftruncate	130
! #define	SS_SYS_flock		131
! 						/* 132 is unused */
! #define	SS_SYS_sendto		133
! #define	SS_SYS_shutdown		134
! #define	SS_SYS_socketpair	135
! #define	SS_SYS_mkdir		136
! #define	SS_SYS_rmdir		137
! #define	SS_SYS_utimes		138
! #define SS_SYS_sigcleanup  	139		/* From 4.2 longjmp */
!                                                 /* same as SYS_sigreturn */
! #define	SS_SYS_adjtime		140
! #define	SS_SYS_getpeername	141
! #define	SS_SYS_gethostid	142
! #define	SS_SYS_sethostid	143
! #define	SS_SYS_getrlimit	144
! #define	SS_SYS_setrlimit	145
! #define	SS_SYS_killpg		146
! 						/* 147 is unused */
! #define	SS_SYS_setquota		148
! #define	SS_SYS_quota		149
! #define	SS_SYS_getsockname	150
! 
! #define SS_SYS_sysmips     	151		/* floating point control */
! 
! /* formerly mips local system calls */
! 
! #define SS_SYS_cacheflush  	152
! #define SS_SYS_cachectl    	153
! #define SS_SYS_atomic_op   	155
! 
! /* nfs releated system calls */
! #define SS_SYS_debug       	154
! 
! #define SS_SYS_statfs      	160
! #define SS_SYS_fstatfs     	161
! #define SS_SYS_unmount     	162
! 
! #define SS_SYS_quotactl    	168
! /* #define SS_SYS_mount       170 */
! 
! #define SS_SYS_hdwconf     	171
! 
! /* try to keep binary compatibility with mips */
! 
! #define SS_SYS_nfs_svc		158
! #define SS_SYS_nfssvc		158 /* cruft - delete when kernel fixed */
! #define SS_SYS_nfs_biod		163
! #define SS_SYS_async_daemon	163 /* cruft - delete when kernel fixed */
! #define SS_SYS_nfs_getfh	164
! #define SS_SYS_getfh		164 /* cruft - delete when kernel fixed */
! #define SS_SYS_getdirentries	159
! #define SS_SYS_getdomainname	165
! #define SS_SYS_setdomainname	166
! #define SS_SYS_exportfs		169
! 
! #define SS_SYS_msgctl		172
! #define SS_SYS_msgget		173
! #define SS_SYS_msgrcv		174
! #define SS_SYS_msgsnd		175
! #define SS_SYS_semctl		176
! #define SS_SYS_semget		177
! #define SS_SYS_semop		178
! #define SS_SYS_uname		179
! #define SS_SYS_shmsys		180
! #define SS_SYS_plock		181
! #define SS_SYS_lockf		182
! #define SS_SYS_ustat		183
! #define SS_SYS_getmnt		184
! #define	SS_SYS_sigpending	187
! #define	SS_SYS_setsid		188
! #define	SS_SYS_waitpid		189
! 
! #define	SS_SYS_utc_gettime	233	 /* 233 -- same as OSF/1 */
! #define SS_SYS_utc_adjtime	234	 /* 234 -- same as OSF/1 */
! #define SS_SYS_audcntl		252
! #define SS_SYS_audgen		253
! #define SS_SYS_startcpu		254	 /* 254 -- Ultrix Private */
! #define SS_SYS_stopcpu		255	 /* 255 -- Ultrix Private */
! #define SS_SYS_getsysinfo	256	 /* 256 -- Ultrix Private */
! #define SS_SYS_setsysinfo	257	 /* 257 -- Ultrix Private */
! 
! /* SStrix ioctl values */
! #define SS_IOCTL_TIOCGETP	1074164744
! #define SS_IOCTL_TIOCSETP	-2147060727
! #define SS_IOCTL_TCGETP		1076130901
! #define SS_IOCTL_TCGETA		1075082331
! #define SS_IOCTL_TIOCGLTC	1074164852
! #define SS_IOCTL_TIOCSLTC	-2147060619
! #define SS_IOCTL_TIOCGWINSZ	1074295912
! #define SS_IOCTL_TCSETAW	-2146143143
! #define SS_IOCTL_TIOCGETC	1074164754
! #define SS_IOCTL_TIOCSETC	-2147060719
! #define SS_IOCTL_TIOCLBIC	-2147191682
! #define SS_IOCTL_TIOCLBIS	-2147191681
! #define SS_IOCTL_TIOCLGET	0x4004747c
! #define SS_IOCTL_TIOCLSET	-2147191683
  
  /* internal system call buffer size, used primarily for file name arguments,
     argument larger than this will be truncated */
***************
*** 556,921 ****
     NUM_IOCTL_BYTES bytes from the pointer argument to host memory */
  #define NUM_IOCTL_BYTES		128
  
- /* OSF ioctl() requests */
- #define OSF_TIOCGETP		0x40067408
- #define OSF_FIONREAD		0x4004667f
- 
  /* target stat() buffer definition, the host stat buffer format is
     automagically mapped to/from this format in syscall.c */
! struct  osf_statbuf
  {
!   word_t osf_st_dev;
!   word_t osf_st_ino;
!   word_t osf_st_mode;
!   half_t osf_st_nlink;
!   half_t pad0;			/* to match Alpha/AXP padding... */
!   word_t osf_st_uid;
!   word_t osf_st_gid;
!   word_t osf_st_rdev;
!   word_t pad1;			/* to match Alpha/AXP padding... */
!   qword_t osf_st_size;
!   word_t osf_st_atime;
!   word_t osf_st_spare1;
!   word_t osf_st_mtime;
!   word_t osf_st_spare2;
!   word_t osf_st_ctime;
!   word_t osf_st_spare3;
!   word_t osf_st_blksize;
!   word_t osf_st_blocks;
!   word_t osf_st_gennum;
!   word_t osf_st_spare4;
  };
  
! struct osf_sgttyb {
!   byte_t sg_ispeed;	/* input speed */
!   byte_t sg_ospeed;	/* output speed */
!   byte_t sg_erase;	/* erase character */
!   byte_t sg_kill;	/* kill character */
!   shalf_t sg_flags;	/* mode flags */
! };
! 
! #define OSF_NSIG		32
! 
! #define OSF_SIG_BLOCK		1
! #define OSF_SIG_UNBLOCK		2
! #define OSF_SIG_SETMASK		3
! 
! struct osf_sigcontext {
!   qword_t sc_onstack;              /* sigstack state to restore */
!   qword_t sc_mask;                 /* signal mask to restore */
!   qword_t sc_pc;                   /* pc at time of signal */
!   qword_t sc_ps;                   /* psl to retore */
!   qword_t sc_regs[32];             /* processor regs 0 to 31 */
!   qword_t sc_ownedfp;              /* fp has been used */
!   qword_t sc_fpregs[32];           /* fp regs 0 to 31 */
!   qword_t sc_fpcr;                 /* floating point control register */
!   qword_t sc_fp_control;           /* software fpcr */
! };
! 
! struct osf_statfs {
!   shalf_t f_type;		/* type of filesystem (see below) */
!   shalf_t f_flags;		/* copy of mount flags */
!   word_t f_fsize;		/* fundamental filesystem block size */
!   word_t f_bsize;		/* optimal transfer block size */
!   word_t f_blocks;		/* total data blocks in file system, */
!   /* note: may not represent fs size. */
!   word_t f_bfree;		/* free blocks in fs */
!   word_t f_bavail;		/* free blocks avail to non-su */
!   word_t f_files;		/* total file nodes in file system */
!   word_t f_ffree;		/* free file nodes in fs */
!   qword_t f_fsid;		/* file system id */
!   word_t f_spare[9];		/* spare for later */
! };
! 
! struct osf_timeval
! {
!   sword_t osf_tv_sec;		/* seconds */
!   sword_t osf_tv_usec;		/* microseconds */
  };
  
! struct osf_timezone
  {
!   sword_t osf_tz_minuteswest;	/* minutes west of Greenwich */
!   sword_t osf_tz_dsttime;	/* type of dst correction */
  };
  
  /* target getrusage() buffer definition, the host stat buffer format is
     automagically mapped to/from this format in syscall.c */
! struct osf_rusage
  {
!   struct osf_timeval osf_ru_utime;
!   struct osf_timeval osf_ru_stime;
!   sword_t osf_ru_maxrss;
!   sword_t osf_ru_ixrss;
!   sword_t osf_ru_idrss;
!   sword_t osf_ru_isrss;
!   sword_t osf_ru_minflt;
!   sword_t osf_ru_majflt;
!   sword_t osf_ru_nswap;
!   sword_t osf_ru_inblock;
!   sword_t osf_ru_oublock;
!   sword_t osf_ru_msgsnd;
!   sword_t osf_ru_msgrcv;
!   sword_t osf_ru_nsignals;
!   sword_t osf_ru_nvcsw;
!   sword_t osf_ru_nivcsw;
  };
  
! struct osf_rlimit
  {
!   qword_t osf_rlim_cur;		/* current (soft) limit */
!   qword_t osf_rlim_max;		/* maximum value for rlim_cur */
  };
  
! struct osf_sockaddr
  {
!   half_t sa_family;		/* address family, AF_xxx */
!   byte_t sa_data[24];		/* 14 bytes of protocol address */
  };
  
! struct osf_iovec
! {
!   md_addr_t iov_base;		/* starting address */
!   word_t iov_len;		/* length in bytes */
!   word_t pad;
! };
! 
! /* returns size of DIRENT structure */
! #define OSF_DIRENT_SZ(STR)						\
!   (sizeof(word_t) + 2*sizeof(half_t) + (((strlen(STR) + 1) + 3)/4)*4)
!   /* was: (sizeof(word_t) + 2*sizeof(half_t) + strlen(STR) + 1) */
! 
! struct osf_dirent
! {
!   word_t d_ino;			/* file number of entry */
!   half_t d_reclen;		/* length of this record */
!   half_t d_namlen;		/* length of string in d_name */
!   char d_name[256];		/* DUMMY NAME LENGTH */
! 				/* the real maximum length is */
! 				/* returned by pathconf() */
!                                 /* At this time, this MUST */
!                                 /* be 256 -- the kernel */
!                                 /* requires it */
! };
! 
! /* open(2) flags for Alpha/AXP OSF target, syscall.c automagically maps
     between these codes to/from host open(2) flags */
! #define OSF_O_RDONLY		0x0000
! #define OSF_O_WRONLY		0x0001
! #define OSF_O_RDWR		0x0002
! #define OSF_O_NONBLOCK		0x0004
! #define OSF_O_APPEND		0x0008
! #define OSF_O_CREAT		0x0200
! #define OSF_O_TRUNC		0x0400
! #define OSF_O_EXCL		0x0800
! #define OSF_O_NOCTTY		0x1000
! #define OSF_O_SYNC		0x4000
  
  /* open(2) flags translation table for SimpleScalar target */
  struct {
!   int osf_flag;
    int local_flag;
! } osf_flag_table[] = {
    /* target flag */	/* host flag */
  #ifdef _MSC_VER
!   { OSF_O_RDONLY,	_O_RDONLY },
!   { OSF_O_WRONLY,	_O_WRONLY },
!   { OSF_O_RDWR,		_O_RDWR },
!   { OSF_O_APPEND,	_O_APPEND },
!   { OSF_O_CREAT,	_O_CREAT },
!   { OSF_O_TRUNC,	_O_TRUNC },
!   { OSF_O_EXCL,		_O_EXCL },
  #ifdef _O_NONBLOCK
!   { OSF_O_NONBLOCK,	_O_NONBLOCK },
  #endif
  #ifdef _O_NOCTTY
!   { OSF_O_NOCTTY,	_O_NOCTTY },
  #endif
  #ifdef _O_SYNC
!   { OSF_O_SYNC,		_O_SYNC },
  #endif
  #else /* !_MSC_VER */
!   { OSF_O_RDONLY,	O_RDONLY },
!   { OSF_O_WRONLY,	O_WRONLY },
!   { OSF_O_RDWR,		O_RDWR },
!   { OSF_O_APPEND,	O_APPEND },
!   { OSF_O_CREAT,	O_CREAT },
!   { OSF_O_TRUNC,	O_TRUNC },
!   { OSF_O_EXCL,		O_EXCL },
!   { OSF_O_NONBLOCK,	O_NONBLOCK },
!   { OSF_O_NOCTTY,	O_NOCTTY },
  #ifdef O_SYNC
!   { OSF_O_SYNC,		O_SYNC },
  #endif
  #endif /* _MSC_VER */
  };
! #define OSF_NFLAGS	(sizeof(osf_flag_table)/sizeof(osf_flag_table[0]))
! 
! qword_t sigmask = 0;
! 
! qword_t sigaction_array[OSF_NSIG] =
!  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
! 
! /* setsockopt option names */
! #define OSF_SO_DEBUG		0x0001
! #define OSF_SO_ACCEPTCONN	0x0002
! #define OSF_SO_REUSEADDR	0x0004
! #define OSF_SO_KEEPALIVE	0x0008
! #define OSF_SO_DONTROUTE	0x0010
! #define OSF_SO_BROADCAST	0x0020
! #define OSF_SO_USELOOPBACK	0x0040
! #define OSF_SO_LINGER		0x0080
! #define OSF_SO_OOBINLINE	0x0100
! #define OSF_SO_REUSEPORT	0x0200
! 
! struct xlate_table_t sockopt_map[] =
! {
!   { OSF_SO_DEBUG,	SO_DEBUG },
! #ifdef SO_ACCEPTCONN
!   { OSF_SO_ACCEPTCONN,	SO_ACCEPTCONN },
! #endif
!   { OSF_SO_REUSEADDR,	SO_REUSEADDR },
!   { OSF_SO_KEEPALIVE,	SO_KEEPALIVE },
!   { OSF_SO_DONTROUTE,	SO_DONTROUTE },
!   { OSF_SO_BROADCAST,	SO_BROADCAST },
! #ifdef SO_USELOOPBACK
!   { OSF_SO_USELOOPBACK,	SO_USELOOPBACK },
! #endif
!   { OSF_SO_LINGER,	SO_LINGER },
!   { OSF_SO_OOBINLINE,	SO_OOBINLINE },
! #ifdef SO_REUSEPORT
!   { OSF_SO_REUSEPORT,	SO_REUSEPORT }
! #endif
! };
! 
! /* setsockopt TCP options */
! #define OSF_TCP_NODELAY		0x01 /* don't delay send to coalesce packets */
! #define OSF_TCP_MAXSEG		0x02 /* maximum segment size */
! #define OSF_TCP_RPTR2RXT	0x03 /* set repeat count for R2 RXT timer */
! #define OSF_TCP_KEEPIDLE	0x04 /* secs before initial keepalive probe */
! #define OSF_TCP_KEEPINTVL	0x05 /* seconds between keepalive probes */
! #define OSF_TCP_KEEPCNT		0x06 /* num of keepalive probes before drop */
! #define OSF_TCP_KEEPINIT	0x07 /* initial connect timeout (seconds) */
! #define OSF_TCP_PUSH		0x08 /* set push bit in outbnd data packets */
! #define OSF_TCP_NODELACK	0x09 /* don't delay send to coalesce packets */
! 
! struct xlate_table_t tcpopt_map[] =
! {
!   { OSF_TCP_NODELAY,	TCP_NODELAY },
!   { OSF_TCP_MAXSEG,	TCP_MAXSEG },
! #ifdef TCP_RPTR2RXT
!   { OSF_TCP_RPTR2RXT,	TCP_RPTR2RXT },
! #endif
! #ifdef TCP_KEEPIDLE
!   { OSF_TCP_KEEPIDLE,	TCP_KEEPIDLE },
! #endif
! #ifdef TCP_KEEPINTVL
!   { OSF_TCP_KEEPINTVL,	TCP_KEEPINTVL },
! #endif
! #ifdef TCP_KEEPCNT
!   { OSF_TCP_KEEPCNT,	TCP_KEEPCNT },
! #endif
! #ifdef TCP_KEEPINIT
!   { OSF_TCP_KEEPINIT,	TCP_KEEPINIT },
! #endif
! #ifdef TCP_PUSH
!   { OSF_TCP_PUSH,	TCP_PUSH },
! #endif
! #ifdef TCP_NODELACK
!   { OSF_TCP_NODELACK,	TCP_NODELACK }
! #endif
! };
! 
! /* setsockopt level names */
! #define OSF_SOL_SOCKET		0xffff	/* options for socket level */
! #define OSF_SOL_IP		0	/* dummy for IP */
! #define OSF_SOL_TCP		6	/* tcp */
! #define OSF_SOL_UDP		17	/* user datagram protocol */
! 
! struct xlate_table_t socklevel_map[] =
! {
! #if defined(__svr4__) || defined(__osf__) || defined(__FreeBSD__)
!   { OSF_SOL_SOCKET,	SOL_SOCKET },
!   { OSF_SOL_IP,		IPPROTO_IP },
!   { OSF_SOL_TCP,	IPPROTO_TCP },
!   { OSF_SOL_UDP,	IPPROTO_UDP }
! #else
!   { OSF_SOL_SOCKET,	SOL_SOCKET },
!   { OSF_SOL_IP,		SOL_IP },
!   { OSF_SOL_TCP,	SOL_TCP },
!   { OSF_SOL_UDP,	SOL_UDP }
! #endif
! };
! 
! /* socket() address families */
! #define OSF_AF_UNSPEC		0
! #define OSF_AF_UNIX		1	/* Unix domain sockets */
! #define OSF_AF_INET		2	/* internet IP protocol */
! #define OSF_AF_IMPLINK		3	/* arpanet imp addresses */
! #define OSF_AF_PUP		4	/* pup protocols: e.g. BSP */
! #define OSF_AF_CHAOS		5	/* mit CHAOS protocols */
! #define OSF_AF_NS		6	/* XEROX NS protocols */
! #define OSF_AF_ISO		7	/* ISO protocols */
! 
! struct xlate_table_t family_map[] =
! {
!   { OSF_AF_UNSPEC,	AF_UNSPEC },
!   { OSF_AF_UNIX,	AF_UNIX },
!   { OSF_AF_INET,	AF_INET },
! #ifdef AF_IMPLINK
!   { OSF_AF_IMPLINK,	AF_IMPLINK },
! #endif
! #ifdef AF_PUP
!   { OSF_AF_PUP,		AF_PUP },
! #endif
! #ifdef AF_CHAOS
!   { OSF_AF_CHAOS,	AF_CHAOS },
! #endif
! #ifdef AF_NS
!   { OSF_AF_NS,		AF_NS },
! #endif
! #ifdef AF_ISO
!   { OSF_AF_ISO,		AF_ISO }
! #endif
! };
! 
! /* socket() socket types */
! #define OSF_SOCK_STREAM		1	/* stream (connection) socket */
! #define OSF_SOCK_DGRAM		2	/* datagram (conn.less) socket */
! #define OSF_SOCK_RAW		3	/* raw socket */
! #define OSF_SOCK_RDM		4	/* reliably-delivered message */
! #define OSF_SOCK_SEQPACKET	5	/* sequential packet socket */
! 
! struct xlate_table_t socktype_map[] =
! {
!   { OSF_SOCK_STREAM,	SOCK_STREAM },
!   { OSF_SOCK_DGRAM,	SOCK_DGRAM },
!   { OSF_SOCK_RAW,	SOCK_RAW },
!   { OSF_SOCK_RDM,	SOCK_RDM },
!   { OSF_SOCK_SEQPACKET,	SOCK_SEQPACKET }
! };
! 
! /* OSF table() call. Right now, we only support TBL_SYSINFO queries */
! #define OSF_TBL_SYSINFO		12
! struct osf_tbl_sysinfo 
! {
!   long si_user;		/* user time */
!   long si_nice;		/* nice time */
!   long si_sys;		/* system time */
!   long si_idle;		/* idle time */
!   long si_hz;
!   long si_phz;
!   long si_boottime;	/* boot time in seconds */
!   long wait;		/* wait time */
! };
  
  
- /* OSF SYSCALL -- standard system call sequence
-    the kernel expects arguments to be passed with the normal C calling
-    sequence; v0 should contain the system call number; on return from the
-    kernel mode, a3 will be 0 to indicate no error and non-zero to indicate an
-    error; if an error occurred v0 will contain an errno; if the kernel return
-    an error, setup a valid gp and jmp to _cerror */
  
  /* syscall proxy handler, architect registers and memory are assumed to be
     precise when this function is called, register and memory are updated with
--- 466,600 ----
     NUM_IOCTL_BYTES bytes from the pointer argument to host memory */
  #define NUM_IOCTL_BYTES		128
  
  /* target stat() buffer definition, the host stat buffer format is
     automagically mapped to/from this format in syscall.c */
! struct ss_statbuf
  {
!   shalf_t ss_st_dev;
!   shalf_t ss_pad;
!   word_t ss_st_ino;
!   half_t ss_st_mode;
!   shalf_t ss_st_nlink;
!   shalf_t ss_st_uid;
!   shalf_t ss_st_gid;
!   shalf_t ss_st_rdev;
!   shalf_t ss_pad1;
!   sword_t ss_st_size;
!   sword_t ss_st_atime;
!   sword_t ss_st_spare1;
!   sword_t ss_st_mtime;
!   sword_t ss_st_spare2;
!   sword_t ss_st_ctime;
!   sword_t ss_st_spare3;
!   sword_t ss_st_blksize;
!   sword_t ss_st_blocks;
!   word_t ss_st_gennum;
!   sword_t ss_st_spare4;
  };
  
! struct ss_sgttyb {
!   byte_t sg_ispeed;     /* input speed */
!   byte_t sg_ospeed;     /* output speed */
!   byte_t sg_erase;      /* erase character */
!   byte_t sg_kill;       /* kill character */
!   shalf_t sg_flags;     /* mode flags */
  };
  
! struct ss_timeval
  {
!   sword_t ss_tv_sec;		/* seconds */
!   sword_t ss_tv_usec;		/* microseconds */
  };
  
  /* target getrusage() buffer definition, the host stat buffer format is
     automagically mapped to/from this format in syscall.c */
! struct ss_rusage
  {
!   struct ss_timeval ss_ru_utime;
!   struct ss_timeval ss_ru_stime;
!   sword_t ss_ru_maxrss;
!   sword_t ss_ru_ixrss;
!   sword_t ss_ru_idrss;
!   sword_t ss_ru_isrss;
!   sword_t ss_ru_minflt;
!   sword_t ss_ru_majflt;
!   sword_t ss_ru_nswap;
!   sword_t ss_ru_inblock;
!   sword_t ss_ru_oublock;
!   sword_t ss_ru_msgsnd;
!   sword_t ss_ru_msgrcv;
!   sword_t ss_ru_nsignals;
!   sword_t ss_ru_nvcsw;
!   sword_t ss_ru_nivcsw;
  };
  
! struct ss_timezone
  {
!   sword_t ss_tz_minuteswest;	/* minutes west of Greenwich */
!   sword_t ss_tz_dsttime;	/* type of dst correction */
  };
  
! struct ss_rlimit
  {
!   int ss_rlim_cur;		/* current (soft) limit */
!   int ss_rlim_max;		/* maximum value for rlim_cur */
  };
  
! /* open(2) flags for SimpleScalar target, syscall.c automagically maps
     between these codes to/from host open(2) flags */
! #define SS_O_RDONLY		0
! #define SS_O_WRONLY		1
! #define SS_O_RDWR		2
! #define SS_O_APPEND		0x0008
! #define SS_O_CREAT		0x0200
! #define SS_O_TRUNC		0x0400
! #define SS_O_EXCL		0x0800
! #define SS_O_NONBLOCK		0x4000
! #define SS_O_NOCTTY		0x8000
! #define SS_O_SYNC		0x2000
  
  /* open(2) flags translation table for SimpleScalar target */
  struct {
!   int ss_flag;
    int local_flag;
! } ss_flag_table[] = {
    /* target flag */	/* host flag */
  #ifdef _MSC_VER
!   { SS_O_RDONLY,	_O_RDONLY },
!   { SS_O_WRONLY,	_O_WRONLY },
!   { SS_O_RDWR,		_O_RDWR },
!   { SS_O_APPEND,	_O_APPEND },
!   { SS_O_CREAT,		_O_CREAT },
!   { SS_O_TRUNC,		_O_TRUNC },
!   { SS_O_EXCL,		_O_EXCL },
  #ifdef _O_NONBLOCK
!   { SS_O_NONBLOCK,	_O_NONBLOCK },
  #endif
  #ifdef _O_NOCTTY
!   { SS_O_NOCTTY,	_O_NOCTTY },
  #endif
  #ifdef _O_SYNC
!   { SS_O_SYNC,		_O_SYNC },
  #endif
  #else /* !_MSC_VER */
!   { SS_O_RDONLY,	O_RDONLY },
!   { SS_O_WRONLY,	O_WRONLY },
!   { SS_O_RDWR,		O_RDWR },
!   { SS_O_APPEND,	O_APPEND },
!   { SS_O_CREAT,		O_CREAT },
!   { SS_O_TRUNC,		O_TRUNC },
!   { SS_O_EXCL,		O_EXCL },
!   { SS_O_NONBLOCK,	O_NONBLOCK },
!   { SS_O_NOCTTY,	O_NOCTTY },
  #ifdef O_SYNC
!   { SS_O_SYNC,		O_SYNC },
  #endif
  #endif /* _MSC_VER */
  };
! #define SS_NFLAGS	(sizeof(ss_flag_table)/sizeof(ss_flag_table[0]))
  
+ #endif /* !MD_CROSS_ENDIAN */
  
  
  /* syscall proxy handler, architect registers and memory are assumed to be
     precise when this function is called, register and memory are updated with
***************
*** 927,1048 ****
  	    md_inst_t inst,		/* system call inst */
  	    int traceable)		/* traceable system call? */
  {
!   qword_t syscode = regs->regs_R[MD_REG_V0];
! 
!   /* fix for syscall() which uses CALL_PAL CALLSYS for making system calls */
!   if (syscode == OSF_SYS_syscall)
!     syscode = regs->regs_R[MD_REG_A0];
  
    /* first, check if an EIO trace is being consumed... */
    if (traceable && sim_eio_fd != NULL)
      {
        eio_read_trace(sim_eio_fd, sim_num_insn, regs, mem_fn, mem, inst);
  
-       /* kludge fix for sigreturn(), it modifies all registers */
-       if (syscode == OSF_SYS_sigreturn)
- 	{
- 	  int i;
- 	  struct osf_sigcontext sc;
- 	  md_addr_t sc_addr = regs->regs_R[MD_REG_A0];
- 
- 	  mem_bcopy(mem_fn, mem, Read, sc_addr, 
- 		    &sc, sizeof(struct osf_sigcontext));
- 	  regs->regs_NPC = sc.sc_pc;
- 	  for (i=0; i < 32; ++i)
- 	    regs->regs_R[i] = sc.sc_regs[i];
- 	  for (i=0; i < 32; ++i)
- 	    regs->regs_F.q[i] = sc.sc_fpregs[i];
- 	  regs->regs_C.fpcr = sc.sc_fpcr;
- 	}
- 
        /* fini... */
        return;
      }
  
    /* no, OK execute the live system call... */
    switch (syscode)
      {
!     case OSF_SYS_exit:
        /* exit jumps to the target set in main() */
!       longjmp(sim_exit_buf,
! 	      /* exitcode + fudge */(regs->regs_R[MD_REG_A0] & 0xff) + 1);
        break;
  
!     case OSF_SYS_read:
        {
  	char *buf;
  
  	/* allocate same-sized input buffer in host memory */
! 	if (!(buf =
! 	      (char *)calloc(/*nbytes*/regs->regs_R[MD_REG_A2], sizeof(char))))
  	  fatal("out of memory in SYS_read");
  
  	/* read data from file */
! 	do {
! 	  /*nread*/regs->regs_R[MD_REG_V0] =
! 	    read(/*fd*/regs->regs_R[MD_REG_A0], buf,
! 	         /*nbytes*/regs->regs_R[MD_REG_A2]);
! 	} while (/*nread*/regs->regs_R[MD_REG_V0] == -1
! 	         && errno == EAGAIN);
  
  	/* check for error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
  
  	/* copy results back into host memory */
! 	mem_bcopy(mem_fn, mem, Write,
! 		  /*buf*/regs->regs_R[MD_REG_A1], buf, /*nread*/regs->regs_R[MD_REG_A2]);
  
  	/* done with input buffer */
  	free(buf);
        }
        break;
  
!     case OSF_SYS_write:
        {
  	char *buf;
  
  	/* allocate same-sized output buffer in host memory */
! 	if (!(buf =
! 	      (char *)calloc(/*nbytes*/regs->regs_R[MD_REG_A2], sizeof(char))))
  	  fatal("out of memory in SYS_write");
  
  	/* copy inputs into host memory */
! 	mem_bcopy(mem_fn, mem, Read, /*buf*/regs->regs_R[MD_REG_A1], buf,
! 		  /*nbytes*/regs->regs_R[MD_REG_A2]);
  
  	/* write data to file */
  	if (sim_progfd && MD_OUTPUT_SYSCALL(regs))
  	  {
  	    /* redirect program output to file */
  
! 	    /*nwritten*/regs->regs_R[MD_REG_V0] =
! 	      fwrite(buf, 1, /*nbytes*/regs->regs_R[MD_REG_A2], sim_progfd);
  	  }
  	else
  	  {
  	    /* perform program output request */
  
! 	    do {
! 	      /*nwritten*/regs->regs_R[MD_REG_V0] =
! 	        write(/*fd*/regs->regs_R[MD_REG_A0],
! 		      buf, /*nbytes*/regs->regs_R[MD_REG_A2]);
! 	    } while (/*nwritten*/regs->regs_R[MD_REG_V0] == -1
! 		     && errno == EAGAIN);
  	  }
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] == regs->regs_R[MD_REG_A2])
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
  
  	/* done with output buffer */
--- 606,744 ----
  	    md_inst_t inst,		/* system call inst */
  	    int traceable)		/* traceable system call? */
  {
!   word_t syscode = regs->regs_R[2];
  
    /* first, check if an EIO trace is being consumed... */
    if (traceable && sim_eio_fd != NULL)
      {
        eio_read_trace(sim_eio_fd, sim_num_insn, regs, mem_fn, mem, inst);
  
        /* fini... */
        return;
      }
+ #ifdef MD_CROSS_ENDIAN
+   else if (syscode == SS_SYS_exit)
+     {
+       /* exit jumps to the target set in main() */
+       longjmp(sim_exit_buf, /* exitcode + fudge */regs->regs_R[4]+1);
+     }
+   else
+     fatal("cannot execute PISA system call on cross-endian host");
+ 
+ #else /* !MD_CROSS_ENDIAN */
  
    /* no, OK execute the live system call... */
    switch (syscode)
      {
!     case SS_SYS_exit:
        /* exit jumps to the target set in main() */
!       longjmp(sim_exit_buf, /* exitcode + fudge */regs->regs_R[4]+1);
!       break;
! 
! #if 0
!     case SS_SYS_fork:
!       /* FIXME: this is broken... */
!       regs->regs_R[2] = fork();
!       if (regs->regs_R[2] != -1)
! 	{
! 	  regs->regs_R[7] = 0;
! 	  /* parent process */
! 	  if (regs->regs_R[2] != 0)
! 	  regs->regs_R[3] = 0;
! 	}
!       else
! 	fatal("SYS_fork failed");
!       break;
! #endif
! 
! #if 0
!     case SS_SYS_vfork:
!       /* FIXME: this is broken... */
!       int r31_parent = regs->regs_R[31];
!       /* pid */regs->regs_R[2] = vfork();
!       if (regs->regs_R[2] != -1)
! 	regs->regs_R[7] = 0;
!       else
! 	fatal("vfork() in SYS_vfork failed");
!       if (regs->regs_R[2] != 0)
! 	{
! 	  regs->regs_R[3] = 0;
! 	  regs->regs_R[7] = 0;
! 	  regs->regs_R[31] = r31_parent;
! 	}
        break;
+ #endif
  
!     case SS_SYS_read:
        {
  	char *buf;
  
  	/* allocate same-sized input buffer in host memory */
! 	if (!(buf = (char *)calloc(/*nbytes*/regs->regs_R[6], sizeof(char))))
  	  fatal("out of memory in SYS_read");
  
  	/* read data from file */
! 	/*nread*/regs->regs_R[2] =
! 	  read(/*fd*/regs->regs_R[4], buf, /*nbytes*/regs->regs_R[6]);
  
  	/* check for error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
  
  	/* copy results back into host memory */
! 	mem_bcopy(mem_fn, mem,
! 		  Write, /*buf*/regs->regs_R[5],
! 		  buf, /*nread*/regs->regs_R[2]);
  
  	/* done with input buffer */
  	free(buf);
        }
        break;
  
!     case SS_SYS_write:
        {
  	char *buf;
  
  	/* allocate same-sized output buffer in host memory */
! 	if (!(buf = (char *)calloc(/*nbytes*/regs->regs_R[6], sizeof(char))))
  	  fatal("out of memory in SYS_write");
  
  	/* copy inputs into host memory */
! 	mem_bcopy(mem_fn, mem,
! 		  Read, /*buf*/regs->regs_R[5],
! 		  buf, /*nbytes*/regs->regs_R[6]);
  
  	/* write data to file */
  	if (sim_progfd && MD_OUTPUT_SYSCALL(regs))
  	  {
  	    /* redirect program output to file */
  
! 	    /*nwritten*/regs->regs_R[2] =
! 	      fwrite(buf, 1, /*nbytes*/regs->regs_R[6], sim_progfd);
  	  }
  	else
  	  {
  	    /* perform program output request */
  
! 	    /*nwritten*/regs->regs_R[2] =
! 	      write(/*fd*/regs->regs_R[4],
! 		    buf, /*nbytes*/regs->regs_R[6]);
  	  }
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] == regs->regs_R[6])
! 	  /*result*/regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
  
  	/* done with output buffer */
***************
*** 1050,1541 ****
        }
        break;
  
! #if !defined(MIN_SYSCALL_MODE)
!       /* ADDED BY CALDER 10/27/99 */
!     case OSF_SYS_getdomainname:
!       /* get program scheduling priority */
!       {
! 	char *buf;
! 
! 	buf = malloc(/* len */(size_t)regs->regs_R[MD_REG_A1]);
! 	if (!buf)
! 	  fatal("out of virtual memory in gethostname()");
! 
! 	/* result */regs->regs_R[MD_REG_V0] =
! 	  getdomainname(/* name */buf,
! 		      /* len */(size_t)regs->regs_R[MD_REG_A1]);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 
! 	/* copy string back to simulated memory */
! 	mem_bcopy(mem_fn, mem, Write,
! 		  /* name */regs->regs_R[MD_REG_A0],
! 		  buf, /* len */regs->regs_R[MD_REG_A1]);
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!       /* ADDED BY CALDER 10/27/99 */
!     case OSF_SYS_flock:
!       /* get flock() information on the file */
!       {
! 	regs->regs_R[MD_REG_V0] =
! 	  flock(/*fd*/(int)regs->regs_R[MD_REG_A0],
! 		/*cmd*/(int)regs->regs_R[MD_REG_A1]);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!       /* ADDED BY CALDER 10/27/99 */
!     case OSF_SYS_bind:
!       {
! 	const struct sockaddr a_sock;
! 
! 	mem_bcopy(mem_fn, mem, Read, /* serv_addr */regs->regs_R[MD_REG_A1],
! 		  (void *)&a_sock, /* addrlen */(int)regs->regs_R[MD_REG_A2]);
! 
!       regs->regs_R[MD_REG_V0] =
! 	bind((int) regs->regs_R[MD_REG_A0],
! 	     &a_sock,(int) regs->regs_R[MD_REG_A2]);
! 
!       /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
! 	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
! 	}
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!       /* ADDED BY CALDER 10/27/99 */
!     case OSF_SYS_sendto:
!       {
! 	char *buf = NULL;
! 	struct sockaddr d_sock;
! 	int buf_len = 0;
! 
! 	buf_len = regs->regs_R[MD_REG_A2];
! 
! 	if (buf_len > 0)
! 	  buf = (char *) malloc(buf_len*sizeof(char));
! 
! 	mem_bcopy(mem_fn, mem, Read, /* serv_addr */regs->regs_R[MD_REG_A1],
! 		  buf, /* addrlen */(int)regs->regs_R[MD_REG_A2]);
! 
! 	if (regs->regs_R[MD_REG_A5] > 0) 
! 	  mem_bcopy(mem_fn, mem, Read, regs->regs_R[MD_REG_A4],
! 		    &d_sock, (int)regs->regs_R[MD_REG_A5]);
! 
! 	regs->regs_R[MD_REG_V0] =
! 	  sendto((int) regs->regs_R[MD_REG_A0],
! 		 buf,(int) regs->regs_R[MD_REG_A2],
! 		 (int) regs->regs_R[MD_REG_A3],
! 		 &d_sock,(int) regs->regs_R[MD_REG_A5]);
! 
! 	mem_bcopy(mem_fn, mem, Write, /* serv_addr */regs->regs_R[MD_REG_A1],
! 		  buf, /* addrlen */(int)regs->regs_R[MD_REG_A2]);
! 
! 	/* maybe copy back whole size of sockaddr */
! 	if (regs->regs_R[MD_REG_A5] > 0)
! 	  mem_bcopy(mem_fn, mem, Write, regs->regs_R[MD_REG_A4],
! 		    &d_sock, (int)regs->regs_R[MD_REG_A5]);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 
! 	if (buf != NULL) 
! 	  free(buf);
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!       /* ADDED BY CALDER 10/27/99 */
!     case OSF_SYS_old_recvfrom:
!     case OSF_SYS_recvfrom:
!       {
! 	int addr_len;
! 	char *buf;
! 	struct sockaddr *a_sock;
!       
! 	buf = (char *) malloc(sizeof(char)*regs->regs_R[MD_REG_A2]);
! 
! 	mem_bcopy(mem_fn, mem, Read, /* serv_addr */regs->regs_R[MD_REG_A1],
! 		  buf, /* addrlen */(int)regs->regs_R[MD_REG_A2]);
! 
! 	mem_bcopy(mem_fn, mem, Read, /* serv_addr */regs->regs_R[MD_REG_A5],
! 		  &addr_len, sizeof(int));
! 
! 	a_sock = (struct sockaddr *)malloc(addr_len);
! 
! 	mem_bcopy(mem_fn, mem, Read, regs->regs_R[MD_REG_A4],
! 		  a_sock, addr_len);
! 
! 	regs->regs_R[MD_REG_V0] =
! 	  recvfrom((int) regs->regs_R[MD_REG_A0],
! 		   buf,(int) regs->regs_R[MD_REG_A2],
! 		   (int) regs->regs_R[MD_REG_A3], a_sock,&addr_len);
! 
! 	mem_bcopy(mem_fn, mem, Write, regs->regs_R[MD_REG_A1],
! 		  buf, (int) regs->regs_R[MD_REG_V0]);
! 
! 	mem_bcopy(mem_fn, mem, Write, /* serv_addr */regs->regs_R[MD_REG_A5],
! 		  &addr_len, sizeof(int));
! 
! 	mem_bcopy(mem_fn, mem, Write, regs->regs_R[MD_REG_A4],
! 		  a_sock, addr_len);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 	if (buf != NULL)
! 	  free(buf);
!       }
!       break;
! #endif
! 
!     case OSF_SYS_open:
        {
  	char buf[MAXBUFSIZE];
  	unsigned int i;
! 	int osf_flags = regs->regs_R[MD_REG_A1], local_flags = 0;
  
  	/* translate open(2) flags */
! 	for (i=0; i < OSF_NFLAGS; i++)
  	  {
! 	    if (osf_flags & osf_flag_table[i].osf_flag)
  	      {
! 		osf_flags &= ~osf_flag_table[i].osf_flag;
! 		local_flags |= osf_flag_table[i].local_flag;
  	      }
  	  }
  	/* any target flags left? */
! 	if (osf_flags != 0)
! 	  fatal("syscall: open: cannot decode flags: 0x%08x", osf_flags);
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[MD_REG_A0], buf);
  
  	/* open the file */
! 	/*fd*/regs->regs_R[MD_REG_V0] =
! 	  open(buf, local_flags, /*mode*/regs->regs_R[MD_REG_A2]);
  	
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
        }
        break;
  
!     case OSF_SYS_close:
        /* don't close stdin, stdout, or stderr as this messes up sim logs */
!       if (/*fd*/regs->regs_R[MD_REG_A0] == 0
! 	  || /*fd*/regs->regs_R[MD_REG_A0] == 1
! 	  || /*fd*/regs->regs_R[MD_REG_A0] == 2)
  	{
! 	  regs->regs_R[MD_REG_A3] = 0;
  	  break;
  	}
  
        /* close the file */
!       regs->regs_R[MD_REG_V0] = close(/*fd*/regs->regs_R[MD_REG_A0]);
  
        /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
  	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
  	}
        break;
  
! #if 0
!     case OSF_SYS_creat:
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, Read, /*fname*/regs->regs_R[MD_REG_A0], buf);
  
  	/* create the file */
! 	/*fd*/regs->regs_R[MD_REG_V0] =
! 	  creat(buf, /*mode*/regs->regs_R[MD_REG_A1]);
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
        }
        break;
- #endif
  
!     case OSF_SYS_unlink:
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[MD_REG_A0], buf);
  
  	/* delete the file */
! 	/*result*/regs->regs_R[MD_REG_V0] = unlink(buf);
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
        }
        break;
  
!     case OSF_SYS_chdir:
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[MD_REG_A0], buf);
  
  	/* change the working directory */
! 	/*result*/regs->regs_R[MD_REG_V0] = chdir(buf);
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
        }
        break;
  
!     case OSF_SYS_chmod:
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[MD_REG_A0], buf);
  
  	/* chmod the file */
! 	/*result*/regs->regs_R[MD_REG_V0] =
! 	  chmod(buf, /*mode*/regs->regs_R[MD_REG_A1]);
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
        }
        break;
  
!     case OSF_SYS_chown:
  #ifdef _MSC_VER
        warn("syscall chown() not yet implemented for MSC...");
!       regs->regs_R[MD_REG_A3] = 0;
  #else /* !_MSC_VER */
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem,Read, /*fname*/regs->regs_R[MD_REG_A0], buf);
  
  	/* chown the file */
! 	/*result*/regs->regs_R[MD_REG_V0] =
! 	  chown(buf, /*owner*/regs->regs_R[MD_REG_A1],
! 		/*group*/regs->regs_R[MD_REG_A2]);
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
        }
  #endif /* _MSC_VER */
        break;
  
!     case OSF_SYS_sbrk:
        {
- 	sqword_t delta;
  	md_addr_t addr;
  
! 	delta = regs->regs_R[MD_REG_A0];
! 	addr = ld_brk_point + delta;
  
- 	if (verbose)
- 	  myfprintf(stderr, "SYS_sbrk: delta: 0x%012p (%ld)\n", delta, delta);
- 
- 	ld_brk_point = addr;
- 	regs->regs_R[MD_REG_V0] = ld_brk_point;
- 	regs->regs_R[MD_REG_A3] = 0;
- 
- 	if (verbose)
- 	  myfprintf(stderr, "ld_brk_point: 0x%012p\n", ld_brk_point);
- 
- #if 0
  	/* check whether heap area has merged with stack area */
! 	if (/* addr >= ld_brk_point && */ addr < regs->regs_R[MD_REG_SP])
  	  {
! 	    regs->regs_R[MD_REG_A3] = 0;
  	    ld_brk_point = addr;
  	  }
  	else
  	  {
  	    /* out of address space, indicate error */
! 	    regs->regs_R[MD_REG_A3] = -1;
  	  }
- #endif
-       }
-       break;
- 
-     case OSF_SYS_obreak:
-       {
-         md_addr_t addr;
- 
-         /* round the new heap pointer to the its page boundary */
- #if 0
-         addr = ROUND_UP(/*base*/regs->regs_R[MD_REG_A0], MD_PAGE_SIZE);
- #endif
-         addr = /*base*/regs->regs_R[MD_REG_A0];
- 
- 	if (verbose)
- 	  myfprintf(stderr, "SYS_obreak: addr: 0x%012p\n", addr);
- 
- 	ld_brk_point = addr;
- 	regs->regs_R[MD_REG_V0] = ld_brk_point;
- 	regs->regs_R[MD_REG_A3] = 0;
- 
- 	if (verbose)
- 	  myfprintf(stderr, "ld_brk_point: 0x%012p\n", ld_brk_point);
        }
        break;
  
!     case OSF_SYS_lseek:
        /* seek into file */
!       regs->regs_R[MD_REG_V0] =
! 	lseek(/*fd*/regs->regs_R[MD_REG_A0],
! 	      /*off*/regs->regs_R[MD_REG_A1], /*dir*/regs->regs_R[MD_REG_A2]);
  
        /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
  	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
  	}
        break;
  
!     case OSF_SYS_getpid:
        /* get the simulator process id */
!       /*result*/regs->regs_R[MD_REG_V0] = getpid();
  
        /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
  	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
  	}
        break;
  
!     case OSF_SYS_getuid:
  #ifdef _MSC_VER
        warn("syscall getuid() not yet implemented for MSC...");
!       regs->regs_R[MD_REG_A3] = 0;
  #else /* !_MSC_VER */
        /* get current user id */
!       /*first result*/regs->regs_R[MD_REG_V0] = getuid();
!       /*second result*/regs->regs_R[MD_REG_A4] = geteuid();
  
        /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
  	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
  	}
  #endif /* _MSC_VER */
        break;
  
!     case OSF_SYS_access:
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fName*/regs->regs_R[MD_REG_A0], buf);
  
  	/* check access on the file */
! 	/*result*/regs->regs_R[MD_REG_V0] =
! 	  access(buf, /*mode*/regs->regs_R[MD_REG_A1]);
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
        }
        break;
  
!     case OSF_SYS_stat:
!     case OSF_SYS_lstat:
        {
  	char buf[MAXBUFSIZE];
! 	struct osf_statbuf osf_sbuf;
  #ifdef _MSC_VER
  	struct _stat sbuf;
  #else /* !_MSC_VER */
--- 746,1034 ----
        }
        break;
  
!     case SS_SYS_open:
        {
  	char buf[MAXBUFSIZE];
  	unsigned int i;
! 	int ss_flags = regs->regs_R[5], local_flags = 0;
  
  	/* translate open(2) flags */
! 	for (i=0; i<SS_NFLAGS; i++)
  	  {
! 	    if (ss_flags & ss_flag_table[i].ss_flag)
  	      {
! 		ss_flags &= ~ss_flag_table[i].ss_flag;
! 		local_flags |= ss_flag_table[i].local_flag;
  	      }
  	  }
  	/* any target flags left? */
! 	if (ss_flags != 0)
! 	  fatal("syscall: open: cannot decode flags: 0x%08x", ss_flags);
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[4], buf);
  
  	/* open the file */
! 	/*fd*/regs->regs_R[2] =
! 	  open(buf, local_flags, /*mode*/regs->regs_R[6]);
  	
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
        }
        break;
  
!     case SS_SYS_close:
        /* don't close stdin, stdout, or stderr as this messes up sim logs */
!       if (/*fd*/regs->regs_R[4] == 0
! 	  || /*fd*/regs->regs_R[4] == 1
! 	  || /*fd*/regs->regs_R[4] == 2)
  	{
! 	  regs->regs_R[7] = 0;
  	  break;
  	}
  
        /* close the file */
!       regs->regs_R[2] = close(/*fd*/regs->regs_R[4]);
  
        /* check for an error condition */
!       if (regs->regs_R[2] != -1)
! 	regs->regs_R[7] = 0;
!       else
  	{
! 	  /* got an error, return details */
! 	  regs->regs_R[2] = errno;
! 	  regs->regs_R[7] = 1;
  	}
        break;
  
!     case SS_SYS_creat:
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[4], buf);
  
  	/* create the file */
! 	/*fd*/regs->regs_R[2] = creat(buf, /*mode*/regs->regs_R[5]);
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
        }
        break;
  
!     case SS_SYS_unlink:
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[4], buf);
  
  	/* delete the file */
! 	/*result*/regs->regs_R[2] = unlink(buf);
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
        }
        break;
  
!     case SS_SYS_chdir:
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[4], buf);
  
  	/* change the working directory */
! 	/*result*/regs->regs_R[2] = chdir(buf);
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
        }
        break;
  
!     case SS_SYS_chmod:
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[4], buf);
  
  	/* chmod the file */
! 	/*result*/regs->regs_R[2] = chmod(buf, /*mode*/regs->regs_R[5]);
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
        }
        break;
  
!     case SS_SYS_chown:
  #ifdef _MSC_VER
        warn("syscall chown() not yet implemented for MSC...");
!       regs->regs_R[7] = 0;
  #else /* !_MSC_VER */
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[4], buf);
  
  	/* chown the file */
! 	/*result*/regs->regs_R[2] = chown(buf, /*owner*/regs->regs_R[5],
! 				    /*group*/regs->regs_R[6]);
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
        }
  #endif /* _MSC_VER */
        break;
  
!     case SS_SYS_brk:
        {
  	md_addr_t addr;
  
! 	/* round the new heap pointer to the its page boundary */
! 	addr = ROUND_UP(/*base*/regs->regs_R[4], MD_PAGE_SIZE);
  
  	/* check whether heap area has merged with stack area */
! 	if (addr >= ld_brk_point && addr < (md_addr_t)regs->regs_R[29])
  	  {
! 	    regs->regs_R[2] = 0;
! 	    regs->regs_R[7] = 0;
  	    ld_brk_point = addr;
  	  }
  	else
  	  {
  	    /* out of address space, indicate error */
! 	    regs->regs_R[2] = ENOMEM;
! 	    regs->regs_R[7] = 1;
  	  }
        }
        break;
  
!     case SS_SYS_lseek:
        /* seek into file */
!       regs->regs_R[2] =
! 	lseek(/*fd*/regs->regs_R[4],
! 	      /*off*/regs->regs_R[5], /*dir*/regs->regs_R[6]);
  
        /* check for an error condition */
!       if (regs->regs_R[2] != -1)
! 	regs->regs_R[7] = 0;
!       else
  	{
! 	  /* got an error, return details */
! 	  regs->regs_R[2] = errno;
! 	  regs->regs_R[7] = 1;
  	}
        break;
  
!     case SS_SYS_getpid:
        /* get the simulator process id */
!       /*result*/regs->regs_R[2] = getpid();
  
        /* check for an error condition */
!       if (regs->regs_R[2] != -1)
! 	regs->regs_R[7] = 0;
!       else
  	{
! 	  /* got an error, return details */
! 	  regs->regs_R[2] = errno;
! 	  regs->regs_R[7] = 1;
  	}
        break;
  
!     case SS_SYS_getuid:
  #ifdef _MSC_VER
        warn("syscall getuid() not yet implemented for MSC...");
!       regs->regs_R[7] = 0;
  #else /* !_MSC_VER */
        /* get current user id */
!       /*first result*/regs->regs_R[2] = getuid();
! 
!       /* get effective user id */
!       /*second result*/regs->regs_R[3] = geteuid();
  
        /* check for an error condition */
!       if (regs->regs_R[2] != -1)
! 	regs->regs_R[7] = 0;
!       else
  	{
! 	  /* got an error, return details */
! 	  regs->regs_R[2] = errno;
! 	  regs->regs_R[7] = 1;
  	}
  #endif /* _MSC_VER */
        break;
  
!     case SS_SYS_access:
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fName*/regs->regs_R[4], buf);
  
  	/* check access on the file */
! 	/*result*/regs->regs_R[2] = access(buf, /*mode*/regs->regs_R[5]);
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
        }
        break;
  
!     case SS_SYS_stat:
!     case SS_SYS_lstat:
        {
  	char buf[MAXBUFSIZE];
! 	struct ss_statbuf ss_sbuf;
  #ifdef _MSC_VER
  	struct _stat sbuf;
  #else /* !_MSC_VER */
***************
*** 1543,1806 ****
  #endif /* _MSC_VER */
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fName*/regs->regs_R[MD_REG_A0], buf);
  
  	/* stat() the file */
! 	if (syscode == OSF_SYS_stat)
! 	  /*result*/regs->regs_R[MD_REG_V0] = stat(buf, &sbuf);
! 	else /* syscode == OSF_SYS_lstat */
  	  {
  #ifdef _MSC_VER
!             warn("syscall lstat() not yet implemented for MSC...");
!             regs->regs_R[MD_REG_A3] = 0;
!             break;
  #else /* !_MSC_VER */
! 	    /*result*/regs->regs_R[MD_REG_V0] = lstat(buf, &sbuf);
  #endif /* _MSC_VER */
  	  }
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
  
  	/* translate from host stat structure to target format */
! 	osf_sbuf.osf_st_dev = MD_SWAPW(sbuf.st_dev);
! 	osf_sbuf.osf_st_ino = MD_SWAPW(sbuf.st_ino);
! 	osf_sbuf.osf_st_mode = MD_SWAPW(sbuf.st_mode);
! 	osf_sbuf.osf_st_nlink = MD_SWAPH(sbuf.st_nlink);
! 	osf_sbuf.osf_st_uid = MD_SWAPW(sbuf.st_uid);
! 	osf_sbuf.osf_st_gid = MD_SWAPW(sbuf.st_gid);
! 	osf_sbuf.osf_st_rdev = MD_SWAPW(sbuf.st_rdev);
! 	osf_sbuf.osf_st_size = MD_SWAPQ(sbuf.st_size);
! 	osf_sbuf.osf_st_atime = MD_SWAPW(sbuf.st_atime);
! 	osf_sbuf.osf_st_mtime = MD_SWAPW(sbuf.st_mtime);
! 	osf_sbuf.osf_st_ctime = MD_SWAPW(sbuf.st_ctime);
  #ifndef _MSC_VER
! 	osf_sbuf.osf_st_blksize = MD_SWAPW(sbuf.st_blksize);
! 	osf_sbuf.osf_st_blocks = MD_SWAPW(sbuf.st_blocks);
  #endif /* !_MSC_VER */
  
  	/* copy stat() results to simulator memory */
! 	mem_bcopy(mem_fn, mem, Write, /*sbuf*/regs->regs_R[MD_REG_A1],
! 		  &osf_sbuf, sizeof(struct osf_statbuf));
        }
        break;
  
!     case OSF_SYS_dup:
        /* dup() the file descriptor */
!       /*fd*/regs->regs_R[MD_REG_V0] = dup(/*fd*/regs->regs_R[MD_REG_A0]);
  
        /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
  	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
  	}
        break;
  
! #if 0
!     case OSF_SYS_pipe:
        {
  	int fd[2];
  
  	/* copy pipe descriptors to host memory */;
! 	mem_bcopy(mem_fn, mem, Read, /*fd's*/regs->regs_R[MD_REG_A0],
! 		  fd, sizeof(fd));
  
  	/* create a pipe */
  	/*result*/regs->regs_R[7] = pipe(fd);
  
  	/* copy descriptor results to result registers */
! 	/*pipe1*/regs->regs_R[MD_REG_V0] = fd[0];
  	/*pipe 2*/regs->regs_R[3] = fd[1];
  
  	/* check for an error condition */
! 	if (regs->regs_R[7] == (qword_t)-1)
  	  {
! 	    regs->regs_R[MD_REG_V0] = errno;
  	    regs->regs_R[7] = 1;
  	  }
        }
        break;
  #endif
  
!     case OSF_SYS_getgid:
  #ifdef _MSC_VER
        warn("syscall getgid() not yet implemented for MSC...");
!       regs->regs_R[MD_REG_A3] = 0;
  #else /* !_MSC_VER */
        /* get current group id */
!       /*first result*/regs->regs_R[MD_REG_V0] = getgid();
!       /*second result*/regs->regs_R[MD_REG_A4] = getegid();
  
!       /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
  	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
  	}
  #endif /* _MSC_VER */
        break;
  
!     case OSF_SYS_ioctl:
!       switch (/* req */regs->regs_R[MD_REG_A1])
! 	{
! #if !defined(TIOCGETP) && (defined(linux) || defined(__CYGWIN32__))
! 	case OSF_TIOCGETP: /* <Out,TIOCGETP,6> */
! 	  {
! 	    struct termios lbuf;
! 	    struct osf_sgttyb buf;
! 
! 	    /* result */regs->regs_R[MD_REG_V0] =
! 			  tcgetattr(/* fd */(int)regs->regs_R[MD_REG_A0],
! 				    &lbuf);
! 
! 	    /* translate results */
! 	    buf.sg_ispeed = lbuf.c_ispeed;
! 	    buf.sg_ospeed = lbuf.c_ospeed;
! 	    buf.sg_erase = lbuf.c_cc[VERASE];
! 	    buf.sg_kill = lbuf.c_cc[VKILL];
! 	    buf.sg_flags = 0;	/* FIXME: this is wrong... */
! 
! 	    mem_bcopy(mem_fn, mem, Write,
! 		      /* buf */regs->regs_R[MD_REG_A2], &buf,
! 		      sizeof(struct osf_sgttyb));
! 
! 	    if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	      regs->regs_R[MD_REG_A3] = 0;
! 	    else /* probably not a typewriter, return details */
! 	      {
! 		regs->regs_R[MD_REG_A3] = -1;
! 		regs->regs_R[MD_REG_V0] = errno;
! 	      }
! 	  }
! 	  break;
! #endif
! #ifdef TIOCGETP
! 	case OSF_TIOCGETP: /* <Out,TIOCGETP,6> */
! 	  {
! 	    struct sgttyb lbuf;
! 	    struct osf_sgttyb buf;
! 
! 	    /* result */regs->regs_R[MD_REG_V0] =
! 	      ioctl(/* fd */(int)regs->regs_R[MD_REG_A0],
! 		    /* req */TIOCGETP,
! 		    &lbuf);
! 
! 	    /* translate results */
! 	    buf.sg_ispeed = lbuf.sg_ispeed;
! 	    buf.sg_ospeed = lbuf.sg_ospeed;
! 	    buf.sg_erase = lbuf.sg_erase;
! 	    buf.sg_kill = lbuf.sg_kill;
! 	    buf.sg_flags = lbuf.sg_flags;
! 	    mem_bcopy(mem_fn, mem, Write,
! 		      /* buf */regs->regs_R[MD_REG_A2], &buf,
! 		      sizeof(struct osf_sgttyb));
! 
! 	    if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	      regs->regs_R[MD_REG_A3] = 0;
! 	    else /* not a typewriter, return details */
! 	      {
! 		regs->regs_R[MD_REG_A3] = -1;
! 		regs->regs_R[MD_REG_V0] = errno;
! 	      }
! 	  }
! 	  break;
! #endif
! #ifdef FIONREAD
! 	case OSF_FIONREAD:
! 	  {
! 	    int nread;
! 
! 	    /* result */regs->regs_R[MD_REG_V0] =
! 	      ioctl(/* fd */(int)regs->regs_R[MD_REG_A0],
! 		    /* req */FIONREAD,
! 		    /* arg */&nread);
! 
! 	    mem_bcopy(mem_fn, mem, Write,
! 		      /* arg */regs->regs_R[MD_REG_A2],
! 		      &nread, sizeof(nread));
! 
! 	    if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	      regs->regs_R[MD_REG_A3] = 0;
! 	    else /* not a typewriter, return details */
! 	      {
! 		regs->regs_R[MD_REG_A3] = -1;
! 		regs->regs_R[MD_REG_V0] = errno;
! 	      }
! 	  }
! 	  break;
! #endif
! #ifdef FIONBIO
! 	case /*FIXME*/FIONBIO:
! 	  {
! 	    int arg = 0;
! 
! 	    if (regs->regs_R[MD_REG_A2])
! 	      mem_bcopy(mem_fn, mem, Read,
! 		      /* arg */regs->regs_R[MD_REG_A2],
! 		      &arg, sizeof(arg));
! 
! #ifdef NOTNOW
! 	    fprintf(stderr, "FIONBIO: %d, %d\n",
! 		    (int)regs->regs_R[MD_REG_A0],
! 		    arg);
! #endif
! 	    /* result */regs->regs_R[MD_REG_V0] =
! 	      ioctl(/* fd */(int)regs->regs_R[MD_REG_A0],
! 		    /* req */FIONBIO,
! 		    /* arg */&arg);
! 
! 	    if (regs->regs_R[MD_REG_A2])
! 	      mem_bcopy(mem_fn, mem, Write,
! 		      /* arg */regs->regs_R[MD_REG_A2],
! 		      &arg, sizeof(arg));
! 
! 	    if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	      regs->regs_R[MD_REG_A3] = 0;
! 	    else /* not a typewriter, return details */
! 	      {
! 		regs->regs_R[MD_REG_A3] = -1;
! 		regs->regs_R[MD_REG_V0] = errno;
! 	      }
! 	  }
! 	  break;
! #endif
! 	default:
! 	  warn("unsupported ioctl call: ioctl(%ld, ...)",
! 	       regs->regs_R[MD_REG_A1]);
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	  break;
! 	}
!       break;
! 
! #if 0
        {
  	char buf[NUM_IOCTL_BYTES];
  	int local_req = 0;
  
  	/* convert target ioctl() request to host ioctl() request values */
! 	switch (/*req*/regs->regs_R[MD_REG_A1]) {
! /* #if !defined(__CYGWIN32__) */
  	case SS_IOCTL_TIOCGETP:
  	  local_req = TIOCGETP;
  	  break;
  	case SS_IOCTL_TIOCSETP:
  	  local_req = TIOCSETP;
  	  break;
  	case SS_IOCTL_TCGETP:
  	  local_req = TIOCGETP;
  	  break;
! /* #endif */
  #ifdef TCGETA
  	case SS_IOCTL_TCGETA:
  	  local_req = TCGETA;
--- 1036,1182 ----
  #endif /* _MSC_VER */
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fName*/regs->regs_R[4], buf);
  
  	/* stat() the file */
! 	if (syscode == SS_SYS_stat)
! 	  /*result*/regs->regs_R[2] = stat(buf, &sbuf);
! 	else /* syscode == SS_SYS_lstat */
  	  {
  #ifdef _MSC_VER
! 	    warn("syscall lstat() not yet implemented for MSC...");
! 	    regs->regs_R[7] = 0;
! 	    break;
  #else /* !_MSC_VER */
! 	    /*result*/regs->regs_R[2] = lstat(buf, &sbuf);
  #endif /* _MSC_VER */
  	  }
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
  
  	/* translate from host stat structure to target format */
! 	ss_sbuf.ss_st_dev = MD_SWAPH(sbuf.st_dev);
! 	ss_sbuf.ss_pad = 0;
! 	ss_sbuf.ss_st_ino = MD_SWAPW(sbuf.st_ino);
! 	ss_sbuf.ss_st_mode = MD_SWAPH(sbuf.st_mode);
! 	ss_sbuf.ss_st_nlink = MD_SWAPH(sbuf.st_nlink);
! 	ss_sbuf.ss_st_uid = MD_SWAPH(sbuf.st_uid);
! 	ss_sbuf.ss_st_gid = MD_SWAPH(sbuf.st_gid);
! 	ss_sbuf.ss_st_rdev = MD_SWAPH(sbuf.st_rdev);
! 	ss_sbuf.ss_pad1 = 0;
! 	ss_sbuf.ss_st_size = MD_SWAPW(sbuf.st_size);
! 	ss_sbuf.ss_st_atime = MD_SWAPW(sbuf.st_atime);
! 	ss_sbuf.ss_st_spare1 = 0;
! 	ss_sbuf.ss_st_mtime = MD_SWAPW(sbuf.st_mtime);
! 	ss_sbuf.ss_st_spare2 = 0;
! 	ss_sbuf.ss_st_ctime = MD_SWAPW(sbuf.st_ctime);
! 	ss_sbuf.ss_st_spare3 = 0;
  #ifndef _MSC_VER
! 	ss_sbuf.ss_st_blksize = MD_SWAPW(sbuf.st_blksize);
! 	ss_sbuf.ss_st_blocks = MD_SWAPW(sbuf.st_blocks);
  #endif /* !_MSC_VER */
+ 	ss_sbuf.ss_st_gennum = 0;
+ 	ss_sbuf.ss_st_spare4 = 0;
  
  	/* copy stat() results to simulator memory */
! 	mem_bcopy(mem_fn, mem, Write, /*sbuf*/regs->regs_R[5],
! 		  &ss_sbuf, sizeof(struct ss_statbuf));
        }
        break;
  
!     case SS_SYS_dup:
        /* dup() the file descriptor */
!       /*fd*/regs->regs_R[2] = dup(/*fd*/regs->regs_R[4]);
  
        /* check for an error condition */
!       if (regs->regs_R[2] != -1)
! 	regs->regs_R[7] = 0;
!       else
  	{
! 	  /* got an error, return details */
! 	  regs->regs_R[2] = errno;
! 	  regs->regs_R[7] = 1;
  	}
        break;
  
! #ifndef _MSC_VER
!     case SS_SYS_pipe:
        {
  	int fd[2];
  
  	/* copy pipe descriptors to host memory */;
! 	mem_bcopy(mem_fn, mem, Read, /*fd's*/regs->regs_R[4], fd, sizeof(fd));
  
  	/* create a pipe */
  	/*result*/regs->regs_R[7] = pipe(fd);
  
  	/* copy descriptor results to result registers */
! 	/*pipe1*/regs->regs_R[2] = fd[0];
  	/*pipe 2*/regs->regs_R[3] = fd[1];
  
  	/* check for an error condition */
! 	if (regs->regs_R[7] == -1)
  	  {
! 	    regs->regs_R[2] = errno;
  	    regs->regs_R[7] = 1;
  	  }
        }
        break;
  #endif
  
!     case SS_SYS_getgid:
  #ifdef _MSC_VER
        warn("syscall getgid() not yet implemented for MSC...");
!       regs->regs_R[7] = 0;
  #else /* !_MSC_VER */
        /* get current group id */
!       /*first result*/regs->regs_R[2] = getgid();
  
!       /* get current effective group id */
!       /*second result*/regs->regs_R[3] = getegid();
! 
! 	/* check for an error condition */
!       if (regs->regs_R[2] != -1)
! 	regs->regs_R[7] = 0;
!       else
  	{
! 	  /* got an error, return details */
! 	  regs->regs_R[2] = errno;
! 	  regs->regs_R[7] = 1;
  	}
  #endif /* _MSC_VER */
        break;
  
!     case SS_SYS_ioctl:
        {
  	char buf[NUM_IOCTL_BYTES];
  	int local_req = 0;
  
  	/* convert target ioctl() request to host ioctl() request values */
! 	switch (/*req*/regs->regs_R[5]) {
! #ifdef TIOCGETP
  	case SS_IOCTL_TIOCGETP:
  	  local_req = TIOCGETP;
  	  break;
+ #endif
+ #ifdef TIOCSETP
  	case SS_IOCTL_TIOCSETP:
  	  local_req = TIOCSETP;
  	  break;
+ #endif
+ #ifdef TIOCGETP
  	case SS_IOCTL_TCGETP:
  	  local_req = TIOCGETP;
  	  break;
! #endif
  #ifdef TCGETA
  	case SS_IOCTL_TCGETA:
  	  local_req = TCGETA;
***************
*** 1816,1824 ****
--- 1192,1202 ----
  	  local_req = TIOCSLTC;
  	  break;
  #endif
+ #ifdef TIOCGWINSZ
  	case SS_IOCTL_TIOCGWINSZ:
  	  local_req = TIOCGWINSZ;
  	  break;
+ #endif
  #ifdef TCSETAW
  	case SS_IOCTL_TCSETAW:
  	  local_req = TCSETAW;
***************
*** 1856,2363 ****
  #endif
  	}
  
  	if (!local_req)
  	  {
  	    /* FIXME: could not translate the ioctl() request, just warn user
  	       and ignore the request */
  	    warn("syscall: ioctl: ioctl code not supported d=%d, req=%d",
! 		 regs->regs_R[MD_REG_A0], regs->regs_R[MD_REG_A1]);
! 	    regs->regs_R[MD_REG_V0] = 0;
  	    regs->regs_R[7] = 0;
  	  }
  	else
  	  {
  	    /* ioctl() code was successfully translated to a host code */
  
  	    /* if arg ptr exists, copy NUM_IOCTL_BYTES bytes to host mem */
! 	    if (/*argp*/regs->regs_R[MD_REG_A2] != 0)
! 	      mem_bcopy(mem_fn, mem, Read, /*argp*/regs->regs_R[MD_REG_A2],
! 			buf, NUM_IOCTL_BYTES);
  
  	    /* perform the ioctl() call */
! 	    /*result*/regs->regs_R[MD_REG_V0] =
! 	      ioctl(/*fd*/regs->regs_R[MD_REG_A0], local_req, buf);
  
  	    /* if arg ptr exists, copy NUM_IOCTL_BYTES bytes from host mem */
! 	    if (/*argp*/regs->regs_R[MD_REG_A2] != 0)
! 	      mem_bcopy(mem_fn, mem, Write, regs->regs_R[MD_REG_A2],
  			buf, NUM_IOCTL_BYTES);
  
  	    /* check for an error condition */
! 	    if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
  	      regs->regs_R[7] = 0;
  	    else
  	      {	
  		/* got an error, return details */
! 		regs->regs_R[MD_REG_V0] = errno;
  		regs->regs_R[7] = 1;
  	      }
  	  }
        }
        break;
- #endif
  
!     case OSF_SYS_fstat:
        {
! 	struct osf_statbuf osf_sbuf;
  #ifdef _MSC_VER
!         struct _stat sbuf;
  #else /* !_MSC_VER */
  	struct stat sbuf;
  #endif /* _MSC_VER */
  
  	/* fstat() the file */
! 	/*result*/regs->regs_R[MD_REG_V0] =
! 	  fstat(/*fd*/regs->regs_R[MD_REG_A0], &sbuf);
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
  
  	/* translate the stat structure to host format */
! 	osf_sbuf.osf_st_dev = MD_SWAPW(sbuf.st_dev);
! 	osf_sbuf.osf_st_ino = MD_SWAPW(sbuf.st_ino);
! 	osf_sbuf.osf_st_mode = MD_SWAPW(sbuf.st_mode);
! 	osf_sbuf.osf_st_nlink = MD_SWAPH(sbuf.st_nlink);
! 	osf_sbuf.osf_st_uid = MD_SWAPW(sbuf.st_uid);
! 	osf_sbuf.osf_st_gid = MD_SWAPW(sbuf.st_gid);
! 	osf_sbuf.osf_st_rdev = MD_SWAPW(sbuf.st_rdev);
! 	osf_sbuf.osf_st_size = MD_SWAPQ(sbuf.st_size);
! 	osf_sbuf.osf_st_atime = MD_SWAPW(sbuf.st_atime);
! 	osf_sbuf.osf_st_mtime = MD_SWAPW(sbuf.st_mtime);
! 	osf_sbuf.osf_st_ctime = MD_SWAPW(sbuf.st_ctime);
  #ifndef _MSC_VER
! 	osf_sbuf.osf_st_blksize = MD_SWAPW(sbuf.st_blksize);
! 	osf_sbuf.osf_st_blocks = MD_SWAPW(sbuf.st_blocks);
  #endif /* !_MSC_VER */
  
  	/* copy fstat() results to simulator memory */
! 	mem_bcopy(mem_fn, mem, Write, /*sbuf*/regs->regs_R[MD_REG_A1],
! 		  &osf_sbuf, sizeof(struct osf_statbuf));
        }
        break;
  
!     case OSF_SYS_getpagesize:
        /* get target pagesize */
!       regs->regs_R[MD_REG_V0] = /* was: getpagesize() */MD_PAGE_SIZE;
  
        /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
  	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
  	}
        break;
  
!     case OSF_SYS_setitimer:
        /* FIXME: the sigvec system call is ignored */
        warn("syscall: setitimer ignored");
-       regs->regs_R[MD_REG_A3] = 0;
-       break;
- 
-     case OSF_SYS_table:
-       {
- 	qword_t table_id, table_index, buf_addr, num_elem, size_elem;
- 	struct osf_tbl_sysinfo sysinfo;
- 	
- 	table_id = regs->regs_R[MD_REG_A1];
- 	table_index = regs->regs_R[MD_REG_A2];
- 	buf_addr = regs->regs_R[MD_REG_A3];
- 	num_elem = regs->regs_R[MD_REG_A4];
- 	size_elem = regs->regs_R[MD_REG_A5];
- 	
- 	switch(table_id)
- 	{
- 	case OSF_TBL_SYSINFO:
- 	  if (table_index != 0)
- 	    {
- 	      panic("table: table id TBL_SYSINFO requires 0 index, got %08d",
- 		    table_index );
- 	    }
- 	  else if (num_elem != 1)
- 	    {
- 	      panic("table: table id TBL_SYSINFO requires 1 elts, got %08d",
- 		    num_elem );
- 	    }
- 	  else
- 	    {
- 	      struct rusage rusage_info;
- 	      
- 	      /* use getrusage() to determine user & system time */
- 	      if (getrusage(RUSAGE_SELF, &rusage_info) < 0)
- 		{
- 		  /* abort the system call */
- 		  regs->regs_R[MD_REG_A3] = -1;
- 		  /* not kosher to pass off errno of getrusage() as errno
- 		     of table(), but what the heck... */
- 		  regs->regs_R[MD_REG_V0] = errno;
- 		  break;
- 		}
- 	      
- 	      /* use sysconf() to determine clock tick frequency */
- 	      sysinfo.si_hz = sysconf(_SC_CLK_TCK);
- 
- 	      /* convert user and system time into clock ticks */
- 	      sysinfo.si_user = rusage_info.ru_utime.tv_sec * sysinfo.si_hz + 
- 		(rusage_info.ru_utime.tv_usec * sysinfo.si_hz) / 1000000UL;
- 	      sysinfo.si_sys = rusage_info.ru_stime.tv_sec * sysinfo.si_hz + 
- 		(rusage_info.ru_stime.tv_usec * sysinfo.si_hz) / 1000000UL;
- 
- 	      /* following can't be determined in a portable manner and
- 		 are ignored */
- 	      sysinfo.si_nice = 0;
- 	      sysinfo.si_idle = 0;
- 	      sysinfo.si_phz = 0;
- 	      sysinfo.si_boottime = 0;
- 	      sysinfo.wait = 0;
- 
- 	      /* copy structure into simulator memory */
- 	      mem_bcopy(mem_fn, mem, Write, buf_addr,
- 			&sysinfo, sizeof(struct osf_tbl_sysinfo));
- 
- 	      /* return success */
- 	      regs->regs_R[MD_REG_A3] = 0;
- 	    }
- 	  break;
- 
- 	default:
- 	  warn("table: unsupported table id %d requested, ignored", table_id);
- 	  regs->regs_R[MD_REG_A3] = 0;
- 	}
-       }
        break;
  
!     case OSF_SYS_getdtablesize:
! #if defined(_AIX) || defined(__alpha)
        /* get descriptor table size */
!       regs->regs_R[MD_REG_V0] = getdtablesize();
  
        /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
  	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
  	}
! #elif defined(ultrix)
!       {
! 	/* no comparable system call found, try some reasonable defaults */
! 	warn("syscall: called getdtablesize\n");
! 	regs->regs_R[MD_REG_V0] = 16;
! 	regs->regs_R[MD_REG_A3] = 0;
!       }
! #elif defined(MIN_SYSCALL_MODE)
        {
  	/* no comparable system call found, try some reasonable defaults */
! 	warn("syscall: called getdtablesize\n");
! 	regs->regs_R[MD_REG_V0] = 16;
! 	regs->regs_R[MD_REG_A3] = 0;
        }
  #else
        {
  	struct rlimit rl;
  
  	/* get descriptor table size in rlimit structure */
! 	if (getrlimit(RLIMIT_NOFILE, &rl) != (qword_t)-1)
  	  {
! 	    regs->regs_R[MD_REG_V0] = rl.rlim_cur;
! 	    regs->regs_R[MD_REG_A3] = 0;
  	  }
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
        }
  #endif
        break;
  
!     case OSF_SYS_dup2:
        /* dup2() the file descriptor */
!       regs->regs_R[MD_REG_V0] =
! 	dup2(/*fd1*/regs->regs_R[MD_REG_A0], /*fd2*/regs->regs_R[MD_REG_A1]);
  
        /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
  	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
  	}
        break;
  
!     case OSF_SYS_fcntl:
  #ifdef _MSC_VER
        warn("syscall fcntl() not yet implemented for MSC...");
!       regs->regs_R[MD_REG_A3] = 0;
  #else /* !_MSC_VER */
        /* get fcntl() information on the file */
!       regs->regs_R[MD_REG_V0] =
! 	fcntl(/*fd*/regs->regs_R[MD_REG_A0],
! 	      /*cmd*/regs->regs_R[MD_REG_A1], /*arg*/regs->regs_R[MD_REG_A2]);
  
        /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
! 	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
  	}
  #endif /* _MSC_VER */
        break;
  
! #if 0
!     case OSF_SYS_sigvec:
        /* FIXME: the sigvec system call is ignored */
        warn("syscall: sigvec ignored");
-       regs->regs_R[MD_REG_A3] = 0;
        break;
- #endif
  
! #if 0
!     case OSF_SYS_sigblock:
        /* FIXME: the sigblock system call is ignored */
        warn("syscall: sigblock ignored");
-       regs->regs_R[MD_REG_A3] = 0;
        break;
- #endif
  
! #if 0
!     case OSF_SYS_sigsetmask:
        /* FIXME: the sigsetmask system call is ignored */
        warn("syscall: sigsetmask ignored");
!       regs->regs_R[MD_REG_A3] = 0;
        break;
  #endif
  
!     case OSF_SYS_gettimeofday:
  #ifdef _MSC_VER
        warn("syscall gettimeofday() not yet implemented for MSC...");
!       regs->regs_R[MD_REG_A3] = 0;
  #else /* _MSC_VER */
        {
! 	struct osf_timeval osf_tv;
  	struct timeval tv, *tvp;
! 	struct osf_timezone osf_tz;
  	struct timezone tz, *tzp;
  
! 	if (/*timeval*/regs->regs_R[MD_REG_A0] != 0)
  	  {
  	    /* copy timeval into host memory */
! 	    mem_bcopy(mem_fn, mem, Read, /*timeval*/regs->regs_R[MD_REG_A0],
! 		      &osf_tv, sizeof(struct osf_timeval));
  
  	    /* convert target timeval structure to host format */
! 	    tv.tv_sec = MD_SWAPW(osf_tv.osf_tv_sec);
! 	    tv.tv_usec = MD_SWAPW(osf_tv.osf_tv_usec);
  	    tvp = &tv;
  	  }
  	else
  	  tvp = NULL;
  
! 	if (/*timezone*/regs->regs_R[MD_REG_A1] != 0)
  	  {
  	    /* copy timezone into host memory */
! 	    mem_bcopy(mem_fn, mem, Read, /*timezone*/regs->regs_R[MD_REG_A1],
! 		      &osf_tz, sizeof(struct osf_timezone));
  
  	    /* convert target timezone structure to host format */
! 	    tz.tz_minuteswest = MD_SWAPW(osf_tz.osf_tz_minuteswest);
! 	    tz.tz_dsttime = MD_SWAPW(osf_tz.osf_tz_dsttime);
  	    tzp = &tz;
  	  }
  	else
  	  tzp = NULL;
  
  	/* get time of day */
! 	/*result*/regs->regs_R[MD_REG_V0] = gettimeofday(tvp, tzp);
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
  
! 	if (/*timeval*/regs->regs_R[MD_REG_A0] != 0)
  	  {
  	    /* convert host timeval structure to target format */
! 	    osf_tv.osf_tv_sec = MD_SWAPW(tv.tv_sec);
! 	    osf_tv.osf_tv_usec = MD_SWAPW(tv.tv_usec);
  
  	    /* copy timeval to target memory */
! 	    mem_bcopy(mem_fn, mem, Write, /*timeval*/regs->regs_R[MD_REG_A0],
! 		      &osf_tv, sizeof(struct osf_timeval));
  	  }
  
! 	if (/*timezone*/regs->regs_R[MD_REG_A1] != 0)
  	  {
  	    /* convert host timezone structure to target format */
! 	    osf_tz.osf_tz_minuteswest = MD_SWAPW(tz.tz_minuteswest);
! 	    osf_tz.osf_tz_dsttime = MD_SWAPW(tz.tz_dsttime);
  
  	    /* copy timezone to target memory */
! 	    mem_bcopy(mem_fn, mem, Write, /*timezone*/regs->regs_R[MD_REG_A1],
! 		      &osf_tz, sizeof(struct osf_timezone));
  	  }
        }
  #endif /* !_MSC_VER */
        break;
  
!     case OSF_SYS_getrusage:
  #if defined(__svr4__) || defined(__USLC__) || defined(hpux) || defined(__hpux) || defined(_AIX)
        {
  	struct tms tms_buf;
! 	struct osf_rusage rusage;
  
  	/* get user and system times */
! 	if (times(&tms_buf) != (qword_t)-1)
  	  {
  	    /* no error */
! 	    regs->regs_R[MD_REG_V0] = 0;
! 	    regs->regs_R[MD_REG_A3] = 0;
  	  }
! 	else /* got an error, indicate result */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
  
  	/* initialize target rusage result structure */
  #if defined(__svr4__)
! 	memset(&rusage, '\0', sizeof(struct osf_rusage));
  #else /* !defined(__svr4__) */
! 	bzero(&rusage, sizeof(struct osf_rusage));
  #endif
  
  	/* convert from host rusage structure to target format */
! 	rusage.osf_ru_utime.osf_tv_sec = MD_SWAPW(tms_buf.tms_utime/CLK_TCK);
! 	rusage.osf_ru_utime.osf_tv_sec =
! 	  MD_SWAPW(rusage.osf_ru_utime.osf_tv_sec);
! 	rusage.osf_ru_utime.osf_tv_usec = 0;
! 	rusage.osf_ru_stime.osf_tv_sec = MD_SWAPW(tms_buf.tms_stime/CLK_TCK);
! 	rusage.osf_ru_stime.osf_tv_sec =
! 	  MD_SWAPW(rusage.osf_ru_stime.osf_tv_sec);
! 	rusage.osf_ru_stime.osf_tv_usec = 0;
  
  	/* copy rusage results into target memory */
! 	mem_bcopy(mem_fn, mem, Write, /*rusage*/regs->regs_R[MD_REG_A1],
! 		  &rusage, sizeof(struct osf_rusage));
        }
! #elif defined(__unix__)
        {
  	struct rusage local_rusage;
! 	struct osf_rusage rusage;
  
  	/* get rusage information */
! 	/*result*/regs->regs_R[MD_REG_V0] =
! 	  getrusage(/*who*/regs->regs_R[MD_REG_A0], &local_rusage);
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
  
  	/* convert from host rusage structure to target format */
! 	rusage.osf_ru_utime.osf_tv_sec =
! 	  MD_SWAPW(local_rusage.ru_utime.tv_sec);
! 	rusage.osf_ru_utime.osf_tv_usec =
  	  MD_SWAPW(local_rusage.ru_utime.tv_usec);
! 	rusage.osf_ru_utime.osf_tv_sec =
! 	  MD_SWAPW(local_rusage.ru_utime.tv_sec);
! 	rusage.osf_ru_utime.osf_tv_usec =
! 	  MD_SWAPW(local_rusage.ru_utime.tv_usec);
! 	rusage.osf_ru_stime.osf_tv_sec =
! 	  MD_SWAPW(local_rusage.ru_stime.tv_sec);
! 	rusage.osf_ru_stime.osf_tv_usec =
! 	  MD_SWAPW(local_rusage.ru_stime.tv_usec);
! 	rusage.osf_ru_stime.osf_tv_sec =
  	  MD_SWAPW(local_rusage.ru_stime.tv_sec);
! 	rusage.osf_ru_stime.osf_tv_usec =
  	  MD_SWAPW(local_rusage.ru_stime.tv_usec);
! 	rusage.osf_ru_maxrss = MD_SWAPW(local_rusage.ru_maxrss);
! 	rusage.osf_ru_ixrss = MD_SWAPW(local_rusage.ru_ixrss);
! 	rusage.osf_ru_idrss = MD_SWAPW(local_rusage.ru_idrss);
! 	rusage.osf_ru_isrss = MD_SWAPW(local_rusage.ru_isrss);
! 	rusage.osf_ru_minflt = MD_SWAPW(local_rusage.ru_minflt);
! 	rusage.osf_ru_majflt = MD_SWAPW(local_rusage.ru_majflt);
! 	rusage.osf_ru_nswap = MD_SWAPW(local_rusage.ru_nswap);
! 	rusage.osf_ru_inblock = MD_SWAPW(local_rusage.ru_inblock);
! 	rusage.osf_ru_oublock = MD_SWAPW(local_rusage.ru_oublock);
! 	rusage.osf_ru_msgsnd = MD_SWAPW(local_rusage.ru_msgsnd);
! 	rusage.osf_ru_msgrcv = MD_SWAPW(local_rusage.ru_msgrcv);
! 	rusage.osf_ru_nsignals = MD_SWAPW(local_rusage.ru_nsignals);
! 	rusage.osf_ru_nvcsw = MD_SWAPW(local_rusage.ru_nvcsw);
! 	rusage.osf_ru_nivcsw = MD_SWAPW(local_rusage.ru_nivcsw);
  
  	/* copy rusage results into target memory */
! 	mem_bcopy(mem_fn, mem, Write, /*rusage*/regs->regs_R[MD_REG_A1],
! 		  &rusage, sizeof(struct osf_rusage));
        }
! #elif /* defined(__CYGWIN32__) || */ defined(_MSC_VER)
! 	    warn("syscall: called getrusage\n");
              regs->regs_R[7] = 0;
  #else
  #error No getrusage() implementation!
  #endif
        break;
  
!     case OSF_SYS_utimes:
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[MD_REG_A0], buf);
  
! 	if (/*timeval*/regs->regs_R[MD_REG_A1] == 0)
  	  {
  #if defined(hpux) || defined(__hpux) || defined(linux)
  	    /* no utimes() in hpux, use utime() instead */
! 	    /*result*/regs->regs_R[MD_REG_V0] = utime(buf, NULL);
  #elif defined(_MSC_VER)
!             /* no utimes() in MSC, use utime() instead */
! 	    /*result*/regs->regs_R[MD_REG_V0] = utime(buf, NULL);
! #elif defined(__svr4__) || defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha)
! 	    /*result*/regs->regs_R[MD_REG_V0] = utimes(buf, NULL);
  #elif defined(__CYGWIN32__)
! 	    warn("syscall: called utimes\n");
  #else
  #error No utimes() implementation!
  #endif
  	  }
  	else
  	  {
! 	    struct osf_timeval osf_tval[2];
  #ifndef _MSC_VER
  	    struct timeval tval[2];
  #endif /* !_MSC_VER */
  
  	    /* copy timeval structure to host memory */
! 	    mem_bcopy(mem_fn, mem, Read, /*timeout*/regs->regs_R[MD_REG_A1],
! 		      osf_tval, 2*sizeof(struct osf_timeval));
  
  #ifndef _MSC_VER
  	    /* convert timeval structure to host format */
! 	    tval[0].tv_sec = MD_SWAPW(osf_tval[0].osf_tv_sec);
! 	    tval[0].tv_usec = MD_SWAPW(osf_tval[0].osf_tv_usec);
! 	    tval[1].tv_sec = MD_SWAPW(osf_tval[1].osf_tv_sec);
! 	    tval[1].tv_usec = MD_SWAPW(osf_tval[1].osf_tv_usec);
  #endif /* !_MSC_VER */
  
  #if defined(hpux) || defined(__hpux) || defined(__svr4__)
--- 1234,1897 ----
  #endif
  	}
  
+ #if !defined(TIOCGETP) && (defined(linux) || defined(__CYGWIN32__))
+         if (!local_req && /*req*/regs->regs_R[5] == SS_IOCTL_TIOCGETP)
+           {
+             struct termios lbuf;
+             struct ss_sgttyb buf;
+ 
+             /* result */regs->regs_R[2] =
+                           tcgetattr(/* fd */(int)regs->regs_R[4], &lbuf);
+ 
+             /* translate results */
+             buf.sg_ispeed = lbuf.c_ispeed;
+             buf.sg_ospeed = lbuf.c_ospeed;
+             buf.sg_erase = lbuf.c_cc[VERASE];
+             buf.sg_kill = lbuf.c_cc[VKILL];
+             buf.sg_flags = 0;   /* FIXME: this is wrong... */
+ 
+             mem_bcopy(mem_fn, mem, Write,
+                       /* buf */regs->regs_R[6], &buf,
+                       sizeof(struct ss_sgttyb));
+ 
+             if (regs->regs_R[2] != -1)
+               regs->regs_R[7] = 0;
+             else /* probably not a typewriter, return details */
+               {
+                 regs->regs_R[2] = errno;
+                 regs->regs_R[7] = 1;
+               }
+           }
+         else
+ #endif
+ 
  	if (!local_req)
  	  {
  	    /* FIXME: could not translate the ioctl() request, just warn user
  	       and ignore the request */
  	    warn("syscall: ioctl: ioctl code not supported d=%d, req=%d",
! 		 regs->regs_R[4], regs->regs_R[5]);
! 	    regs->regs_R[2] = 0;
  	    regs->regs_R[7] = 0;
  	  }
  	else
  	  {
+ #ifdef _MSC_VER
+ 	    warn("syscall getgid() not yet implemented for MSC...");
+ 	    regs->regs_R[7] = 0;
+ 	    break;
+ #else /* !_MSC_VER */
+ 
+ #if 0 /* FIXME: needed? */
+ #ifdef TIOCGETP
+ 	    if (local_req == TIOCGETP && sim_progfd)
+ 	      {
+ 		/* program I/O has been redirected to file, make
+ 		   termios() calls fail... */
+ 
+ 		/* got an error, return details */
+ 		regs->regs_R[2] = ENOTTY;
+ 		regs->regs_R[7] = 1;
+ 		break;
+ 	      }
+ #endif
+ #endif
  	    /* ioctl() code was successfully translated to a host code */
  
  	    /* if arg ptr exists, copy NUM_IOCTL_BYTES bytes to host mem */
! 	    if (/*argp*/regs->regs_R[6] != 0)
! 	      mem_bcopy(mem_fn, mem,
! 			Read, /*argp*/regs->regs_R[6], buf, NUM_IOCTL_BYTES);
  
  	    /* perform the ioctl() call */
! 	    /*result*/regs->regs_R[2] =
! 	      ioctl(/*fd*/regs->regs_R[4], local_req, buf);
  
  	    /* if arg ptr exists, copy NUM_IOCTL_BYTES bytes from host mem */
! 	    if (/*argp*/regs->regs_R[6] != 0)
! 	      mem_bcopy(mem_fn, mem, Write, regs->regs_R[6],
  			buf, NUM_IOCTL_BYTES);
  
  	    /* check for an error condition */
! 	    if (regs->regs_R[2] != -1)
  	      regs->regs_R[7] = 0;
  	    else
  	      {	
  		/* got an error, return details */
! 		regs->regs_R[2] = errno;
  		regs->regs_R[7] = 1;
  	      }
+ #endif /* _MSC_VER */
  	  }
        }
        break;
  
!     case SS_SYS_fstat:
        {
! 	struct ss_statbuf ss_sbuf;
  #ifdef _MSC_VER
! 	struct _stat sbuf;
  #else /* !_MSC_VER */
  	struct stat sbuf;
  #endif /* _MSC_VER */
  
  	/* fstat() the file */
! 	/*result*/regs->regs_R[2] = fstat(/*fd*/regs->regs_R[4], &sbuf);
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
  
  	/* translate the stat structure to host format */
! 	ss_sbuf.ss_st_dev = MD_SWAPH(sbuf.st_dev);
! 	ss_sbuf.ss_pad = 0;
! 	ss_sbuf.ss_st_ino = MD_SWAPW(sbuf.st_ino);
! 	ss_sbuf.ss_st_mode = MD_SWAPH(sbuf.st_mode);
! 	ss_sbuf.ss_st_nlink = MD_SWAPH(sbuf.st_nlink);
! 	ss_sbuf.ss_st_uid = MD_SWAPH(sbuf.st_uid);
! 	ss_sbuf.ss_st_gid = MD_SWAPH(sbuf.st_gid);
! 	ss_sbuf.ss_st_rdev = MD_SWAPH(sbuf.st_rdev);
! 	ss_sbuf.ss_pad1 = 0;
! 	ss_sbuf.ss_st_size = MD_SWAPW(sbuf.st_size);
! 	ss_sbuf.ss_st_atime = MD_SWAPW(sbuf.st_atime);
!         ss_sbuf.ss_st_spare1 = 0;
! 	ss_sbuf.ss_st_mtime = MD_SWAPW(sbuf.st_mtime);
!         ss_sbuf.ss_st_spare2 = 0;
! 	ss_sbuf.ss_st_ctime = MD_SWAPW(sbuf.st_ctime);
!         ss_sbuf.ss_st_spare3 = 0;
  #ifndef _MSC_VER
! 	ss_sbuf.ss_st_blksize = MD_SWAPW(sbuf.st_blksize);
! 	ss_sbuf.ss_st_blocks = MD_SWAPW(sbuf.st_blocks);
  #endif /* !_MSC_VER */
+         ss_sbuf.ss_st_gennum = 0;
+         ss_sbuf.ss_st_spare4 = 0;
  
  	/* copy fstat() results to simulator memory */
! 	mem_bcopy(mem_fn, mem, Write, /*sbuf*/regs->regs_R[5],
! 		  &ss_sbuf, sizeof(struct ss_statbuf));
        }
        break;
  
!     case SS_SYS_getpagesize:
        /* get target pagesize */
!       regs->regs_R[2] = /* was: getpagesize() */MD_PAGE_SIZE;
  
        /* check for an error condition */
!       if (regs->regs_R[2] != -1)
! 	regs->regs_R[7] = 0;
!       else
  	{
! 	  /* got an error, return details */
! 	  regs->regs_R[2] = errno;
! 	  regs->regs_R[7] = 1;
  	}
        break;
  
!     case SS_SYS_setitimer:
        /* FIXME: the sigvec system call is ignored */
+       regs->regs_R[2] = regs->regs_R[7] = 0;
        warn("syscall: setitimer ignored");
        break;
  
!     case SS_SYS_getdtablesize:
! #if defined(_AIX)
        /* get descriptor table size */
!       regs->regs_R[2] = getdtablesize();
  
        /* check for an error condition */
!       if (regs->regs_R[2] != -1)
! 	regs->regs_R[7] = 0;
!       else
  	{
! 	  /* got an error, return details */
! 	  regs->regs_R[2] = errno;
! 	  regs->regs_R[7] = 1;
  	}
! #elif defined(__CYGWIN32__) || defined(ultrix) || defined(_MSC_VER)
        {
  	/* no comparable system call found, try some reasonable defaults */
! 	warn("syscall: called getdtablesize()\n");
! 	regs->regs_R[2] = 16;
! 	regs->regs_R[7] = 0;
        }
  #else
        {
  	struct rlimit rl;
  
  	/* get descriptor table size in rlimit structure */
! 	if (getrlimit(RLIMIT_NOFILE, &rl) != -1)
  	  {
! 	    regs->regs_R[2] = rl.rlim_cur;
! 	    regs->regs_R[7] = 0;
  	  }
! 	else
  	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
        }
  #endif
        break;
  
!     case SS_SYS_dup2:
        /* dup2() the file descriptor */
!       regs->regs_R[2] =
! 	dup2(/* fd1 */regs->regs_R[4], /* fd2 */regs->regs_R[5]);
  
        /* check for an error condition */
!       if (regs->regs_R[2] != -1)
! 	regs->regs_R[7] = 0;
!       else
  	{
! 	  /* got an error, return details */
! 	  regs->regs_R[2] = errno;
! 	  regs->regs_R[7] = 1;
  	}
        break;
  
!     case SS_SYS_fcntl:
  #ifdef _MSC_VER
        warn("syscall fcntl() not yet implemented for MSC...");
!       regs->regs_R[7] = 0;
  #else /* !_MSC_VER */
        /* get fcntl() information on the file */
!       regs->regs_R[2] =
! 	fcntl(/*fd*/regs->regs_R[4], /*cmd*/regs->regs_R[5],
! 	      /*arg*/regs->regs_R[6]);
  
        /* check for an error condition */
!       if (regs->regs_R[2] != -1)
! 	regs->regs_R[7] = 0;
!       else
! 	{
! 	  /* got an error, return details */
! 	  regs->regs_R[2] = errno;
! 	  regs->regs_R[7] = 1;
  	}
  #endif /* _MSC_VER */
        break;
  
!     case SS_SYS_select:
! #ifdef _MSC_VER
!       warn("syscall select() not yet implemented for MSC...");
!       regs->regs_R[7] = 0;
! #else /* !_MSC_VER */
!       {
! 	fd_set readfd, writefd, exceptfd;
! 	fd_set *readfdp, *writefdp, *exceptfdp;
! 	struct timeval timeout, *timeoutp;
! 	word_t param5;
! 
! 	/* FIXME: swap words? */
! 
! 	/* read the 5th parameter (timeout) from the stack */
! 	mem_bcopy(mem_fn, mem,
! 		  Read, regs->regs_R[29]+16, &param5, sizeof(word_t));
! 
! 	/* copy read file descriptor set into host memory */
! 	if (/*readfd*/regs->regs_R[5] != 0)
! 	  {
! 	    mem_bcopy(mem_fn, mem, Read, /*readfd*/regs->regs_R[5],
! 		      &readfd, sizeof(fd_set));
! 	    readfdp = &readfd;
! 	  }
! 	else
! 	  readfdp = NULL;
! 
! 	/* copy write file descriptor set into host memory */
! 	if (/*writefd*/regs->regs_R[6] != 0)
! 	  {
! 	    mem_bcopy(mem_fn, mem, Read, /*writefd*/regs->regs_R[6],
! 		      &writefd, sizeof(fd_set));
! 	    writefdp = &writefd;
! 	  }
! 	else
! 	  writefdp = NULL;
! 
! 	/* copy exception file descriptor set into host memory */
! 	if (/*exceptfd*/regs->regs_R[7] != 0)
! 	  {
! 	    mem_bcopy(mem_fn, mem, Read, /*exceptfd*/regs->regs_R[7],
! 		      &exceptfd, sizeof(fd_set));
! 	    exceptfdp = &exceptfd;
! 	  }
! 	else
! 	  exceptfdp = NULL;
! 
! 	/* copy timeout value into host memory */
! 	if (/*timeout*/param5 != 0)
! 	  {
! 	    mem_bcopy(mem_fn, mem, Read, /*timeout*/param5,
! 		      &timeout, sizeof(struct timeval));
! 	    timeoutp = &timeout;
! 	  }
! 	else
! 	  timeoutp = NULL;
! 
! #if defined(hpux) || defined(__hpux)
! 	/* select() on the specified file descriptors */
! 	/*result*/regs->regs_R[2] =
! 	  select(/*nfd*/regs->regs_R[4],
! 		 (int *)readfdp, (int *)writefdp, (int *)exceptfdp, timeoutp);
! #else
! 	/* select() on the specified file descriptors */
! 	/*result*/regs->regs_R[2] =
! 	  select(/*nfd*/regs->regs_R[4],
! 		 readfdp, writefdp, exceptfdp, timeoutp);
! #endif
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
! 	  {
! 	    /* got an error, return details */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
! 	  }
! 
! 	/* copy read file descriptor set to target memory */
! 	if (/*readfd*/regs->regs_R[5] != 0)
! 	  mem_bcopy(mem_fn, mem, Write, /*readfd*/regs->regs_R[5],
! 		    &readfd, sizeof(fd_set));
! 
! 	/* copy write file descriptor set to target memory */
! 	if (/*writefd*/regs->regs_R[6] != 0)
! 	  mem_bcopy(mem_fn, mem, Write, /*writefd*/regs->regs_R[6],
! 		    &writefd, sizeof(fd_set));
! 
! 	/* copy exception file descriptor set to target memory */
! 	if (/*exceptfd*/regs->regs_R[7] != 0)
! 	  mem_bcopy(mem_fn, mem, Write, /*exceptfd*/regs->regs_R[7],
! 		    &exceptfd, sizeof(fd_set));
! 
! 	/* copy timeout value result to target memory */
! 	if (/* timeout */param5 != 0)
! 	  mem_bcopy(mem_fn, mem, Write, /*timeout*/param5,
! 		    &timeout, sizeof(struct timeval));
!       }
! #endif
!       break;
! 
!     case SS_SYS_sigvec:
        /* FIXME: the sigvec system call is ignored */
+       regs->regs_R[2] = regs->regs_R[7] = 0;
        warn("syscall: sigvec ignored");
        break;
  
!     case SS_SYS_sigblock:
        /* FIXME: the sigblock system call is ignored */
+       regs->regs_R[2] = regs->regs_R[7] = 0;
        warn("syscall: sigblock ignored");
        break;
  
!     case SS_SYS_sigsetmask:
        /* FIXME: the sigsetmask system call is ignored */
+       regs->regs_R[2] = regs->regs_R[7] = 0;
        warn("syscall: sigsetmask ignored");
!       break;
! 
! #if 0
!     case SS_SYS_sigstack:
!       /* FIXME: this is broken... */
!       /* do not make the system call; instead, modify (the stack
! 	 portion of) the simulator's main memory, ignore the 1st
! 	 argument (regs->regs_R[4]), as it relates to signal handling */
!       if (regs->regs_R[5] != 0)
! 	{
! 	  (*maf)(Read, regs->regs_R[29]+28, (unsigned char *)&temp, 4);
! 	  (*maf)(Write, regs->regs_R[5], (unsigned char *)&temp, 4);
! 	}
!       regs->regs_R[2] = regs->regs_R[7] = 0;
        break;
  #endif
  
!     case SS_SYS_gettimeofday:
  #ifdef _MSC_VER
        warn("syscall gettimeofday() not yet implemented for MSC...");
!       regs->regs_R[7] = 0;
  #else /* _MSC_VER */
        {
! 	struct ss_timeval ss_tv;
  	struct timeval tv, *tvp;
! 	struct ss_timezone ss_tz;
  	struct timezone tz, *tzp;
  
! 	if (/*timeval*/regs->regs_R[4] != 0)
  	  {
  	    /* copy timeval into host memory */
! 	    mem_bcopy(mem_fn, mem, Read, /*timeval*/regs->regs_R[4],
! 		      &ss_tv, sizeof(struct ss_timeval));
  
  	    /* convert target timeval structure to host format */
! 	    tv.tv_sec = MD_SWAPW(ss_tv.ss_tv_sec);
! 	    tv.tv_usec = MD_SWAPW(ss_tv.ss_tv_usec);
  	    tvp = &tv;
  	  }
  	else
  	  tvp = NULL;
  
! 	if (/*timezone*/regs->regs_R[5] != 0)
  	  {
  	    /* copy timezone into host memory */
! 	    mem_bcopy(mem_fn, mem, Read, /*timezone*/regs->regs_R[5],
! 		      &ss_tz, sizeof(struct ss_timezone));
  
  	    /* convert target timezone structure to host format */
! 	    tz.tz_minuteswest = MD_SWAPW(ss_tz.ss_tz_minuteswest);
! 	    tz.tz_dsttime = MD_SWAPW(ss_tz.ss_tz_dsttime);
  	    tzp = &tz;
  	  }
  	else
  	  tzp = NULL;
  
  	/* get time of day */
! 	/*result*/regs->regs_R[2] = gettimeofday(tvp, tzp);
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, indicate result */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
  
! 	if (/*timeval*/regs->regs_R[4] != 0)
  	  {
  	    /* convert host timeval structure to target format */
! 	    ss_tv.ss_tv_sec = MD_SWAPW(tv.tv_sec);
! 	    ss_tv.ss_tv_usec = MD_SWAPW(tv.tv_usec);
  
  	    /* copy timeval to target memory */
! 	    mem_bcopy(mem_fn, mem, Write, /*timeval*/regs->regs_R[4],
! 		      &ss_tv, sizeof(struct ss_timeval));
  	  }
  
! 	if (/*timezone*/regs->regs_R[5] != 0)
  	  {
  	    /* convert host timezone structure to target format */
! 	    ss_tz.ss_tz_minuteswest = MD_SWAPW(tz.tz_minuteswest);
! 	    ss_tz.ss_tz_dsttime = MD_SWAPW(tz.tz_dsttime);
  
  	    /* copy timezone to target memory */
! 	    mem_bcopy(mem_fn, mem, Write, /*timezone*/regs->regs_R[5],
! 		      &ss_tz, sizeof(struct ss_timezone));
  	  }
        }
  #endif /* !_MSC_VER */
        break;
  
!     case SS_SYS_getrusage:
  #if defined(__svr4__) || defined(__USLC__) || defined(hpux) || defined(__hpux) || defined(_AIX)
        {
  	struct tms tms_buf;
! 	struct ss_rusage rusage;
  
  	/* get user and system times */
! 	if (times(&tms_buf) != -1)
  	  {
  	    /* no error */
! 	    regs->regs_R[2] = 0;
! 	    regs->regs_R[7] = 0;
  	  }
! 	else
  	  {
! 	    /* got an error, indicate result */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
  
  	/* initialize target rusage result structure */
  #if defined(__svr4__)
! 	memset(&rusage, '\0', sizeof(struct ss_rusage));
  #else /* !defined(__svr4__) */
! 	bzero(&rusage, sizeof(struct ss_rusage));
  #endif
  
  	/* convert from host rusage structure to target format */
! 	rusage.ss_ru_utime.ss_tv_sec = tms_buf.tms_utime/CLK_TCK;
! 	rusage.ss_ru_utime.ss_tv_sec = MD_SWAPW(rusage.ss_ru_utime.ss_tv_sec);
! 	rusage.ss_ru_utime.ss_tv_usec = 0;
! 	rusage.ss_ru_stime.ss_tv_sec = tms_buf.tms_stime/CLK_TCK;
! 	rusage.ss_ru_stime.ss_tv_sec = MD_SWAPW(rusage.ss_ru_stime.ss_tv_sec);
! 	rusage.ss_ru_stime.ss_tv_usec = 0;
  
  	/* copy rusage results into target memory */
! 	mem_bcopy(mem_fn, mem, Write, /*rusage*/regs->regs_R[5],
! 		  &rusage, sizeof(struct ss_rusage));
        }
! #elif defined(__unix__) || defined(unix) || defined(__APPLE__)
        {
  	struct rusage local_rusage;
! 	struct ss_rusage rusage;
  
  	/* get rusage information */
! 	/*result*/regs->regs_R[2] =
! 	  getrusage(/*who*/regs->regs_R[4], &local_rusage);
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, indicate result */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
  
  	/* convert from host rusage structure to target format */
! 	rusage.ss_ru_utime.ss_tv_sec = local_rusage.ru_utime.tv_sec;
! 	rusage.ss_ru_utime.ss_tv_usec = local_rusage.ru_utime.tv_usec;
! 	rusage.ss_ru_utime.ss_tv_sec = MD_SWAPW(local_rusage.ru_utime.tv_sec);
! 	rusage.ss_ru_utime.ss_tv_usec =
  	  MD_SWAPW(local_rusage.ru_utime.tv_usec);
! 	rusage.ss_ru_stime.ss_tv_sec = local_rusage.ru_stime.tv_sec;
! 	rusage.ss_ru_stime.ss_tv_usec = local_rusage.ru_stime.tv_usec;
! 	rusage.ss_ru_stime.ss_tv_sec =
  	  MD_SWAPW(local_rusage.ru_stime.tv_sec);
! 	rusage.ss_ru_stime.ss_tv_usec =
  	  MD_SWAPW(local_rusage.ru_stime.tv_usec);
! 	rusage.ss_ru_maxrss = MD_SWAPW(local_rusage.ru_maxrss);
! 	rusage.ss_ru_ixrss = MD_SWAPW(local_rusage.ru_ixrss);
! 	rusage.ss_ru_idrss = MD_SWAPW(local_rusage.ru_idrss);
! 	rusage.ss_ru_isrss = MD_SWAPW(local_rusage.ru_isrss);
! 	rusage.ss_ru_minflt = MD_SWAPW(local_rusage.ru_minflt);
! 	rusage.ss_ru_majflt = MD_SWAPW(local_rusage.ru_majflt);
! 	rusage.ss_ru_nswap = MD_SWAPW(local_rusage.ru_nswap);
! 	rusage.ss_ru_inblock = MD_SWAPW(local_rusage.ru_inblock);
! 	rusage.ss_ru_oublock = MD_SWAPW(local_rusage.ru_oublock);
! 	rusage.ss_ru_msgsnd = MD_SWAPW(local_rusage.ru_msgsnd);
! 	rusage.ss_ru_msgrcv = MD_SWAPW(local_rusage.ru_msgrcv);
! 	rusage.ss_ru_nsignals = MD_SWAPW(local_rusage.ru_nsignals);
! 	rusage.ss_ru_nvcsw = MD_SWAPW(local_rusage.ru_nvcsw);
! 	rusage.ss_ru_nivcsw = MD_SWAPW(local_rusage.ru_nivcsw);
  
  	/* copy rusage results into target memory */
! 	mem_bcopy(mem_fn, mem, Write, /*rusage*/regs->regs_R[5],
! 		  &rusage, sizeof(struct ss_rusage));
        }
! #elif defined(__CYGWIN32__) || defined(_MSC_VER)
! 	    warn("syscall: called getrusage()\n");
              regs->regs_R[7] = 0;
  #else
  #error No getrusage() implementation!
  #endif
        break;
  
!     case SS_SYS_writev:
! #ifdef _MSC_VER
!       warn("syscall writev() not yet implemented for MSC...");
!       regs->regs_R[7] = 0;
! #else /* !_MSC_VER */
!       {
! 	int i;
! 	char *buf;
! 	struct iovec *iov;
! 
! 	/* allocate host side I/O vectors */
! 	iov =
! 	  (struct iovec *)malloc(/*iovcnt*/regs->regs_R[6]
! 				 * sizeof(struct iovec));
! 	if (!iov)
! 	  fatal("out of virtual memory in SYS_writev");
! 
! 	/* copy target side pointer data into host side vector */
! 	mem_bcopy(mem_fn, mem, Read, /*iov*/regs->regs_R[5],
! 		  iov, /*iovcnt*/regs->regs_R[6] * sizeof(struct iovec));
! 
! 	/* copy target side I/O vector buffers to host memory */
! 	for (i=0; i < /*iovcnt*/regs->regs_R[6]; i++)
! 	  {
! 	    iov[i].iov_base = (char *)MD_SWAPW((unsigned)iov[i].iov_base);
! 	    iov[i].iov_len = MD_SWAPW(iov[i].iov_len);
! 	    if (iov[i].iov_base != NULL)
! 	      {
! 		buf = (char *)calloc(iov[i].iov_len, sizeof(char));
! 		if (!buf)
! 		  fatal("out of virtual memory in SYS_writev");
! 		mem_bcopy(mem_fn, mem, Read, (md_addr_t)iov[i].iov_base,
! 			  buf, iov[i].iov_len);
! 		iov[i].iov_base = buf;
! 	      }
! 	  }
! 
! 	/* perform the vector'ed write */
! 	/*result*/regs->regs_R[2] =
! 	  writev(/*fd*/regs->regs_R[4], iov, /*iovcnt*/regs->regs_R[6]);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
! 	  {
! 	    /* got an error, indicate results */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
! 	  }
! 
! 	/* free all the allocated memory */
! 	for (i=0; i < /*iovcnt*/regs->regs_R[6]; i++)
! 	  {
! 	    if (iov[i].iov_base)
! 	      {
! 		free(iov[i].iov_base);
! 		iov[i].iov_base = NULL;
! 	      }
! 	  }
! 	free(iov);
!       }
! #endif /* !_MSC_VER */
!       break;
! 
!     case SS_SYS_utimes:
        {
  	char buf[MAXBUFSIZE];
  
  	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[4], buf);
  
! 	if (/*timeval*/regs->regs_R[5] == 0)
  	  {
  #if defined(hpux) || defined(__hpux) || defined(linux)
  	    /* no utimes() in hpux, use utime() instead */
! 	    /*result*/regs->regs_R[2] = utime(buf, NULL);
  #elif defined(_MSC_VER)
! 	    /* no utimes() in MSC, use utime() instead */
! 	    /*result*/regs->regs_R[2] = utime(buf, NULL);
! #elif defined(__svr4__) || defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha) || defined(__APPLE__)
! 	    /*result*/regs->regs_R[2] = utimes(buf, NULL);
  #elif defined(__CYGWIN32__)
! 	    warn("syscall: called utimes()\n");
  #else
  #error No utimes() implementation!
  #endif
  	  }
  	else
  	  {
! 	    struct ss_timeval ss_tval[2];
  #ifndef _MSC_VER
  	    struct timeval tval[2];
  #endif /* !_MSC_VER */
  
  	    /* copy timeval structure to host memory */
! 	    mem_bcopy(mem_fn, mem, Read, /*timeout*/regs->regs_R[5],
! 		      ss_tval, 2*sizeof(struct ss_timeval));
  
  #ifndef _MSC_VER
  	    /* convert timeval structure to host format */
! 	    tval[0].tv_sec = MD_SWAPW(ss_tval[0].ss_tv_sec);
! 	    tval[0].tv_usec = MD_SWAPW(ss_tval[0].ss_tv_usec);
! 	    tval[1].tv_sec = MD_SWAPW(ss_tval[1].ss_tv_sec);
! 	    tval[1].tv_usec = MD_SWAPW(ss_tval[1].ss_tv_usec);
  #endif /* !_MSC_VER */
  
  #if defined(hpux) || defined(__hpux) || defined(__svr4__)
***************
*** 2365,3520 ****
  	    {
  	      struct utimbuf ubuf;
  
! 	      ubuf.actime = MD_SWAPW(tval[0].tv_sec);
! 	      ubuf.modtime = MD_SWAPW(tval[1].tv_sec);
  
! 	      /* result */regs->regs_R[MD_REG_V0] = utime(buf, &ubuf);
  	    }
  #elif defined(_MSC_VER)
!             /* no utimes() in hpux, use utime() instead */
!             {
!               struct _utimbuf ubuf;
! 
!               ubuf.actime = MD_SWAPW(osf_tval[0].osf_tv_sec);
!               ubuf.modtime = MD_SWAPW(osf_tval[1].osf_tv_sec);
! 
!               /* result */regs->regs_R[MD_REG_V0] = utime(buf, &ubuf);
!             }
! #elif defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha)
! 	    /* result */regs->regs_R[MD_REG_V0] = utimes(buf, tval);
  #elif defined(__CYGWIN32__)
! 	    warn("syscall: called utimes\n");
  #else
  #error No utimes() implementation!
  #endif
  	  }
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
        }
        break;
  
!     case OSF_SYS_getrlimit:
!     case OSF_SYS_setrlimit:
  #ifdef _MSC_VER
        warn("syscall get/setrlimit() not yet implemented for MSC...");
!       regs->regs_R[MD_REG_A3] = 0;
  #elif defined(__CYGWIN32__)
!       {
! 	warn("syscall: called get/setrlimit\n");
! 	regs->regs_R[MD_REG_A3] = 0;
!       }
  #else
        {
! 	struct osf_rlimit osf_rl;
  	struct rlimit rl;
  
  	/* copy rlimit structure to host memory */
! 	mem_bcopy(mem_fn, mem, Read, /*rlimit*/regs->regs_R[MD_REG_A1],
! 		  &osf_rl, sizeof(struct osf_rlimit));
  
  	/* convert rlimit structure to host format */
! 	rl.rlim_cur = MD_SWAPQ(osf_rl.osf_rlim_cur);
! 	rl.rlim_max = MD_SWAPQ(osf_rl.osf_rlim_max);
  
  	/* get rlimit information */
! 	if (syscode == OSF_SYS_getrlimit)
! 	  /*result*/regs->regs_R[MD_REG_V0] =
! 	    getrlimit(regs->regs_R[MD_REG_A0], &rl);
! 	else /* syscode == OSF_SYS_setrlimit */
! 	  /*result*/regs->regs_R[MD_REG_V0] =
! 	    setrlimit(regs->regs_R[MD_REG_A0], &rl);
  
  	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
  	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
  	  }
  
  	/* convert rlimit structure to target format */
! 	osf_rl.osf_rlim_cur = MD_SWAPQ(rl.rlim_cur);
! 	osf_rl.osf_rlim_max = MD_SWAPQ(rl.rlim_max);
  
  	/* copy rlimit structure to target memory */
! 	mem_bcopy(mem_fn, mem, Write, /*rlimit*/regs->regs_R[MD_REG_A1],
! 		  &osf_rl, sizeof(struct osf_rlimit));
        }
  #endif
        break;
  
!     case OSF_SYS_sigprocmask:
        {
! 	static int first = TRUE;
! 
! 	if (first)
! 	  {
! 	    warn("partially supported sigprocmask() call...");
! 	    first = FALSE;
! 	  }
  
! 	/* from klauser@cs.colorado.edu: there are a couple bugs in the
! 	   sigprocmask implementation; here is a fix: the problem comes from an
! 	   impedance mismatch between application/libc interface and
! 	   libc/syscall interface, the former of which you read about in the
! 	   manpage, the latter of which you actually intercept here.  The
! 	   following is mostly correct, but does not capture some minor
! 	   details, which you only get right if you really let the kernel
! 	   handle it. (e.g. you can't really ever block sigkill etc.) */
  
!         regs->regs_R[MD_REG_V0] = sigmask;
!         regs->regs_R[MD_REG_A3] = 0;
  
!         switch (regs->regs_R[MD_REG_A0])
  	  {
!           case OSF_SIG_BLOCK:
!             sigmask |= regs->regs_R[MD_REG_A1];
!             break;
!           case OSF_SIG_UNBLOCK:
!             sigmask &= ~regs->regs_R[MD_REG_A1];
!             break;
!           case OSF_SIG_SETMASK:
!             sigmask = regs->regs_R[MD_REG_A1];
!             break;
!           default:
!             regs->regs_R[MD_REG_V0] = EINVAL;
!             regs->regs_R[MD_REG_A3] = 1;
  	  }
  
! #if 0 /* FIXME: obsolete... */
! 	if (regs->regs_R[MD_REG_A2] > /* FIXME: why? */0x10000000)
! 	  mem_bcopy(mem_fn, mem, Write, regs->regs_R[MD_REG_A2],
! 		    &sigmask, sizeof(sigmask));
  
! 	if (regs->regs_R[MD_REG_A1] != 0)
! 	  {
! 	    switch (regs->regs_R[MD_REG_A0])
! 	      {
! 	      case OSF_SIG_BLOCK:
! 		sigmask |= regs->regs_R[MD_REG_A1];
! 		break;
! 	      case OSF_SIG_UNBLOCK:
! 		sigmask &= regs->regs_R[MD_REG_A1]; /* I think */
! 	      break;
! 	      case OSF_SIG_SETMASK:
! 		sigmask = regs->regs_R[MD_REG_A1]; /* I think */
! 		break;
! 	      default:
! 		panic("illegal how value to sigprocmask()");
! 	      }
! 	  }
! 	regs->regs_R[MD_REG_V0] = 0;
! 	regs->regs_R[MD_REG_A3] = 0;
! #endif
        }
        break;
  
!     case OSF_SYS_sigaction:
!       {
! 	int signum;
! 	static int first = TRUE;
! 
! 	if (first)
! 	  {
! 	    warn("partially supported sigaction() call...");
! 	    first = FALSE;
! 	  }
! 
! 	signum = regs->regs_R[MD_REG_A0];
! 	if (regs->regs_R[MD_REG_A1] != 0)
! 	  sigaction_array[signum] = regs->regs_R[MD_REG_A1];
! 
! 	if (regs->regs_R[MD_REG_A2])
! 	  regs->regs_R[MD_REG_A2] = sigaction_array[signum];
! 
! 	regs->regs_R[MD_REG_V0] = 0;
  
! 	/* for some reason, __sigaction expects A3 to have a 0 return value */
! 	regs->regs_R[MD_REG_A3] = 0;
!   
! 	/* FIXME: still need to add code so that on a signal, the 
! 	   correct action is actually taken. */
! 
! 	/* FIXME: still need to add support for returning the correct
! 	   error messages (EFAULT, EINVAL) */
!       }
!       break;
! 
!     case OSF_SYS_sigstack:
!       warn("unsupported sigstack() call...");
!       regs->regs_R[MD_REG_A3] = 0;
!       break;
! 
!     case OSF_SYS_sigreturn:
!       {
! 	int i;
! 	struct osf_sigcontext sc;
! 	static int first = TRUE;
! 
! 	if (first)
! 	  {
! 	    warn("partially supported sigreturn() call...");
! 	    first = FALSE;
! 	  }
! 
! 	mem_bcopy(mem_fn, mem, Read, /* sc */regs->regs_R[MD_REG_A0],
! 		  &sc, sizeof(struct osf_sigcontext));
! 
! 	sigmask = MD_SWAPQ(sc.sc_mask); /* was: prog_sigmask */
! 	regs->regs_NPC = MD_SWAPQ(sc.sc_pc);
! 
! 	/* FIXME: should check for the branch delay bit */
! 	/* FIXME: current->nextpc = current->pc + 4; not sure about this... */
! 	for (i=0; i < 32; ++i)
! 	  regs->regs_R[i] = sc.sc_regs[i];
! 	for (i=0; i < 32; ++i)
! 	  regs->regs_F.q[i] = sc.sc_fpregs[i];
! 	regs->regs_C.fpcr = sc.sc_fpcr;
!       }
!       break;
! 
!     case OSF_SYS_uswitch:
!       warn("unsupported uswitch() call...");
!       regs->regs_R[MD_REG_V0] = regs->regs_R[MD_REG_A1]; 
!       break;
! 
!     case OSF_SYS_setsysinfo:
!       warn("unsupported setsysinfo() call...");
!       regs->regs_R[MD_REG_V0] = 0; 
!       break;
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_getdirentries:
!       {
! 	int i, cnt, osf_cnt;
! 	struct dirent *p;
! 	sword_t fd = regs->regs_R[MD_REG_A0];
! 	md_addr_t osf_buf = regs->regs_R[MD_REG_A1];
! 	char *buf;
! 	sword_t osf_nbytes = regs->regs_R[MD_REG_A2];
! 	md_addr_t osf_pbase = regs->regs_R[MD_REG_A3];
! 	sqword_t osf_base;
! 	long base = 0;
! 
! 	/* number of entries in simulated memory */
! 	if (!osf_nbytes)
! 	  warn("attempting to get 0 directory entries...");
! 
! 	/* allocate local memory, whatever fits */
! 	buf = calloc(1, osf_nbytes);
! 	if (!buf)
! 	  fatal("out of virtual memory");
! 
! 	/* get directory entries */
! #if defined(__svr4__)
! 	base = lseek ((int)fd, (off_t)0, SEEK_CUR);
! 	regs->regs_R[MD_REG_V0] =
! 	  getdents((int)fd, (struct dirent *)buf, (size_t)osf_nbytes);
! #else /* !__svr4__ */
! 	regs->regs_R[MD_REG_V0] =
! 	  getdirentries((int)fd, buf, (size_t)osf_nbytes, &base);
! #endif
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  {
! 	    regs->regs_R[MD_REG_A3] = 0;
! 
! 	    /* anything to copy back? */
! 	    if (regs->regs_R[MD_REG_V0] > 0)
! 	      {
! 		/* copy all possible results to simulated space */
! 		for (i=0, cnt=0, osf_cnt=0, p=(struct dirent *)buf;
! 		     cnt < regs->regs_R[MD_REG_V0] && p->d_reclen > 0;
! 		     i++, cnt += p->d_reclen, p=(struct dirent *)(buf+cnt))
! 		  {
! 		    struct osf_dirent osf_dirent;
! 
! 		    osf_dirent.d_ino = MD_SWAPW(p->d_ino);
! 		    osf_dirent.d_namlen = MD_SWAPH(strlen(p->d_name));
! 		    strcpy(osf_dirent.d_name, p->d_name);
! 		    osf_dirent.d_reclen = MD_SWAPH(OSF_DIRENT_SZ(p->d_name));
! 
! 		    mem_bcopy(mem_fn, mem, Write,
! 			      osf_buf + osf_cnt,
! 			      &osf_dirent, OSF_DIRENT_SZ(p->d_name));
! 		    osf_cnt += OSF_DIRENT_SZ(p->d_name);
! 		  }
! 
! 		if (osf_pbase != 0)
! 		  {
! 		    osf_base = (sqword_t)base;
! 		    mem_bcopy(mem_fn, mem, Write, osf_pbase,
! 			      &osf_base, sizeof(osf_base));
! 		  }
! 
! 		/* update V0 to indicate translated read length */
! 		regs->regs_R[MD_REG_V0] = osf_cnt;
! 	      }
! 	  }
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 
! 	free(buf);
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_truncate:
!       {
! 	char buf[MAXBUFSIZE];
! 
! 	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fname*/regs->regs_R[MD_REG_A0], buf);
! 
! 	/* truncate the file */
! 	/*result*/regs->regs_R[MD_REG_V0] =
! 	  truncate(buf, /* length */(size_t)regs->regs_R[MD_REG_A1]);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
!       }
!       break;
! #endif
! 
! #if /*!defined(__CYGWIN32__) &&*/ !defined(_MSC_VER)
!     case OSF_SYS_ftruncate:
!       /* truncate the file */
!       /*result*/regs->regs_R[MD_REG_V0] =
! 	ftruncate(/* fd */(int)regs->regs_R[MD_REG_A0],
! 		 /* length */(size_t)regs->regs_R[MD_REG_A1]);
! 
!       /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
! 	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
! 	}
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_statfs:
!       {
! 	char buf[MAXBUFSIZE];
! 	struct osf_statfs osf_sbuf;
! 	struct statfs sbuf;
! 
! 	/* copy filename to host memory */
! 	mem_strcpy(mem_fn, mem, Read, /*fName*/regs->regs_R[MD_REG_A0], buf);
! 
! 	/* statfs() the fs */
! 	/*result*/regs->regs_R[MD_REG_V0] = statfs(buf, &sbuf);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 
! 	/* translate from host stat structure to target format */
! #if defined(__svr4__) || defined(__osf__)
! 	osf_sbuf.f_type = MD_SWAPH(0x6969) /* NFS, whatever... */;
! #else /* !__svr4__ */
! 	osf_sbuf.f_type = MD_SWAPH(sbuf.f_type);
! #endif
! 	osf_sbuf.f_fsize = MD_SWAPW(sbuf.f_bsize);
! 	osf_sbuf.f_blocks = MD_SWAPW(sbuf.f_blocks);
! 	osf_sbuf.f_bfree = MD_SWAPW(sbuf.f_bfree);
! 	osf_sbuf.f_bavail = MD_SWAPW(sbuf.f_bavail);
! 	osf_sbuf.f_files = MD_SWAPW(sbuf.f_files);
! 	osf_sbuf.f_ffree = MD_SWAPW(sbuf.f_ffree);
! 	/* osf_sbuf.f_fsid = MD_SWAPW(sbuf.f_fsid); */
! 
! 	/* copy stat() results to simulator memory */
! 	mem_bcopy(mem_fn, mem, Write, /*sbuf*/regs->regs_R[MD_REG_A1],
! 		  &osf_sbuf, sizeof(struct osf_statbuf));
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_setregid:
!       /* set real and effective group ID */
! 
!       /*result*/regs->regs_R[MD_REG_V0] =
! 	setregid(/* rgid */(gid_t)regs->regs_R[MD_REG_A0],
! 		 /* egid */(gid_t)regs->regs_R[MD_REG_A1]);
! 
!       /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
! 	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
! 	}
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_setreuid:
!       /* set real and effective user ID */
! 
!       /*result*/regs->regs_R[MD_REG_V0] =
! 	setreuid(/* ruid */(uid_t)regs->regs_R[MD_REG_A0],
! 		 /* euid */(uid_t)regs->regs_R[MD_REG_A1]);
! 
!       /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
! 	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
! 	}
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_socket:
!       /* create an endpoint for communication */
! 
!       /* result */regs->regs_R[MD_REG_V0] =
! 	socket(/* domain */xlate_arg((int)regs->regs_R[MD_REG_A0],
! 				     family_map, N_ELT(family_map),
! 				     "socket(family)"),
! 	       /* type */xlate_arg((int)regs->regs_R[MD_REG_A1],
! 				   socktype_map, N_ELT(socktype_map),
! 				   "socket(type)"),
! 	       /* protocol */xlate_arg((int)regs->regs_R[MD_REG_A2],
! 				       family_map, N_ELT(family_map),
! 				       "socket(proto)"));
! 
!       /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
! 	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
! 	}
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_connect:
!       {
! 	struct osf_sockaddr osf_sa;
! 
! 	/* initiate a connection on a socket */
! 
! 	/* get the socket address */
! 	if (regs->regs_R[MD_REG_A2] > sizeof(struct osf_sockaddr))
! 	  {
! 	    fatal("sockaddr size overflow: addrlen = %d",
! 		  regs->regs_R[MD_REG_A2]);
! 	  }
! 	/* copy sockaddr structure to host memory */
! 	mem_bcopy(mem_fn, mem, Read, /* serv_addr */regs->regs_R[MD_REG_A1],
! 		  &osf_sa, /* addrlen */(int)regs->regs_R[MD_REG_A2]);
! #if 0
! 	int i;
! 	sa.sa_family = osf_sa.sa_family;
! 	for (i=0; i < regs->regs_R[MD_REG_A2]; i++)
! 	  sa.sa_data[i] = osf_sa.sa_data[i];
! #endif
! 	/* result */regs->regs_R[MD_REG_V0] =
! 	  connect(/* sockfd */(int)regs->regs_R[MD_REG_A0],
! 		  (void *)&osf_sa, /* addrlen */(int)regs->regs_R[MD_REG_A2]);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_uname:
!       /* get name and information about current kernel */
! 
!       regs->regs_R[MD_REG_A3] = -1;
!       regs->regs_R[MD_REG_V0] = EPERM;
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_writev:
!       {
! 	int i;
! 	char *buf;
! 	struct iovec *iov;
! 
! 	/* allocate host side I/O vectors */
! 	iov =
! 	  (struct iovec *)malloc(/* iovcnt */regs->regs_R[MD_REG_A2]
! 				 * sizeof(struct iovec));
! 	if (!iov)
! 	  fatal("out of virtual memory in SYS_writev");
! 
! 	/* copy target side I/O vector buffers to host memory */
! 	for (i=0; i < /* iovcnt */regs->regs_R[MD_REG_A2]; i++)
! 	  {
! 	    struct osf_iovec osf_iov;
! 
! 	    /* copy target side pointer data into host side vector */
! 	    mem_bcopy(mem_fn, mem, Read,
! 		      (/*iov*/regs->regs_R[MD_REG_A1]
! 		       + i*sizeof(struct osf_iovec)),
! 		      &osf_iov, sizeof(struct osf_iovec));
! 
! 	    iov[i].iov_len = MD_SWAPW(osf_iov.iov_len);
! 	    if (osf_iov.iov_base != 0 && osf_iov.iov_len != 0)
! 	      {
! 		buf = (char *)calloc(MD_SWAPW(osf_iov.iov_len), sizeof(char));
! 		if (!buf)
! 		  fatal("out of virtual memory in SYS_writev");
! 		mem_bcopy(mem_fn, mem, Read, MD_SWAPQ(osf_iov.iov_base),
! 			  buf, MD_SWAPW(osf_iov.iov_len));
! 		iov[i].iov_base = buf;
! 	      }
! 	    else
! 	      iov[i].iov_base = NULL;
! 	  }
! 
! 	/* perform the vector'ed write */
! 	do {
! 	  /*result*/regs->regs_R[MD_REG_V0] =
! 	    writev(/* fd */(int)regs->regs_R[MD_REG_A0], iov,
! 		   /* iovcnt */(size_t)regs->regs_R[MD_REG_A2]);
! 	} while (/*result*/regs->regs_R[MD_REG_V0] == -1
! 	         && errno == EAGAIN);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 
! 	/* free all the allocated memory */
! 	for (i=0; i < /* iovcnt */regs->regs_R[MD_REG_A2]; i++)
! 	  {
! 	    if (iov[i].iov_base)
! 	      {
! 		free(iov[i].iov_base);
! 		iov[i].iov_base = NULL;
! 	      }
! 	  }
! 	free(iov);
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_readv:
!       {
! 	int i;
! 	char *buf = NULL;
! 	struct osf_iovec *osf_iov;
! 	struct iovec *iov;
! 
! 	/* allocate host side I/O vectors */
! 	osf_iov =
! 	  calloc(/* iovcnt */regs->regs_R[MD_REG_A2],
! 		 sizeof(struct osf_iovec));
! 	if (!osf_iov)
! 	  fatal("out of virtual memory in SYS_readv");
! 
! 	iov =
! 	  calloc(/* iovcnt */regs->regs_R[MD_REG_A2], sizeof(struct iovec));
! 	if (!iov)
! 	  fatal("out of virtual memory in SYS_readv");
! 
! 	/* copy host side I/O vector buffers */
! 	for (i=0; i < /* iovcnt */regs->regs_R[MD_REG_A2]; i++)
! 	  {
! 	    /* copy target side pointer data into host side vector */
! 	    mem_bcopy(mem_fn, mem, Read,
! 		      (/*iov*/regs->regs_R[MD_REG_A1]
! 		       + i*sizeof(struct osf_iovec)),
! 		      &osf_iov[i], sizeof(struct osf_iovec));
! 
! 	    iov[i].iov_len = MD_SWAPW(osf_iov[i].iov_len);
! 	    if (osf_iov[i].iov_base != 0 && osf_iov[i].iov_len != 0)
! 	      {
! 		buf =
! 		  (char *)calloc(MD_SWAPW(osf_iov[i].iov_len), sizeof(char));
! 		if (!buf)
! 		  fatal("out of virtual memory in SYS_readv");
! 		iov[i].iov_base = buf;
! 	      }
! 	    else
! 	      iov[i].iov_base = NULL;
! 	  }
! 
! 	/* perform the vector'ed read */
! 	do {
! 	  /*result*/regs->regs_R[MD_REG_V0] =
! 	    readv(/* fd */(int)regs->regs_R[MD_REG_A0], iov,
! 		  /* iovcnt */(size_t)regs->regs_R[MD_REG_A2]);
! 	} while (/*result*/regs->regs_R[MD_REG_V0] == -1
! 		 && errno == EAGAIN);
! 
! 	/* copy target side I/O vector buffers to host memory */
! 	for (i=0; i < /* iovcnt */regs->regs_R[MD_REG_A2]; i++)
! 	  {
! 	    if (osf_iov[i].iov_base != 0)
! 	      {
! 		mem_bcopy(mem_fn, mem, Write, MD_SWAPQ(osf_iov[i].iov_base),
! 			  iov[i].iov_base, MD_SWAPW(osf_iov[i].iov_len));
! 	      }
! 	  }
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 
! 	/* free all the allocated memory */
! 	for (i=0; i < /* iovcnt */regs->regs_R[MD_REG_A2]; i++)
! 	  {
! 	    if (iov[i].iov_base)
! 	      {
! 		free(iov[i].iov_base);
! 		iov[i].iov_base = NULL;
! 	      }
! 	  }
! 
! 	if (osf_iov)
! 	  free(osf_iov);
! 	if (iov)
! 	  free(iov);
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_setsockopt:
!       {
! 	char *buf;
! 	struct xlate_table_t *map;
! 	int nmap;
! 
!  	/* set options on sockets */
! 
! 	/* copy optval to host memory */
! 	if (/* optval */regs->regs_R[MD_REG_A3] != 0
! 	    && /* optlen */regs->regs_R[MD_REG_A4] != 0)
! 	  {
! 	    buf = calloc(1, /* optlen */(size_t)regs->regs_R[MD_REG_A4]);
! 	    if (!buf)
! 	      fatal("cannot allocate memory in OSF_SYS_setsockopt");
! 	    
! 	    /* copy target side pointer data into host side vector */
! 	    mem_bcopy(mem_fn, mem, Read,
! 		      /* optval */regs->regs_R[MD_REG_A3],
! 		      buf, /* optlen */(int)regs->regs_R[MD_REG_A4]);
! 	  }
! 	else
! 	  buf = NULL;
! 
! 	/* pick the correct translation table */
! 	if ((int)regs->regs_R[MD_REG_A1] == OSF_SOL_SOCKET)
! 	  {
! 	    map = sockopt_map;
! 	    nmap = N_ELT(sockopt_map);
! 	  }
! 	else if ((int)regs->regs_R[MD_REG_A1] == OSF_SOL_TCP)
! 	  {
! 	    map = tcpopt_map;
! 	    nmap = N_ELT(tcpopt_map);
! 	  }
! 	else
! 	  {
! 	    warn("no translation map available for `setsockopt()': %d",
! 		 (int)regs->regs_R[MD_REG_A1]);
! 	    map = sockopt_map;
! 	    nmap = N_ELT(sockopt_map);
! 	  }
! 
! 	/* result */regs->regs_R[MD_REG_V0] =
! 	  setsockopt(/* sock */(int)regs->regs_R[MD_REG_A0],
! 		     /* level */xlate_arg((int)regs->regs_R[MD_REG_A1],
! 					  socklevel_map, N_ELT(socklevel_map),
! 					  "setsockopt(level)"),
! 		     /* optname */xlate_arg((int)regs->regs_R[MD_REG_A2],
! 					    map, nmap,
! 					    "setsockopt(opt)"),
! 		     /* optval */buf,
! 		     /* optlen */regs->regs_R[MD_REG_A4]);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 
! 	if (buf != NULL)
! 	  free(buf);
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_old_getsockname:
!       {
! 	/* get socket name */
! 	char *buf;
! 	word_t osf_addrlen;
! 	int addrlen;
! 
! 	/* get simulator memory parameters to host memory */
! 	mem_bcopy(mem_fn, mem, Read,
! 		  /* paddrlen */regs->regs_R[MD_REG_A2],
! 		  &osf_addrlen, sizeof(osf_addrlen));
! 	addrlen = (int)osf_addrlen;
! 	if (addrlen != 0)
! 	  {
! 	    buf = calloc(1, addrlen);
! 	    if (!buf)
! 	      fatal("cannot allocate memory in OSF_SYS_old_getsockname");
! 	  }
! 	else
! 	  buf = NULL;
! 	
! 	/* result */regs->regs_R[MD_REG_V0] =
! 	  getsockname(/* sock */(int)regs->regs_R[MD_REG_A0],
! 		      /* name */(struct sockaddr *)buf,
! 		      /* namelen */&addrlen);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 
! 	/* copy results to simulator memory */
! 	if (addrlen != 0)
! 	  mem_bcopy(mem_fn, mem, Write,
! 		    /* addr */regs->regs_R[MD_REG_A1],
! 		    buf, addrlen);
! 	osf_addrlen = (qword_t)addrlen;
! 	mem_bcopy(mem_fn, mem, Write,
! 		  /* paddrlen */regs->regs_R[MD_REG_A2],
! 		  &osf_addrlen, sizeof(osf_addrlen));
! 
! 	if (buf != NULL)
! 	  free(buf);
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_old_getpeername:
!       {
! 	/* get socket name */
! 	char *buf;
! 	word_t osf_addrlen;
! 	int addrlen;
! 
! 	/* get simulator memory parameters to host memory */
! 	mem_bcopy(mem_fn, mem, Read,
! 		  /* paddrlen */regs->regs_R[MD_REG_A2],
! 		  &osf_addrlen, sizeof(osf_addrlen));
! 	addrlen = (int)osf_addrlen;
! 	if (addrlen != 0)
! 	  {
! 	    buf = calloc(1, addrlen);
! 	    if (!buf)
! 	      fatal("cannot allocate memory in OSF_SYS_old_getsockname");
! 	  }
! 	else
! 	  buf = NULL;
! 	
! 	/* result */regs->regs_R[MD_REG_V0] =
! 	  getpeername(/* sock */(int)regs->regs_R[MD_REG_A0],
! 		      /* name */(struct sockaddr *)buf,
! 		      /* namelen */&addrlen);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 
! 	/* copy results to simulator memory */
! 	if (addrlen != 0)
! 	  mem_bcopy(mem_fn, mem, Write,
! 		    /* addr */regs->regs_R[MD_REG_A1],
! 		    buf, addrlen);
! 	osf_addrlen = (qword_t)addrlen;
! 	mem_bcopy(mem_fn, mem, Write,
! 		  /* paddrlen */regs->regs_R[MD_REG_A2],
! 		  &osf_addrlen, sizeof(osf_addrlen));
! 
! 	if (buf != NULL)
! 	  free(buf);
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_setgid:
!       /* set group ID */
! 
!       /*result*/regs->regs_R[MD_REG_V0] =
! 	setgid(/* gid */(gid_t)regs->regs_R[MD_REG_A0]);
! 
!       /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
! 	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
! 	}
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_setuid:
!       /* set user ID */
! 
!       /*result*/regs->regs_R[MD_REG_V0] =
! 	setuid(/* uid */(uid_t)regs->regs_R[MD_REG_A0]);
! 
!       /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
! 	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
! 	}
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_getpriority:
!       /* get program scheduling priority */
! 
!       /*result*/regs->regs_R[MD_REG_V0] =
! 	getpriority(/* which */(int)regs->regs_R[MD_REG_A0],
! 		    /* who */(int)regs->regs_R[MD_REG_A1]);
! 
!       /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
! 	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
! 	}
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_setpriority:
!       /* set program scheduling priority */
! 
!       /*result*/regs->regs_R[MD_REG_V0] =
! 	setpriority(/* which */(int)regs->regs_R[MD_REG_A0],
! 		    /* who */(int)regs->regs_R[MD_REG_A1],
! 		    /* prio */(int)regs->regs_R[MD_REG_A2]);
! 
!       /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
! 	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
! 	}
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_select:
!       {
! 	fd_set readfd, writefd, exceptfd;
! 	fd_set *readfdp, *writefdp, *exceptfdp;
! 	struct timeval timeout, *timeoutp;
! 
! 	/* copy read file descriptor set into host memory */
! 	if (/* readfds */regs->regs_R[MD_REG_A1] != 0)
! 	  {
! 	    mem_bcopy(mem_fn, mem, Read,
! 		      /* readfds */regs->regs_R[MD_REG_A1],
! 		      &readfd, sizeof(fd_set));
! 	    readfdp = &readfd;
! 	  }
! 	else
! 	  readfdp = NULL;
! 
! 	/* copy write file descriptor set into host memory */
! 	if (/* writefds */regs->regs_R[MD_REG_A2] != 0)
! 	  {
! 	    mem_bcopy(mem_fn, mem, Read,
! 		      /* writefds */regs->regs_R[MD_REG_A2],
! 		      &writefd, sizeof(fd_set));
! 	    writefdp = &writefd;
! 	  }
! 	else
! 	  writefdp = NULL;
! 
! 	/* copy exception file descriptor set into host memory */
! 	if (/* exceptfds */regs->regs_R[MD_REG_A3] != 0)
! 	  {
! 	    mem_bcopy(mem_fn, mem, Read,
! 		      /* exceptfds */regs->regs_R[MD_REG_A3],
! 		      &exceptfd, sizeof(fd_set));
! 	    exceptfdp = &exceptfd;
! 	  }
! 	else
! 	  exceptfdp = NULL;
! 
! 	/* copy timeout value into host memory */
! 	if (/* timeout */regs->regs_R[MD_REG_A4] != 0)
! 	  {
! 	    mem_bcopy(mem_fn, mem, Read,
! 		      /* timeout */regs->regs_R[MD_REG_A4],
! 		      &timeout, sizeof(struct timeval));
! 	    timeoutp = &timeout;
! 	  }
! 	else
! 	  timeoutp = NULL;
! 
! #if defined(hpux) || defined(__hpux)
! 	/* select() on the specified file descriptors */
! 	/* result */regs->regs_R[MD_REG_V0] =
! 	  select(/* nfds */regs->regs_R[MD_REG_A0],
! 		 (int *)readfdp, (int *)writefdp, (int *)exceptfdp, timeoutp);
! #else
! 	/* select() on the specified file descriptors */
! 	/* result */regs->regs_R[MD_REG_V0] =
! 	  select(/* nfds */regs->regs_R[MD_REG_A0],
! 		 readfdp, writefdp, exceptfdp, timeoutp);
! #endif
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 
! 	/* copy read file descriptor set to target memory */
! 	if (/* readfds */regs->regs_R[MD_REG_A1] != 0)
! 	  mem_bcopy(mem_fn, mem, Write,
! 		    /* readfds */regs->regs_R[MD_REG_A1],
! 		    &readfd, sizeof(fd_set));
! 
! 	/* copy write file descriptor set to target memory */
! 	if (/* writefds */regs->regs_R[MD_REG_A2] != 0)
! 	  mem_bcopy(mem_fn, mem, Write,
! 		    /* writefds */regs->regs_R[MD_REG_A2],
! 		    &writefd, sizeof(fd_set));
! 
! 	/* copy exception file descriptor set to target memory */
! 	if (/* exceptfds */regs->regs_R[MD_REG_A3] != 0)
! 	  mem_bcopy(mem_fn, mem, Write,
! 		    /* exceptfds */regs->regs_R[MD_REG_A3],
! 		    &exceptfd, sizeof(fd_set));
! 
! 	/* copy timeout value result to target memory */
! 	if (/* timeout */regs->regs_R[MD_REG_A4] != 0)
! 	  mem_bcopy(mem_fn, mem, Write,
! 		    /* timeout */regs->regs_R[MD_REG_A4],
! 		    &timeout, sizeof(struct timeval));
!       }
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_shutdown:
!       /* shuts down socket send and receive operations */
! 
!       /*result*/regs->regs_R[MD_REG_V0] =
! 	shutdown(/* sock */(int)regs->regs_R[MD_REG_A0],
! 		 /* how */(int)regs->regs_R[MD_REG_A1]);
! 
!       /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
! 	{
! 	  regs->regs_R[MD_REG_A3] = -1;
! 	  regs->regs_R[MD_REG_V0] = errno;
! 	}
!       break;
! #endif
! 
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_poll:
!       {
! 	int i;
! 	struct pollfd *fds;
! 
! 	/* allocate host side I/O vectors */
! 	fds = calloc(/* nfds */regs->regs_R[MD_REG_A1], sizeof(struct pollfd));
! 	if (!fds)
! 	  fatal("out of virtual memory in SYS_poll");
! 
! 	/* copy target side I/O vector buffers to host memory */
! 	for (i=0; i < /* nfds */regs->regs_R[MD_REG_A1]; i++)
! 	  {
! 	    /* copy target side pointer data into host side vector */
! 	    mem_bcopy(mem_fn, mem, Read,
! 		      (/* fds */regs->regs_R[MD_REG_A0]
! 		       + i*sizeof(struct pollfd)),
! 		      &fds[i], sizeof(struct pollfd));
! 	  }
! 
! 	/* perform the vector'ed write */
! 	/* result */regs->regs_R[MD_REG_V0] =
! 	  poll(/* fds */fds,
! 	       /* nfds */(unsigned long)regs->regs_R[MD_REG_A1],
! 	       /* timeout */(int)regs->regs_R[MD_REG_A2]);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 
! 	/* copy target side I/O vector buffers to host memory */
! 	for (i=0; i < /* nfds */regs->regs_R[MD_REG_A1]; i++)
! 	  {
! 	    /* copy target side pointer data into host side vector */
! 	    mem_bcopy(mem_fn, mem, Write,
! 		      (/* fds */regs->regs_R[MD_REG_A0]
! 		       + i*sizeof(struct pollfd)),
! 		      &fds[i], sizeof(struct pollfd));
! 	  }
! 
! 	/* free all the allocated memory */
! 	free(fds);
!       }
!       break;
! #endif
! 
!     case OSF_SYS_usleep_thread:
! #if 0
!       fprintf(stderr, "usleep(%d)\n", (unsigned int)regs->regs_R[MD_REG_A0]);
! #endif
! #ifdef alpha
!       regs->regs_R[MD_REG_V0] = usleep((unsigned int)regs->regs_R[MD_REG_A0]);
! #else
!       usleep((unsigned int)regs->regs_R[MD_REG_A0]);
!       regs->regs_R[MD_REG_V0] = 0;
! #endif
!       /* check for an error condition */
!       if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
!         regs->regs_R[MD_REG_A3] = 0;
!       else /* got an error, return details */
!         {
!           regs->regs_R[MD_REG_A3] = -1;
!           regs->regs_R[MD_REG_V0] = errno;
!         }
! #if 0
!       warn("unsupported usleep_thread() call...");
!       regs->regs_R[MD_REG_V0] = 0; 
! #endif
!       break;
!       
! #if !defined(MIN_SYSCALL_MODE)
!     case OSF_SYS_gethostname:
!       /* get program scheduling priority */
!       {
! 	char *buf;
! 
! 	buf = malloc(/* len */(size_t)regs->regs_R[MD_REG_A1]);
! 	if (!buf)
! 	  fatal("out of virtual memory in gethostname()");
! 
! 	/* result */regs->regs_R[MD_REG_V0] =
! 	  gethostname(/* name */buf,
! 		      /* len */(size_t)regs->regs_R[MD_REG_A1]);
! 
! 	/* check for an error condition */
! 	if (regs->regs_R[MD_REG_V0] != (qword_t)-1)
! 	  regs->regs_R[MD_REG_A3] = 0;
! 	else /* got an error, return details */
! 	  {
! 	    regs->regs_R[MD_REG_A3] = -1;
! 	    regs->regs_R[MD_REG_V0] = errno;
! 	  }
! 
! 	/* copy string back to simulated memory */
! 	mem_bcopy(mem_fn, mem, Write,
! 		  /* name */regs->regs_R[MD_REG_A0],
! 		  buf, /* len */regs->regs_R[MD_REG_A1]);
!       }
!       break;
! #endif
! 
!     case OSF_SYS_madvise:
!       warn("unsupported madvise() call ignored...");
!       regs->regs_R[MD_REG_V0] = 0;
!       break;
! 
!     default:
!       warn("invalid/unimplemented syscall %ld, PC=0x%08p, RA=0x%08p, winging it",
! 	   syscode, regs->regs_PC, regs->regs_R[MD_REG_RA]);
!       regs->regs_R[MD_REG_A3] = -1;
!       regs->regs_R[MD_REG_V0] = 0;
! #if 0
!       fatal("invalid/unimplemented system call encountered, code %d", syscode);
! #endif
!     }
  
-   if (verbose)
-     fprintf(stderr, "syscall(%d): returned %d:%d...\n",
-             (int)syscode, (int)regs->regs_R[MD_REG_A3],
-             (int)regs->regs_R[MD_REG_V0]);
  }
--- 1899,2035 ----
  	    {
  	      struct utimbuf ubuf;
  
! 	      ubuf.actime = tval[0].tv_sec;
! 	      ubuf.modtime = tval[1].tv_sec;
  
! 	      /* result */regs->regs_R[2] = utime(buf, &ubuf);
  	    }
  #elif defined(_MSC_VER)
! 	    /* no utimes() in MSC, use utime() instead */
! 	    {
! 	      struct _utimbuf ubuf;
! 
! 	      ubuf.actime = ss_tval[0].ss_tv_sec;
! 	      ubuf.modtime = ss_tval[1].ss_tv_sec;
! 
! 	      /* result */regs->regs_R[2] = utime(buf, &ubuf);
! 	    }
! #elif defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha) || defined(__APPLE__)
! 	    /* result */regs->regs_R[2] = utimes(buf, tval);
  #elif defined(__CYGWIN32__)
! 	    warn("syscall: called utimes()\n");
  #else
  #error No utimes() implementation!
  #endif
  	  }
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, indicate results */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
        }
        break;
  
!     case SS_SYS_getrlimit:
!     case SS_SYS_setrlimit:
  #ifdef _MSC_VER
        warn("syscall get/setrlimit() not yet implemented for MSC...");
!       regs->regs_R[7] = 0;
  #elif defined(__CYGWIN32__)
!       warn("syscall: called get/setrlimit()\n");
!       regs->regs_R[7] = 0;
  #else
        {
! 	/* FIXME: check this..., was: struct rlimit ss_rl; */
! 	struct ss_rlimit ss_rl;
  	struct rlimit rl;
  
  	/* copy rlimit structure to host memory */
! 	mem_bcopy(mem_fn, mem, Read, /*rlimit*/regs->regs_R[5],
! 		  &ss_rl, sizeof(struct ss_rlimit));
  
  	/* convert rlimit structure to host format */
! 	rl.rlim_cur = MD_SWAPW(ss_rl.ss_rlim_cur);
! 	rl.rlim_max = MD_SWAPW(ss_rl.ss_rlim_max);
  
  	/* get rlimit information */
! 	if (syscode == SS_SYS_getrlimit)
! 	  /*result*/regs->regs_R[2] = getrlimit(regs->regs_R[4], &rl);
! 	else /* syscode == SS_SYS_setrlimit */
! 	  /*result*/regs->regs_R[2] = setrlimit(regs->regs_R[4], &rl);
  
  	/* check for an error condition */
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    /* got an error, indicate results */
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
  
  	/* convert rlimit structure to target format */
! 	ss_rl.ss_rlim_cur = MD_SWAPW(rl.rlim_cur);
! 	ss_rl.ss_rlim_max = MD_SWAPW(rl.rlim_max);
  
  	/* copy rlimit structure to target memory */
! 	mem_bcopy(mem_fn, mem, Write, /*rlimit*/regs->regs_R[5],
! 		  &ss_rl, sizeof(struct ss_rlimit));
        }
  #endif
        break;
  
! #if 0
!     case SS_SYS_getdirentries:
!       /* FIXME: this is currently broken due to incompatabilities in
! 	 disk directory formats */
        {
! 	unsigned int i;
! 	char *buf;
! 	int base;
  
! 	buf = (char *)calloc(/* nbytes */regs->regs_R[6] + 1, sizeof(char));
! 	if (!buf)
! 	  fatal("out of memory in SYS_getdirentries");
  
! 	/* copy in */
! 	for (i=0; i</* nbytes */regs->regs_R[6]; i++)
! 	  (*maf)(Read, /* buf */regs->regs_R[5]+i,
! 		 (unsigned char *)&buf[i], 1);
! 	(*maf)(Read, /* basep */regs->regs_R[7], (unsigned char *)&base, 4);
! 
! 	/*cc*/regs->regs_R[2] =
! 	  getdirentries(/*fd*/regs->regs_R[4], buf,
! 			/*nbytes*/regs->regs_R[6], &base);
  
! 	if (regs->regs_R[2] != -1)
! 	  regs->regs_R[7] = 0;
! 	else
  	  {
! 	    regs->regs_R[2] = errno;
! 	    regs->regs_R[7] = 1;
  	  }
  
! 	/* copy out */
! 	for (i=0; i</* nbytes */regs->regs_R[6]; i++)
! 	  (*maf)(Write, /* buf */regs->regs_R[5]+i,
! 		 (unsigned char *)&buf[i], 1);
! 	(*maf)(Write, /* basep */regs->regs_R[7], (unsigned char *)&base, 4);
  
! 	free(buf);
        }
        break;
+ #endif
  
!     default:
!       panic("invalid/unimplemented system call encountered, code %d", syscode);
!     }
  
! #endif /* MD_CROSS_ENDIAN */
  
  }
diff -crB tmp/simplesim-3.0/target-alpha/syscall.c simplesim-3.0/target-alpha/syscall.c
*** tmp/simplesim-3.0/target-alpha/syscall.c	2011-03-11 23:57:48.000000000 -0600
--- simplesim-3.0/target-alpha/syscall.c	2011-09-30 20:57:52.000000000 -0500
***************
*** 116,122 ****
  #include <sys/select.h>
  #endif
  #endif
! #ifdef linux
  #include <sgtty.h>
  #include <netinet/tcp.h>
  #include <netinet/udp.h>
--- 116,122 ----
  #include <sys/select.h>
  #endif
  #endif
! #if defined(linux) || defined(__APPLE__)
  #include <sgtty.h>
  #include <netinet/tcp.h>
  #include <netinet/udp.h>
***************
*** 130,135 ****
--- 130,136 ----
  #endif /* __FreeBSD__ */
  
  #if defined(__svr4__)
+ #include <sys/types.h>
  #include <sys/dirent.h>
  #include <sys/filio.h>
  #elif defined(__osf__)
***************
*** 139,144 ****
--- 140,159 ----
   * -- SS-Alpha on. But the function exists in the libraries.
   */
  int getdirentries(int fd, char *buf, int nbytes, long *basep);
+ #elif _DARWIN_FEATURE_64_BIT_INODE
+ #include <dirent.h>
+ int darwin_legacy_getdirentries(int, char *, int, long *) __asm("_getdirentries");
+ #define getdirentries darwin_legacy_getdirentries
+ struct darwin_legacy_dirent {
+    __uint32_t d_ino;
+    __uint16_t d_reclen;
+    __uint8_t d_type;
+    __uint8_t d_namlen;
+    char d_name[__DARWIN_MAXNAMLEN + 1];
+ };
+ #define dirent darwin_legacy_dirent
+ #elif defined(__APPLE__)
+ #include <dirent.h>
  #endif
  
  #if defined(__svr4__) || defined(__osf__)
***************
*** 184,190 ****
  #undef CR0
  #endif
  
! #ifdef __FreeBSD__
  #include <termios.h>
  /*#include <sys/ioctl_compat.h>*/
  #else
--- 199,205 ----
  #undef CR0
  #endif
  
! #if defined(__FreeBSD__) || defined(__APPLE__)
  #include <termios.h>
  /*#include <sys/ioctl_compat.h>*/
  #else
***************
*** 834,840 ****
  
  struct xlate_table_t socklevel_map[] =
  {
! #if defined(__svr4__) || defined(__osf__) || defined(__FreeBSD__)
    { OSF_SOL_SOCKET,	SOL_SOCKET },
    { OSF_SOL_IP,		IPPROTO_IP },
    { OSF_SOL_TCP,	IPPROTO_TCP },
--- 849,855 ----
  
  struct xlate_table_t socklevel_map[] =
  {
! #if defined(__svr4__) || defined(__osf__) || defined(__FreeBSD__) || defined(__APPLE__)
    { OSF_SOL_SOCKET,	SOL_SOCKET },
    { OSF_SOL_IP,		IPPROTO_IP },
    { OSF_SOL_TCP,	IPPROTO_TCP },
***************
*** 2256,2262 ****
  	mem_bcopy(mem_fn, mem, Write, /*rusage*/regs->regs_R[MD_REG_A1],
  		  &rusage, sizeof(struct osf_rusage));
        }
! #elif defined(__unix__)
        {
  	struct rusage local_rusage;
  	struct osf_rusage rusage;
--- 2271,2277 ----
  	mem_bcopy(mem_fn, mem, Write, /*rusage*/regs->regs_R[MD_REG_A1],
  		  &rusage, sizeof(struct osf_rusage));
        }
! #elif defined(__unix__) || defined(__APPLE__)
        {
  	struct rusage local_rusage;
  	struct osf_rusage rusage;
***************
*** 2333,2339 ****
  #elif defined(_MSC_VER)
              /* no utimes() in MSC, use utime() instead */
  	    /*result*/regs->regs_R[MD_REG_V0] = utime(buf, NULL);
! #elif defined(__svr4__) || defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha)
  	    /*result*/regs->regs_R[MD_REG_V0] = utimes(buf, NULL);
  #elif defined(__CYGWIN32__)
  	    warn("syscall: called utimes\n");
--- 2348,2354 ----
  #elif defined(_MSC_VER)
              /* no utimes() in MSC, use utime() instead */
  	    /*result*/regs->regs_R[MD_REG_V0] = utime(buf, NULL);
! #elif defined(__svr4__) || defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha) || defined(__APPLE__)
  	    /*result*/regs->regs_R[MD_REG_V0] = utimes(buf, NULL);
  #elif defined(__CYGWIN32__)
  	    warn("syscall: called utimes\n");
***************
*** 2380,2386 ****
  
                /* result */regs->regs_R[MD_REG_V0] = utime(buf, &ubuf);
              }
! #elif defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha)
  	    /* result */regs->regs_R[MD_REG_V0] = utimes(buf, tval);
  #elif defined(__CYGWIN32__)
  	    warn("syscall: called utimes\n");
--- 2395,2401 ----
  
                /* result */regs->regs_R[MD_REG_V0] = utime(buf, &ubuf);
              }
! #elif defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha) || defined(__APPLE__)
  	    /* result */regs->regs_R[MD_REG_V0] = utimes(buf, tval);
  #elif defined(__CYGWIN32__)
  	    warn("syscall: called utimes\n");
Only in simplesim-3.0/target-alpha: syscall.c.orig
Only in simplesim-3.0/target-alpha: syscall.c.rej
diff -crB tmp/simplesim-3.0/target-pisa/syscall.c simplesim-3.0/target-pisa/syscall.c
*** tmp/simplesim-3.0/target-pisa/syscall.c	2011-03-12 00:02:21.000000000 -0600
--- simplesim-3.0/target-pisa/syscall.c	2011-09-30 20:50:13.000000000 -0500
***************
*** 99,105 ****
  #ifndef _MSC_VER
  #include <sys/ioctl.h>
  #endif
! #if !defined(linux) && !defined(sparc) && !defined(hpux) && !defined(__hpux) && !defined(__CYGWIN32__) && !defined(ultrix)
  #ifndef _MSC_VER
  #include <sys/select.h>
  #endif
--- 99,105 ----
  #ifndef _MSC_VER
  #include <sys/ioctl.h>
  #endif
! #if !defined(linux) && !defined(sparc) && !defined(hpux) && !defined(__hpux) && !defined(__CYGWIN32__) && !defined(ultrix) && !defined(__APPLE__)
  #ifndef _MSC_VER
  #include <sys/select.h>
  #endif
***************
*** 150,156 ****
  #undef CR0
  #endif
  
! #ifdef __FreeBSD__
  #include <termios.h>
  /*#include <sys/ioctl_compat.h>*/
  #else /* !__FreeBSD__ */
--- 150,156 ----
  #undef CR0
  #endif
  
! #if defined(__FreeBSD__) || defined(__APPLE__)
  #include <termios.h>
  /*#include <sys/ioctl_compat.h>*/
  #else /* !__FreeBSD__ */
***************
*** 1729,1735 ****
  	mem_bcopy(mem_fn, mem, Write, /*rusage*/regs->regs_R[5],
  		  &rusage, sizeof(struct ss_rusage));
        }
! #elif defined(__unix__) || defined(unix)
        {
  	struct rusage local_rusage;
  	struct ss_rusage rusage;
--- 1729,1735 ----
  	mem_bcopy(mem_fn, mem, Write, /*rusage*/regs->regs_R[5],
  		  &rusage, sizeof(struct ss_rusage));
        }
! #elif defined(__unix__) || defined(unix) || defined(__APPLE__)
        {
  	struct rusage local_rusage;
  	struct ss_rusage rusage;
***************
*** 1867,1873 ****
  #elif defined(_MSC_VER)
  	    /* no utimes() in MSC, use utime() instead */
  	    /*result*/regs->regs_R[2] = utime(buf, NULL);
! #elif defined(__svr4__) || defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha)
  	    /*result*/regs->regs_R[2] = utimes(buf, NULL);
  #elif defined(__CYGWIN32__)
  	    warn("syscall: called utimes()\n");
--- 1867,1873 ----
  #elif defined(_MSC_VER)
  	    /* no utimes() in MSC, use utime() instead */
  	    /*result*/regs->regs_R[2] = utime(buf, NULL);
! #elif defined(__svr4__) || defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha) || defined(__APPLE__)
  	    /*result*/regs->regs_R[2] = utimes(buf, NULL);
  #elif defined(__CYGWIN32__)
  	    warn("syscall: called utimes()\n");
***************
*** 1914,1920 ****
  
  	      /* result */regs->regs_R[2] = utime(buf, &ubuf);
  	    }
! #elif defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha)
  	    /* result */regs->regs_R[2] = utimes(buf, tval);
  #elif defined(__CYGWIN32__)
  	    warn("syscall: called utimes()\n");
--- 1914,1920 ----
  
  	      /* result */regs->regs_R[2] = utime(buf, &ubuf);
  	    }
! #elif defined(__USLC__) || defined(unix) || defined(_AIX) || defined(__alpha) || defined(__APPLE__)
  	    /* result */regs->regs_R[2] = utimes(buf, tval);
  #elif defined(__CYGWIN32__)
  	    warn("syscall: called utimes()\n");
Only in simplesim-3.0/target-pisa: syscall.c.orig
Only in simplesim-3.0/target-pisa: syscall.c.rej
diff -crB tmp/simplesim-3.0/tests/Makefile simplesim-3.0/tests/Makefile
*** tmp/simplesim-3.0/tests/Makefile	2000-11-08 11:55:52.000000000 -0600
--- simplesim-3.0/tests/Makefile	2000-11-08 11:56:13.000000000 -0600
***************
*** 2,7 ****
--- 2,8 ----
  # Makefile arguments:
  #
  #	DIFF	  = diff program
+ #	ENDIAN    = {big, little}
  #	SIM_DIR   = {simulator directory}
  #	SIM_BIN   = {simulator binary}
  #	SIM_OPTS  = {simulator binary}
***************
*** 17,45 ****
  	"GCC_BIN=/fs3/j/kskadro/SS/release/bin/ssbig-na-sstrix-gcc"
  
  make-bins:
! 	cd bin; $(MAKE) "CC=$(GCC_BIN)" "CFLAGS=$(CFLAGS)"
  
  do-tests: # make-bins
  	-cd results $(CS) $(RM) dummy.out $(CS) cd ..
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/anagram.progout \
  		-redir:sim results/anagram.simout $(SIM_OPTS) \
! 		bin/anagram inputs/words < inputs/input.txt \
  		> results$(X)dummy.out
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-math.progout \
  		-redir:sim results/test-math.simout $(SIM_OPTS) \
! 		bin/test-math
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-printf.progout \
  		-redir:sim results/test-printf.simout $(SIM_OPTS) \
! 		bin/test-printf
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-fmath.progout \
  		-redir:sim results/test-fmath.simout $(SIM_OPTS) \
! 		bin/test-fmath
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-llong.progout \
  		-redir:sim results/test-llong.simout $(SIM_OPTS) \
! 		bin/test-llong
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-lswlr.progout \
! 		-redir:sim results/test-lswlr.simout $(SIM_OPTS)\
! 		bin/test-lswlr
  
  diff-tests:
  	@echo "#"
--- 18,46 ----
  	"GCC_BIN=/fs3/j/kskadro/SS/release/bin/ssbig-na-sstrix-gcc"
  
  make-bins:
! 	cd bin.$(ENDIAN); $(MAKE) "CC=$(GCC_BIN)" "CFLAGS=$(CFLAGS)"
  
  do-tests: # make-bins
  	-cd results $(CS) $(RM) dummy.out $(CS) cd ..
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/anagram.progout \
  		-redir:sim results/anagram.simout $(SIM_OPTS) \
! 		bin.$(ENDIAN)/anagram inputs/words < inputs/input.txt \
  		> results$(X)dummy.out
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-math.progout \
  		-redir:sim results/test-math.simout $(SIM_OPTS) \
! 		bin.$(ENDIAN)/test-math
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-printf.progout \
  		-redir:sim results/test-printf.simout $(SIM_OPTS) \
! 		bin.$(ENDIAN)/test-printf
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-fmath.progout \
  		-redir:sim results/test-fmath.simout $(SIM_OPTS) \
! 		bin.$(ENDIAN)/test-fmath
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-llong.progout \
  		-redir:sim results/test-llong.simout $(SIM_OPTS) \
! 		bin.$(ENDIAN)/test-llong
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-lswlr.progout \
! 		-redir:sim results/test-lswlr.simout $(SIM_OPTS) \
! 		bin.$(ENDIAN)/test-lswlr
  
  diff-tests:
  	@echo "#"
***************
*** 69,90 ****
  	@echo "#"
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/anagram.eio-progout \
  		-redir:sim results/anagram.eio-simout $(SIM_OPTS) \
! 		eio/anagram.eio
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-math.eio-progout \
  		-redir:sim results/test-math.eio-simout $(SIM_OPTS) \
! 		eio/test-math.eio
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-printf.eio-progout \
  		-redir:sim results/test-printf.eio-simout $(SIM_OPTS) \
! 		eio/test-printf.eio
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-fmath.eio-progout \
  		-redir:sim results/test-fmath.eio-simout $(SIM_OPTS) \
! 		eio/test-fmath.eio
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-llong.eio-progout \
  		-redir:sim results/test-llong.eio-simout $(SIM_OPTS) \
! 		eio/test-llong.eio
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-lswlr.eio-progout \
  		-redir:sim results/test-lswlr.eio-simout $(SIM_OPTS) \
! 		eio/test-lswlr.eio
  
  local-tests:
  	$(MAKE) tests-live "SIM_DIR=.." "SIM_BIN=sim-safe"
--- 70,91 ----
  	@echo "#"
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/anagram.eio-progout \
  		-redir:sim results/anagram.eio-simout $(SIM_OPTS) \
! 		eio.$(ENDIAN)/anagram.eio
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-math.eio-progout \
  		-redir:sim results/test-math.eio-simout $(SIM_OPTS) \
! 		eio.$(ENDIAN)/test-math.eio
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-printf.eio-progout \
  		-redir:sim results/test-printf.eio-simout $(SIM_OPTS) \
! 		eio.$(ENDIAN)/test-printf.eio
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-fmath.eio-progout \
  		-redir:sim results/test-fmath.eio-simout $(SIM_OPTS) \
! 		eio.$(ENDIAN)/test-fmath.eio
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-llong.eio-progout \
  		-redir:sim results/test-llong.eio-simout $(SIM_OPTS) \
! 		eio.$(ENDIAN)/test-llong.eio
  	$(SIM_DIR)$(X)$(SIM_BIN) -redir:prog results/test-lswlr.eio-progout \
  		-redir:sim results/test-lswlr.eio-simout $(SIM_OPTS) \
! 		eio.$(ENDIAN)/test-lswlr.eio
  
  local-tests:
  	$(MAKE) tests-live "SIM_DIR=.." "SIM_BIN=sim-safe"
***************
*** 92,106 ****
  tests:
  	$(MAKE) "MAKE=$(MAKE)" "RM=$(RM)" "ENDIAN=$(ENDIAN)" \
  		"SIM_DIR=$(SIM_DIR)" "SIM_BIN=$(SIM_BIN)" \
! 		"SIM_OPTS=$(SIM_OPTS)" "DIFF=$(DIFF)" "X=$(X)" "CS=$(CS)" \
  		do-tests
  	$(MAKE) "MAKE=$(MAKE)" "RM=$(RM)" "ENDIAN=$(ENDIAN)" \
  		"SIM_DIR=$(SIM_DIR)" "SIM_BIN=$(SIM_BIN)" \
! 		"SIM_OPTS=$(SIM_OPTS)" "DIFF=$(DIFF)" "X=$(X)" "CS=$(CS)" \
  		diff-tests
  	$(MAKE) "MAKE=$(MAKE)" "RM=$(RM)" "ENDIAN=$(ENDIAN)" \
  		"SIM_DIR=$(SIM_DIR)" "SIM_BIN=$(SIM_BIN)" \
! 		"SIM_OPTS=$(SIM_OPTS)" "DIFF=$(DIFF)" "X=$(X)" "CS=$(CS)" \
  		tests-eio
  
  clean:
--- 93,107 ----
  tests:
  	$(MAKE) "MAKE=$(MAKE)" "RM=$(RM)" "ENDIAN=$(ENDIAN)" \
  		"SIM_DIR=$(SIM_DIR)" "SIM_BIN=$(SIM_BIN)" \
! 		"SIM_BIN=$(SIM_BIN)" "DIFF=$(DIFF)" "X=$(X)" "CS=$(CS)" \
  		do-tests
  	$(MAKE) "MAKE=$(MAKE)" "RM=$(RM)" "ENDIAN=$(ENDIAN)" \
  		"SIM_DIR=$(SIM_DIR)" "SIM_BIN=$(SIM_BIN)" \
! 		"SIM_BIN=$(SIM_BIN)" "DIFF=$(DIFF)" "X=$(X)" "CS=$(CS)" \
  		diff-tests
  	$(MAKE) "MAKE=$(MAKE)" "RM=$(RM)" "ENDIAN=$(ENDIAN)" \
  		"SIM_DIR=$(SIM_DIR)" "SIM_BIN=$(SIM_BIN)" \
! 		"SIM_BIN=$(SIM_BIN)" "DIFF=$(DIFF)" "X=$(X)" "CS=$(CS)" \
  		tests-eio
  
  clean:
Only in tmp/simplesim-3.0/tests: bin
Only in simplesim-3.0/tests: bin.big
Only in simplesim-3.0/tests: bin.little
Only in tmp/simplesim-3.0/tests: eio
Only in simplesim-3.0/tests: eio.big
Only in simplesim-3.0/tests: eio.little
diff -crB tmp/simplesim-3.0/tests/outputs/anagram.progout simplesim-3.0/tests/outputs/anagram.progout
*** tmp/simplesim-3.0/tests/outputs/anagram.progout	2000-05-26 10:22:26.000000000 -0500
--- simplesim-3.0/tests/outputs/anagram.progout	2000-05-26 10:21:59.000000000 -0500
***************
*** 1,7 ****
  main dictionary has 24475 entries
  3048 bytes wasted
  136 candidates
! Order of search will be uoisdantjklmfephqzrcgbvwxy
  USN Dido tat 
  USN Dido AT&T 
  USN toad tid 
--- 1,7 ----
  main dictionary has 24475 entries
  3048 bytes wasted
  136 candidates
! Order of search will be uoisdantbcefghjklmpqrvwxyz
  USN Dido tat 
  USN Dido AT&T 
  USN toad tid 
***************
*** 260,266 ****
  tuna sod tid 
  tuna sod it'd 
  313 candidates
! Order of search will be bhscoreatklmdnzgpqfijuvwxy
  abc chest rot 
  abc chest tor 
  abc torch EST 
--- 260,266 ----
  tuna sod tid 
  tuna sod it'd 
  313 candidates
! Order of search will be bhscoreatdfgijklmnpquvwxyz
  abc chest rot 
  abc chest tor 
  abc torch EST 
***************
*** 564,568 ****
  cab Seth ROTC 
  cab short etc 
  29 candidates
! Order of search will be ogiurhsbjklmanzepqfdtcvwxy
  Hugo iris 
--- 564,568 ----
  cab Seth ROTC 
  cab short etc 
  29 candidates
! Order of search will be goiuhrsabcdefjklmnpqtvwxyz
  Hugo iris 
diff -crB tmp/simplesim-3.0/tests/outputs/anagram.simout simplesim-3.0/tests/outputs/anagram.simout
*** tmp/simplesim-3.0/tests/outputs/anagram.simout	2000-05-26 10:22:26.000000000 -0500
--- simplesim-3.0/tests/outputs/anagram.simout	2000-05-26 10:21:59.000000000 -0500
***************
*** 1,11 ****
! sim-eio: SimpleScalar/Alpha Tool Set version 3.0 of September, 1998.
  Copyright (c) 1994-1998 by Todd M. Austin.  All Rights Reserved.
  
! warning: section `.comment' ignored...
! sim: tracing execution to EIO file `eio/anagram.eio'...
! sim: command line: ../sim-eio -trace eio/anagram.eio -redir:sim outputs/anagram.simout -redir:prog outputs/anagram.progout bin/anagram inputs/words 
  
! sim: simulation started @ Wed Aug 26 17:00:10 1998, options follow:
  
  sim-eio: This simulator implements simulator support for generating
  external event traces (EIO traces) and checkpoint files.  External
--- 1,10 ----
! sim-eio: SimpleScalar/PISA Tool Set version 3.0 of September, 1998.
  Copyright (c) 1994-1998 by Todd M. Austin.  All Rights Reserved.
  
! sim: tracing execution to EIO file `eio.little/anagram.eio'...
! sim: command line: ../sim-eio -trace eio.little/anagram.eio -redir:sim outputs/anagram.simout -redir:prog outputs/anagram.progout bin.little/anagram inputs/words 
  
! sim: simulation started @ Thu Aug 27 08:01:49 1998, options follow:
  
  sim-eio: This simulator implements simulator support for generating
  external event traces (EIO traces) and checkpoint files.  External
***************
*** 31,37 ****
  -nice                       0 # simulator scheduling priority
  -max:inst                   0 # maximum number of inst's to execute
  -fastfwd                    0 # number of insts skipped before tracing starts
! -trace           eio/anagram.eio # EIO trace file output file name
  # -dump                <null> # specify checkpoint file and trigger: <fname> <range>
  
    Checkpoint range triggers are formatted as follows:
--- 30,36 ----
  -nice                       0 # simulator scheduling priority
  -max:inst                   0 # maximum number of inst's to execute
  -fastfwd                    0 # number of insts skipped before tracing starts
! -trace           eio.little/anagram.eio # EIO trace file output file name
  # -dump                <null> # specify checkpoint file and trigger: <fname> <range>
  
    Checkpoint range triggers are formatted as follows:
***************
*** 54,78 ****
  
  sim: writing EIO file initial checkpoint...
  sim: ** starting functional simulation **
- warning: partially supported sigprocmask() call...
  
  sim: ** simulation statistics **
! sim_num_insn               25729060 # total number of instructions executed
! sim_num_refs                9061656 # total number of loads and stores executed
! sim_elapsed_time                 73 # total simulation time in seconds
! sim_inst_rate           352452.8767 # simulation speed (in insts/sec)
! ld_text_base           0x0120000000 # program text (code) segment base
! ld_text_size                 106496 # program text (code) size in bytes
! ld_data_base           0x0140000000 # program initialized data segment base
! ld_data_size                  71264 # program init'ed `.data' and uninit'ed `.bss' size in bytes
! ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
  ld_stack_size                 16384 # program initial stack size
! ld_prog_entry          0x01200059c0 # program entry point (initial PC)
! ld_environ_base        0x011ff97000 # program environment base address address
  ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
! mem.page_count                   54 # total number of pages allocated
! mem.page_mem                   432k # total size of memory pages allocated
! mem.ptab_misses              455506 # total first level page table misses
! mem.ptab_accesses          44543315 # total page table accesses
! mem.ptab_miss_rate           0.0102 # first level page table miss rate
  
--- 53,76 ----
  
  sim: writing EIO file initial checkpoint...
  sim: ** starting functional simulation **
  
  sim: ** simulation statistics **
! sim_num_insn               18657808 # total number of instructions executed
! sim_num_refs                6217526 # total number of loads and stores executed
! sim_elapsed_time                 21 # total simulation time in seconds
! sim_inst_rate           888467.0476 # simulation speed (in insts/sec)
! ld_text_base             0x00400000 # program text (code) segment base
! ld_text_size                  84320 # program text (code) size in bytes
! ld_data_base             0x10000000 # program initialized data segment base
! ld_data_size                  29604 # program init'ed `.data' and uninit'ed `.bss' size in bytes
! ld_stack_base            0x7fffc000 # program stack segment base (highest address in stack)
  ld_stack_size                 16384 # program initial stack size
! ld_prog_entry            0x00400140 # program entry point (initial PC)
! ld_environ_base          0x7fff8000 # program environment base address address
  ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
! mem.page_count                   97 # total number of pages allocated
! mem.page_mem                   388k # total size of memory pages allocated
! mem.ptab_misses                  99 # total first level page table misses
! mem.ptab_accesses          31740556 # total page table accesses
! mem.ptab_miss_rate           0.0000 # first level page table miss rate
  
diff -crB tmp/simplesim-3.0/tests/outputs/test-fmath.progout simplesim-3.0/tests/outputs/test-fmath.progout
*** tmp/simplesim-3.0/tests/outputs/test-fmath.progout	2000-05-26 10:22:26.000000000 -0500
--- simplesim-3.0/tests/outputs/test-fmath.progout	2000-05-26 10:21:59.000000000 -0500
***************
*** 1,11 ****
  q=4 (int)x=12 (int)y=29
! z=1
! z=1
  z=13
  z=13
  l=6
  l=36
  *lp=216
! z=1.000000
  q=4 x=12.000000 (int)x=12 y=29.000000 (int)y=29
  q = 16  x = 11.700001  y = 23.400000
--- 1,11 ----
  q=4 (int)x=12 (int)y=29
! z=144
! z=841
  z=13
  z=13
  l=6
  l=36
  *lp=216
! z=144.000000
  q=4 x=12.000000 (int)x=12 y=29.000000 (int)y=29
  q = 16  x = 11.700001  y = 23.400000
diff -crB tmp/simplesim-3.0/tests/outputs/test-fmath.simout simplesim-3.0/tests/outputs/test-fmath.simout
*** tmp/simplesim-3.0/tests/outputs/test-fmath.simout	2000-05-26 10:22:26.000000000 -0500
--- simplesim-3.0/tests/outputs/test-fmath.simout	2000-05-26 10:21:59.000000000 -0500
***************
*** 1,11 ****
! sim-eio: SimpleScalar/Alpha Tool Set version 3.0 of September, 1998.
  Copyright (c) 1994-1998 by Todd M. Austin.  All Rights Reserved.
  
! warning: section `.comment' ignored...
! sim: tracing execution to EIO file `eio/test-fmath.eio'...
! sim: command line: ../sim-eio -trace eio/test-fmath.eio -redir:sim outputs/test-fmath.simout -redir:prog outputs/test-fmath.progout bin/test-fmath 
  
! sim: simulation started @ Wed Aug 26 17:01:48 1998, options follow:
  
  sim-eio: This simulator implements simulator support for generating
  external event traces (EIO traces) and checkpoint files.  External
--- 1,10 ----
! sim-eio: SimpleScalar/PISA Tool Set version 3.0 of September, 1998.
  Copyright (c) 1994-1998 by Todd M. Austin.  All Rights Reserved.
  
! sim: tracing execution to EIO file `eio.little/test-fmath.eio'...
! sim: command line: ../sim-eio -trace eio.little/test-fmath.eio -redir:sim outputs/test-fmath.simout -redir:prog outputs/test-fmath.progout bin.little/test-fmath 
  
! sim: simulation started @ Thu Aug 27 08:03:03 1998, options follow:
  
  sim-eio: This simulator implements simulator support for generating
  external event traces (EIO traces) and checkpoint files.  External
***************
*** 31,37 ****
  -nice                       0 # simulator scheduling priority
  -max:inst                   0 # maximum number of inst's to execute
  -fastfwd                    0 # number of insts skipped before tracing starts
! -trace           eio/test-fmath.eio # EIO trace file output file name
  # -dump                <null> # specify checkpoint file and trigger: <fname> <range>
  
    Checkpoint range triggers are formatted as follows:
--- 30,36 ----
  -nice                       0 # simulator scheduling priority
  -max:inst                   0 # maximum number of inst's to execute
  -fastfwd                    0 # number of insts skipped before tracing starts
! -trace           eio.little/test-fmath.eio # EIO trace file output file name
  # -dump                <null> # specify checkpoint file and trigger: <fname> <range>
  
    Checkpoint range triggers are formatted as follows:
***************
*** 54,78 ****
  
  sim: writing EIO file initial checkpoint...
  sim: ** starting functional simulation **
- warning: partially supported sigprocmask() call...
  
  sim: ** simulation statistics **
! sim_num_insn                  19402 # total number of instructions executed
! sim_num_refs                   5864 # total number of loads and stores executed
  sim_elapsed_time                  1 # total simulation time in seconds
! sim_inst_rate            19402.0000 # simulation speed (in insts/sec)
! ld_text_base           0x0120000000 # program text (code) segment base
! ld_text_size                 155648 # program text (code) size in bytes
! ld_data_base           0x0140000000 # program initialized data segment base
! ld_data_size                  41216 # program init'ed `.data' and uninit'ed `.bss' size in bytes
! ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
  ld_stack_size                 16384 # program initial stack size
! ld_prog_entry          0x012000aed0 # program entry point (initial PC)
! ld_environ_base        0x011ff97000 # program environment base address address
  ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
! mem.page_count                   24 # total number of pages allocated
! mem.page_mem                   192k # total size of memory pages allocated
! mem.ptab_misses                 112 # total first level page table misses
! mem.ptab_accesses            373336 # total page table accesses
! mem.ptab_miss_rate           0.0003 # first level page table miss rate
  
--- 53,76 ----
  
  sim: writing EIO file initial checkpoint...
  sim: ** starting functional simulation **
  
  sim: ** simulation statistics **
! sim_num_insn                  53129 # total number of instructions executed
! sim_num_refs                  16248 # total number of loads and stores executed
  sim_elapsed_time                  1 # total simulation time in seconds
! sim_inst_rate            53129.0000 # simulation speed (in insts/sec)
! ld_text_base             0x00400000 # program text (code) segment base
! ld_text_size                  79920 # program text (code) size in bytes
! ld_data_base             0x10000000 # program initialized data segment base
! ld_data_size                  12288 # program init'ed `.data' and uninit'ed `.bss' size in bytes
! ld_stack_base            0x7fffc000 # program stack segment base (highest address in stack)
  ld_stack_size                 16384 # program initial stack size
! ld_prog_entry            0x00400140 # program entry point (initial PC)
! ld_environ_base          0x7fff8000 # program environment base address address
  ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
! mem.page_count                   30 # total number of pages allocated
! mem.page_mem                   120k # total size of memory pages allocated
! mem.ptab_misses                  31 # total first level page table misses
! mem.ptab_accesses            307960 # total page table accesses
! mem.ptab_miss_rate           0.0001 # first level page table miss rate
  
diff -crB tmp/simplesim-3.0/tests/outputs/test-llong.progout simplesim-3.0/tests/outputs/test-llong.progout
*** tmp/simplesim-3.0/tests/outputs/test-llong.progout	2000-05-26 10:22:26.000000000 -0500
--- simplesim-3.0/tests/outputs/test-llong.progout	2000-05-26 10:21:59.000000000 -0500
***************
*** 1,5 ****
! x+1 = 0x0000000000000001
  x-1 = 0x00000000ffffffff
! y+1 = 0x0000000000000000
! x+y = 0x00000000ffffffff
! z*w = 0x00000000f0000000
--- 1,5 ----
! x+1 = 0x0000000100000001
  x-1 = 0x00000000ffffffff
! y+1 = 0x0000000200000000
! x+y = 0x00000002ffffffff
! z*w = 0x01fffffff0000000
diff -crB tmp/simplesim-3.0/tests/outputs/test-llong.simout simplesim-3.0/tests/outputs/test-llong.simout
*** tmp/simplesim-3.0/tests/outputs/test-llong.simout	2000-05-26 10:22:26.000000000 -0500
--- simplesim-3.0/tests/outputs/test-llong.simout	2000-05-26 10:21:59.000000000 -0500
***************
*** 1,11 ****
! sim-eio: SimpleScalar/Alpha Tool Set version 3.0 of September, 1998.
  Copyright (c) 1994-1998 by Todd M. Austin.  All Rights Reserved.
  
! warning: section `.comment' ignored...
! sim: tracing execution to EIO file `eio/test-llong.eio'...
! sim: command line: ../sim-eio -trace eio/test-llong.eio -redir:sim outputs/test-llong.simout -redir:prog outputs/test-llong.progout bin/test-llong 
  
! sim: simulation started @ Wed Aug 26 17:02:38 1998, options follow:
  
  sim-eio: This simulator implements simulator support for generating
  external event traces (EIO traces) and checkpoint files.  External
--- 1,10 ----
! sim-eio: SimpleScalar/PISA Tool Set version 3.0 of September, 1998.
  Copyright (c) 1994-1998 by Todd M. Austin.  All Rights Reserved.
  
! sim: tracing execution to EIO file `eio.little/test-llong.eio'...
! sim: command line: ../sim-eio -trace eio.little/test-llong.eio -redir:sim outputs/test-llong.simout -redir:prog outputs/test-llong.progout bin.little/test-llong 
  
! sim: simulation started @ Thu Aug 27 08:03:51 1998, options follow:
  
  sim-eio: This simulator implements simulator support for generating
  external event traces (EIO traces) and checkpoint files.  External
***************
*** 31,37 ****
  -nice                       0 # simulator scheduling priority
  -max:inst                   0 # maximum number of inst's to execute
  -fastfwd                    0 # number of insts skipped before tracing starts
! -trace           eio/test-llong.eio # EIO trace file output file name
  # -dump                <null> # specify checkpoint file and trigger: <fname> <range>
  
    Checkpoint range triggers are formatted as follows:
--- 30,36 ----
  -nice                       0 # simulator scheduling priority
  -max:inst                   0 # maximum number of inst's to execute
  -fastfwd                    0 # number of insts skipped before tracing starts
! -trace           eio.little/test-llong.eio # EIO trace file output file name
  # -dump                <null> # specify checkpoint file and trigger: <fname> <range>
  
    Checkpoint range triggers are formatted as follows:
***************
*** 54,78 ****
  
  sim: writing EIO file initial checkpoint...
  sim: ** starting functional simulation **
- warning: partially supported sigprocmask() call...
  
  sim: ** simulation statistics **
! sim_num_insn                  10530 # total number of instructions executed
! sim_num_refs                   3411 # total number of loads and stores executed
  sim_elapsed_time                  1 # total simulation time in seconds
! sim_inst_rate            10530.0000 # simulation speed (in insts/sec)
! ld_text_base           0x0120000000 # program text (code) segment base
! ld_text_size                  90112 # program text (code) size in bytes
! ld_data_base           0x0140000000 # program initialized data segment base
! ld_data_size                  28176 # program init'ed `.data' and uninit'ed `.bss' size in bytes
! ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
  ld_stack_size                 16384 # program initial stack size
! ld_prog_entry          0x0120005540 # program entry point (initial PC)
! ld_environ_base        0x011ff97000 # program environment base address address
  ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
! mem.page_count                   16 # total number of pages allocated
! mem.page_mem                   128k # total size of memory pages allocated
! mem.ptab_misses                 149 # total first level page table misses
! mem.ptab_accesses            207498 # total page table accesses
! mem.ptab_miss_rate           0.0007 # first level page table miss rate
  
--- 53,76 ----
  
  sim: writing EIO file initial checkpoint...
  sim: ** starting functional simulation **
  
  sim: ** simulation statistics **
! sim_num_insn                  29312 # total number of instructions executed
! sim_num_refs                  10091 # total number of loads and stores executed
  sim_elapsed_time                  1 # total simulation time in seconds
! sim_inst_rate            29312.0000 # simulation speed (in insts/sec)
! ld_text_base             0x00400000 # program text (code) segment base
! ld_text_size                  70464 # program text (code) size in bytes
! ld_data_base             0x10000000 # program initialized data segment base
! ld_data_size                   8192 # program init'ed `.data' and uninit'ed `.bss' size in bytes
! ld_stack_base            0x7fffc000 # program stack segment base (highest address in stack)
  ld_stack_size                 16384 # program initial stack size
! ld_prog_entry            0x00400140 # program entry point (initial PC)
! ld_environ_base          0x7fff8000 # program environment base address address
  ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
! mem.page_count                   26 # total number of pages allocated
! mem.page_mem                   104k # total size of memory pages allocated
! mem.ptab_misses                  26 # total first level page table misses
! mem.ptab_accesses            242380 # total page table accesses
! mem.ptab_miss_rate           0.0001 # first level page table miss rate
  
diff -crB tmp/simplesim-3.0/tests/outputs/test-lswlr.simout simplesim-3.0/tests/outputs/test-lswlr.simout
*** tmp/simplesim-3.0/tests/outputs/test-lswlr.simout	2000-05-26 10:22:26.000000000 -0500
--- simplesim-3.0/tests/outputs/test-lswlr.simout	2000-05-26 10:21:59.000000000 -0500
***************
*** 1,11 ****
! sim-eio: SimpleScalar/Alpha Tool Set version 3.0 of September, 1998.
  Copyright (c) 1994-1998 by Todd M. Austin.  All Rights Reserved.
  
! warning: section `.comment' ignored...
! sim: tracing execution to EIO file `eio/test-lswlr.eio'...
! sim: command line: ../sim-eio -trace eio/test-lswlr.eio -redir:sim outputs/test-lswlr.simout -redir:prog outputs/test-lswlr.progout bin/test-lswlr 
  
! sim: simulation started @ Wed Aug 26 17:02:20 1998, options follow:
  
  sim-eio: This simulator implements simulator support for generating
  external event traces (EIO traces) and checkpoint files.  External
--- 1,10 ----
! sim-eio: SimpleScalar/PISA Tool Set version 3.0 of September, 1998.
  Copyright (c) 1994-1998 by Todd M. Austin.  All Rights Reserved.
  
! sim: tracing execution to EIO file `eio.little/test-lswlr.eio'...
! sim: command line: ../sim-eio -trace eio.little/test-lswlr.eio -redir:sim outputs/test-lswlr.simout -redir:prog outputs/test-lswlr.progout bin.little/test-lswlr 
  
! sim: simulation started @ Thu Aug 27 08:04:11 1998, options follow:
  
  sim-eio: This simulator implements simulator support for generating
  external event traces (EIO traces) and checkpoint files.  External
***************
*** 31,37 ****
  -nice                       0 # simulator scheduling priority
  -max:inst                   0 # maximum number of inst's to execute
  -fastfwd                    0 # number of insts skipped before tracing starts
! -trace           eio/test-lswlr.eio # EIO trace file output file name
  # -dump                <null> # specify checkpoint file and trigger: <fname> <range>
  
    Checkpoint range triggers are formatted as follows:
--- 30,36 ----
  -nice                       0 # simulator scheduling priority
  -max:inst                   0 # maximum number of inst's to execute
  -fastfwd                    0 # number of insts skipped before tracing starts
! -trace           eio.little/test-lswlr.eio # EIO trace file output file name
  # -dump                <null> # specify checkpoint file and trigger: <fname> <range>
  
    Checkpoint range triggers are formatted as follows:
***************
*** 54,78 ****
  
  sim: writing EIO file initial checkpoint...
  sim: ** starting functional simulation **
- warning: partially supported sigprocmask() call...
  
  sim: ** simulation statistics **
! sim_num_insn                   4829 # total number of instructions executed
! sim_num_refs                   1853 # total number of loads and stores executed
  sim_elapsed_time                  1 # total simulation time in seconds
! sim_inst_rate             4829.0000 # simulation speed (in insts/sec)
! ld_text_base           0x0120000000 # program text (code) segment base
! ld_text_size                  90112 # program text (code) size in bytes
! ld_data_base           0x0140000000 # program initialized data segment base
! ld_data_size                  28064 # program init'ed `.data' and uninit'ed `.bss' size in bytes
! ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
  ld_stack_size                 16384 # program initial stack size
! ld_prog_entry          0x0120005550 # program entry point (initial PC)
! ld_environ_base        0x011ff97000 # program environment base address address
  ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
! mem.page_count                   16 # total number of pages allocated
! mem.page_mem                   128k # total size of memory pages allocated
! mem.ptab_misses                  93 # total first level page table misses
! mem.ptab_accesses            197897 # total page table accesses
! mem.ptab_miss_rate           0.0005 # first level page table miss rate
  
--- 53,76 ----
  
  sim: writing EIO file initial checkpoint...
  sim: ** starting functional simulation **
  
  sim: ** simulation statistics **
! sim_num_insn                   8547 # total number of instructions executed
! sim_num_refs                   4549 # total number of loads and stores executed
  sim_elapsed_time                  1 # total simulation time in seconds
! sim_inst_rate             8547.0000 # simulation speed (in insts/sec)
! ld_text_base             0x00400000 # program text (code) segment base
! ld_text_size                  70240 # program text (code) size in bytes
! ld_data_base             0x10000000 # program initialized data segment base
! ld_data_size                   8192 # program init'ed `.data' and uninit'ed `.bss' size in bytes
! ld_stack_base            0x7fffc000 # program stack segment base (highest address in stack)
  ld_stack_size                 16384 # program initial stack size
! ld_prog_entry            0x00400140 # program entry point (initial PC)
! ld_environ_base          0x7fff8000 # program environment base address address
  ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
! mem.page_count                   26 # total number of pages allocated
! mem.page_mem                   104k # total size of memory pages allocated
! mem.ptab_misses                  26 # total first level page table misses
! mem.ptab_accesses            209405 # total page table accesses
! mem.ptab_miss_rate           0.0001 # first level page table miss rate
  
diff -crB tmp/simplesim-3.0/tests/outputs/test-math.progout simplesim-3.0/tests/outputs/test-math.progout
*** tmp/simplesim-3.0/tests/outputs/test-math.progout	2000-05-26 10:22:26.000000000 -0500
--- simplesim-3.0/tests/outputs/test-math.progout	2000-05-26 10:21:59.000000000 -0500
***************
*** 9,22 ****
  x: 123.456000
  123.456 123.456000 123 1000
  sinh(2.0) = 3.62686
! sinh(3.0) = 10.0179
  h=3.60555
! atan2(3,2) = 0.982794
  pow(3.60555,4.0) = 169
! 169 / exp(0.982794 * 5) = 1.24102
! 3.93117 + 5*log(3.60555) = 10.3435
! cos(10.3435) = -0.606798,  sin(10.3435) = -0.794856
  x     0.5x
  x0.5     x
  x   0.5x
! -1e-17 == -1e-17 Worked!
--- 9,22 ----
  x: 123.456000
  123.456 123.456000 123 1000
  sinh(2.0) = 3.62686
! sinh(3.0) = 10.01787
  h=3.60555
! atan2(3,2) = 0.98279
  pow(3.60555,4.0) = 169
! 169 / exp(0.98279 * 5) = 1.24102
! 3.93117 + 5*log(3.60555) = 10.34355
! cos(10.34355) = -0.6068,  sin(10.34355) = -0.79486
  x     0.5x
  x0.5     x
  x   0.5x
! -1e-17 != -1e-17 Worked!
diff -crB tmp/simplesim-3.0/tests/outputs/test-math.simout simplesim-3.0/tests/outputs/test-math.simout
*** tmp/simplesim-3.0/tests/outputs/test-math.simout	2000-05-26 10:22:26.000000000 -0500
--- simplesim-3.0/tests/outputs/test-math.simout	2000-05-26 10:21:59.000000000 -0500
***************
*** 1,11 ****
! sim-eio: SimpleScalar/Alpha Tool Set version 3.0 of September, 1998.
  Copyright (c) 1994-1998 by Todd M. Austin.  All Rights Reserved.
  
! warning: section `.comment' ignored...
! sim: tracing execution to EIO file `eio/test-math.eio'...
! sim: command line: ../sim-eio -trace eio/test-math.eio -redir:sim outputs/test-math.simout -redir:prog outputs/test-math.progout bin/test-math 
  
! sim: simulation started @ Wed Aug 26 17:02:01 1998, options follow:
  
  sim-eio: This simulator implements simulator support for generating
  external event traces (EIO traces) and checkpoint files.  External
--- 1,10 ----
! sim-eio: SimpleScalar/PISA Tool Set version 3.0 of September, 1998.
  Copyright (c) 1994-1998 by Todd M. Austin.  All Rights Reserved.
  
! sim: tracing execution to EIO file `eio.little/test-math.eio'...
! sim: command line: ../sim-eio -trace eio.little/test-math.eio -redir:sim outputs/test-math.simout -redir:prog outputs/test-math.progout bin.little/test-math 
  
! sim: simulation started @ Thu Aug 27 08:03:17 1998, options follow:
  
  sim-eio: This simulator implements simulator support for generating
  external event traces (EIO traces) and checkpoint files.  External
***************
*** 31,37 ****
  -nice                       0 # simulator scheduling priority
  -max:inst                   0 # maximum number of inst's to execute
  -fastfwd                    0 # number of insts skipped before tracing starts
! -trace           eio/test-math.eio # EIO trace file output file name
  # -dump                <null> # specify checkpoint file and trigger: <fname> <range>
  
    Checkpoint range triggers are formatted as follows:
--- 30,36 ----
  -nice                       0 # simulator scheduling priority
  -max:inst                   0 # maximum number of inst's to execute
  -fastfwd                    0 # number of insts skipped before tracing starts
! -trace           eio.little/test-math.eio # EIO trace file output file name
  # -dump                <null> # specify checkpoint file and trigger: <fname> <range>
  
    Checkpoint range triggers are formatted as follows:
***************
*** 54,78 ****
  
  sim: writing EIO file initial checkpoint...
  sim: ** starting functional simulation **
- warning: partially supported sigprocmask() call...
  
  sim: ** simulation statistics **
! sim_num_insn                  49313 # total number of instructions executed
! sim_num_refs                  13601 # total number of loads and stores executed
  sim_elapsed_time                  1 # total simulation time in seconds
! sim_inst_rate            49313.0000 # simulation speed (in insts/sec)
! ld_text_base           0x0120000000 # program text (code) segment base
! ld_text_size                 188416 # program text (code) size in bytes
! ld_data_base           0x0140000000 # program initialized data segment base
! ld_data_size                  41984 # program init'ed `.data' and uninit'ed `.bss' size in bytes
! ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
  ld_stack_size                 16384 # program initial stack size
! ld_prog_entry          0x012000f750 # program entry point (initial PC)
! ld_environ_base        0x011ff97000 # program environment base address address
  ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
! mem.page_count                   28 # total number of pages allocated
! mem.page_mem                   224k # total size of memory pages allocated
! mem.ptab_misses                  74 # total first level page table misses
! mem.ptab_accesses            482033 # total page table accesses
! mem.ptab_miss_rate           0.0002 # first level page table miss rate
  
--- 53,76 ----
  
  sim: writing EIO file initial checkpoint...
  sim: ** starting functional simulation **
  
  sim: ** simulation statistics **
! sim_num_insn                 213370 # total number of instructions executed
! sim_num_refs                  56803 # total number of loads and stores executed
  sim_elapsed_time                  1 # total simulation time in seconds
! sim_inst_rate           213370.0000 # simulation speed (in insts/sec)
! ld_text_base             0x00400000 # program text (code) segment base
! ld_text_size                  91744 # program text (code) size in bytes
! ld_data_base             0x10000000 # program initialized data segment base
! ld_data_size                  13028 # program init'ed `.data' and uninit'ed `.bss' size in bytes
! ld_stack_base            0x7fffc000 # program stack segment base (highest address in stack)
  ld_stack_size                 16384 # program initial stack size
! ld_prog_entry            0x00400140 # program entry point (initial PC)
! ld_environ_base          0x7fff8000 # program environment base address address
  ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
! mem.page_count                   33 # total number of pages allocated
! mem.page_mem                   132k # total size of memory pages allocated
! mem.ptab_misses                  34 # total first level page table misses
! mem.ptab_accesses            583445 # total page table accesses
! mem.ptab_miss_rate           0.0001 # first level page table miss rate
  
diff -crB tmp/simplesim-3.0/tests/outputs/test-printf.progout simplesim-3.0/tests/outputs/test-printf.progout
*** tmp/simplesim-3.0/tests/outputs/test-printf.progout	2000-05-26 10:22:26.000000000 -0500
--- simplesim-3.0/tests/outputs/test-printf.progout	2000-05-26 10:21:59.000000000 -0500
***************
*** 3,21 ****
  %4.4x:	`0012'
  %04.4x:	`0012'
  %4.3x:	` 012'
! %04.3x:	` 012'
  %.*x:	`0012'
  %0*x:	`0012'
  %*.*x:	`0012'
  %0*.*x:	`0012'
! bad format:	"z"
! nil pointer (padded):	"         0"
  decimal negative:	"-2345"
  octal negative:	"37777773327"
  hex negative:	"fffff6d7"
  long decimal number:	"-123456"
! long octal negative:	"1777777777777777773327"
! long unsigned decimal number:	"18446744073709428160"
  zero-padded LDN:	"-000123456"
  left-adjusted ZLDN:	"-123456   "
  space-padded LDN:	"   -123456"
--- 3,21 ----
  %4.4x:	`0012'
  %04.4x:	`0012'
  %4.3x:	` 012'
! %04.3x:	`0012'
  %.*x:	`0012'
  %0*x:	`0012'
  %*.*x:	`0012'
  %0*.*x:	`0012'
! bad format:	"%z"
! nil pointer (padded):	"     (nil)"
  decimal negative:	"-2345"
  octal negative:	"37777773327"
  hex negative:	"fffff6d7"
  long decimal number:	"-123456"
! long octal negative:	"37777773327"
! long unsigned decimal number:	"4294843840"
  zero-padded LDN:	"-000123456"
  left-adjusted ZLDN:	"-123456   "
  space-padded LDN:	"   -123456"
***************
*** 35,41 ****
  f-style < .1:	"0.001234"
  g-style >= 1:	"12.34"
  g-style >= .1:	"0.1234"
! g-style < .1:	"0.001234"
  g-style big:	"100000000000000000000"
  :new test: 99.85:
   0.10000
--- 35,41 ----
  f-style < .1:	"0.001234"
  g-style >= 1:	"12.34"
  g-style >= .1:	"0.1234"
! g-style < .1:	"0.00123"
  g-style big:	"100000000000000000000"
  :new test: 99.85:
   0.10000
diff -crB tmp/simplesim-3.0/tests/outputs/test-printf.simout simplesim-3.0/tests/outputs/test-printf.simout
*** tmp/simplesim-3.0/tests/outputs/test-printf.simout	2000-05-26 10:22:26.000000000 -0500
--- simplesim-3.0/tests/outputs/test-printf.simout	2000-05-26 10:21:59.000000000 -0500
***************
*** 1,11 ****
! sim-eio: SimpleScalar/Alpha Tool Set version 3.0 of September, 1998.
  Copyright (c) 1994-1998 by Todd M. Austin.  All Rights Reserved.
  
! warning: section `.comment' ignored...
! sim: tracing execution to EIO file `eio/test-printf.eio'...
! sim: command line: ../sim-eio -trace eio/test-printf.eio -redir:sim outputs/test-printf.simout -redir:prog outputs/test-printf.progout bin/test-printf 
  
! sim: simulation started @ Wed Aug 26 17:03:04 1998, options follow:
  
  sim-eio: This simulator implements simulator support for generating
  external event traces (EIO traces) and checkpoint files.  External
--- 1,10 ----
! sim-eio: SimpleScalar/PISA Tool Set version 3.0 of September, 1998.
  Copyright (c) 1994-1998 by Todd M. Austin.  All Rights Reserved.
  
! sim: tracing execution to EIO file `eio.little/test-printf.eio'...
! sim: command line: ../sim-eio -trace eio.little/test-printf.eio -redir:sim outputs/test-printf.simout -redir:prog outputs/test-printf.progout bin.little/test-printf 
  
! sim: simulation started @ Thu Aug 27 08:04:30 1998, options follow:
  
  sim-eio: This simulator implements simulator support for generating
  external event traces (EIO traces) and checkpoint files.  External
***************
*** 31,37 ****
  -nice                       0 # simulator scheduling priority
  -max:inst                   0 # maximum number of inst's to execute
  -fastfwd                    0 # number of insts skipped before tracing starts
! -trace           eio/test-printf.eio # EIO trace file output file name
  # -dump                <null> # specify checkpoint file and trigger: <fname> <range>
  
    Checkpoint range triggers are formatted as follows:
--- 30,36 ----
  -nice                       0 # simulator scheduling priority
  -max:inst                   0 # maximum number of inst's to execute
  -fastfwd                    0 # number of insts skipped before tracing starts
! -trace           eio.little/test-printf.eio # EIO trace file output file name
  # -dump                <null> # specify checkpoint file and trigger: <fname> <range>
  
    Checkpoint range triggers are formatted as follows:
***************
*** 54,78 ****
  
  sim: writing EIO file initial checkpoint...
  sim: ** starting functional simulation **
- warning: partially supported sigprocmask() call...
  
  sim: ** simulation statistics **
! sim_num_insn                 983376 # total number of instructions executed
! sim_num_refs                 282484 # total number of loads and stores executed
  sim_elapsed_time                  3 # total simulation time in seconds
! sim_inst_rate           327792.0000 # simulation speed (in insts/sec)
! ld_text_base           0x0120000000 # program text (code) segment base
! ld_text_size                  98304 # program text (code) size in bytes
! ld_data_base           0x0140000000 # program initialized data segment base
! ld_data_size                  34096 # program init'ed `.data' and uninit'ed `.bss' size in bytes
! ld_stack_base          0x011ff9b000 # program stack segment base (highest address in stack)
  ld_stack_size                 16384 # program initial stack size
! ld_prog_entry          0x01200057f0 # program entry point (initial PC)
! ld_environ_base        0x011ff97000 # program environment base address address
  ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
! mem.page_count                   17 # total number of pages allocated
! mem.page_mem                   136k # total size of memory pages allocated
! mem.ptab_misses                4123 # total first level page table misses
! mem.ptab_accesses           1776821 # total page table accesses
! mem.ptab_miss_rate           0.0023 # first level page table miss rate
  
--- 53,76 ----
  
  sim: writing EIO file initial checkpoint...
  sim: ** starting functional simulation **
  
  sim: ** simulation statistics **
! sim_num_insn                1813561 # total number of instructions executed
! sim_num_refs                 516850 # total number of loads and stores executed
  sim_elapsed_time                  3 # total simulation time in seconds
! sim_inst_rate           604520.3333 # simulation speed (in insts/sec)
! ld_text_base             0x00400000 # program text (code) segment base
! ld_text_size                  74640 # program text (code) size in bytes
! ld_data_base             0x10000000 # program initialized data segment base
! ld_data_size                  13636 # program init'ed `.data' and uninit'ed `.bss' size in bytes
! ld_stack_base            0x7fffc000 # program stack segment base (highest address in stack)
  ld_stack_size                 16384 # program initial stack size
! ld_prog_entry            0x00400140 # program entry point (initial PC)
! ld_environ_base          0x7fff8000 # program environment base address address
  ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
! mem.page_count                   28 # total number of pages allocated
! mem.page_mem                   112k # total size of memory pages allocated
! mem.ptab_misses                  29 # total first level page table misses
! mem.ptab_accesses           3081980 # total page table accesses
! mem.ptab_miss_rate           0.0000 # first level page table miss rate
  
diff -crB tmp/simplesim-3.0/tests/src/Makefile simplesim-3.0/tests/src/Makefile
*** tmp/simplesim-3.0/tests/src/Makefile	2000-05-26 10:22:26.000000000 -0500
--- simplesim-3.0/tests/src/Makefile	2000-05-26 10:21:59.000000000 -0500
***************
*** 1,5 ****
! CC=cc
! CFLAGS=-O5 -non_shared
  
  all: anagram test-printf test-fmath test-math test-llong test-lswlr
  
--- 1,5 ----
! CC=../ssbig-na-sstrix/bin/gcc
! CFLAGS=-g -O3
  
  all: anagram test-printf test-fmath test-math test-llong test-lswlr
  
Only in simplesim-3.0/tests/src: test-as.OUT
Only in simplesim-3.0/tests/src: test-as.s
Only in tmp/simplesim-3.0/tests/src: test-dirent.c
